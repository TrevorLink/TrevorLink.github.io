<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>游戏札记|Stellar Blade</title>
    <link href="/2025/11/18/%E6%B8%B8%E6%88%8F%E6%9C%AD%E8%AE%B0-Stellar-Blade/"/>
    <url>/2025/11/18/%E6%B8%B8%E6%88%8F%E6%9C%AD%E8%AE%B0-Stellar-Blade/</url>
    
    <content type="html"><![CDATA[<p>基础信息</p><p>游戏名称：剑星</p><p>平台：PC</p><p>开始日期：2025&#x2F;10&#x2F;14</p><p>通关日期：2025&#x2F;11&#x2F;15</p><p>版本：本体 &amp; Nikke DLC &amp; NieR Automata DLC</p><p>起因与预期</p><p>作为 2024 年我个人特别喜欢的数毛社编辑 John 的年度游戏列表中的前五名，加上数毛社对其画面视效、优化表现的高度肯定，以及，”传奇制作人”金亨泰的人设（XD），都让我对这款游戏充满了期待。</p><p>早在去年刚发售时 PS5 的独占期我就一直关注，由于这款游戏还算是 PlayStation 第二方 ShiftUp 的处女作，PlayStation 对其的宣传以及技术支持方面也十分到位。在首发时就一度想要购入，后来官方宣布了 DLC 的计划让我推迟了体验的时间，也是直到今年，终于在 PC 上体验了这部作品。</p><p>故事叙事体验</p><ul><li>故事情节是否吸引我？</li><li>角色是否立得住？</li><li>世界观是否有魅力？</li><li>有哪些情节或角色给我留下深刻印象？</li><li>游戏的节奏怎样？（拖沓&#x2F;紧凑）</li><li>叙事方式：直给？环境叙事？碎片化？沉浸式？</li></ul><blockquote><p>注重玩家感受，而不是客观分析。比如：“某段剧情让我浑身发冷”这种就非常有价值。</p></blockquote><p>游戏采用科幻末世题材，故事的世界观充满魅力，和同题材的《尼尔:机械纪元》有类似之处。</p><p>叙事节奏平滑流畅不拖沓，结合优秀的美术环境氛围，将环境叙事融合进剧本中。同时游戏中可探索区域里遍布各类文档资料，逐步碎片化拼接出故事的世界观全貌以及主线的发展铺垫。</p><p>但在角色塑造方面并不算得上十分出众，在游戏前80%的内容中，主角团一行人的行动目标十分明确，并未进行进一步的刻画描写，人物立体度上有些欠缺。游戏临近结尾的部分，针对主角团的几位形象刻画又得到了补充。</p><p>此外，游戏采用了多结局的叙事方式，完成特定条件可以触发三种不同的结局，这是当今游戏业界不常见但是却是我喜闻乐见的一种叙事上的小创意。</p><p>（剧透分割线）</p><hr><p>故事情节的发展波澜曲折</p><p>在一开始玩家扮演的是一名消灭孽奇拔的空降小队成员，是”正义”的一方。</p><p>但是随着剧情的深入以及</p><p>印象比较深刻的地方有：</p><ol><li>希雍酒吧里的恩雅</li></ol><p>在经历了伊芙的无私帮助以及酒吧老板苏的种种豁出性命的尝试后终于找回了自己回忆，找回了自我，也悟出了生命最重要的东西。在酒吧演唱的那一段演出表现、配上伊芙坐在一旁静静聆听的刻画十分美好。</p><ol start="2"><li>伊芙最终对存在意义的讨论</li></ol><p>在故事的一开始，艾德姆在列车上询问伊芙消灭完地球上所有的孽奇拔后下一步要做什么，伊芙对于自己的存在意义一无所知，在那时，伊芙只是完成母主领域任务的一枚棋子。</p><p>随着剧情的推进以及真相的深入了解，伊芙逐渐明白自己存在的价值，也体会到了还在地球生存的希雍的人们的坚持与希望，这里有她想要守护的美好。在故事的最后，伊芙给出了自己的回答：重建地球，重新引领新人类走向新的发展。</p><ol start="3"><li>圣经隐喻</li></ol><p>艾德姆 &#x3D; Adam &#x3D; 亚当</p><p>伊芙 &#x3D; Eve &#x3D; 夏娃</p><p>剧情中三种不同结局里的好结局（牵手结局）也就是亚当与夏娃融合创造了新的人类</p><p>顺带一提，剑星原本不叫剑星，叫夏娃计划，属于是贴脸剧透了XD</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PS2|Video Output</title>
    <link href="/2025/11/18/PS2-Video-Output/"/>
    <url>/2025/11/18/PS2-Video-Output/</url>
    
    <content type="html"><![CDATA[<h1 id="480i和480p"><a href="#480i和480p" class="headerlink" title="480i和480p"></a>480i和480p</h1><p>PS2 上面的游戏基本上都以 <strong>480i &#x2F; 480p</strong> 的格式为主。本质区别主要在以下几个维度：清晰度、画面稳定度、输入延迟、适配屏幕方式等。</p><blockquote><p> 简单来说：<strong>480p 是更清晰、更稳定、更适合现代显示器的逐行扫描模式；480i 是老电视时代常见的隔行扫描模式，会更模糊和闪动。</strong></p></blockquote><h2 id="480i"><a href="#480i" class="headerlink" title="480i"></a><strong>480i</strong></h2><p><code>i</code>表示的是隔行扫描，interlaced</p><p>分辨率：<strong>720×480（隔行）</strong></p><p>显示方式：一次扫描 <strong>奇数行</strong>，下一次扫描 <strong>偶数行</strong></p><p>实际帧率：<strong>每秒 60 个场（fields）&#x3D; 30 帧（frames）</strong></p><p>特征：</p><ul><li>画面轻微抖动（在LCD&#x2F;现代屏幕尤其明显）</li><li>字体和细线会出现锯齿或闪烁</li><li>整体偏模糊</li><li>480i 的输出实际上是专为 CRT 电视设计，CRT 上表现反而很自然</li></ul><h2 id="480p"><a href="#480p" class="headerlink" title="480p"></a><strong>480p</strong></h2><p><code>p</code>表示的是逐行扫描，progressive</p><p>分辨率：<strong>720×480（逐行）</strong></p><p>显示方式：一次扫描整张图画面（全 480 行）</p><p>实际帧率：<strong>60 帧（frames）</strong></p><p>特征：</p><ul><li>更清晰、稳定，无闪烁</li><li>细节表现明显更好</li><li>480p 的画面在现代电视或采集卡上看起来舒服很多</li><li>硬件要求更高，需要 <strong>组件线（Y Pb Pr）</strong> 才能输出</li></ul><h2 id="支持列表"><a href="#支持列表" class="headerlink" title="支持列表"></a>支持列表</h2><p>并不是所有的 PS2 游戏都原生支持 480p 的视频输出，具体的兼容性列表可以参考<a href="https://consolemods.org/wiki/PS2:Games_with_Alternative_Display_Modes">这里</a>。</p><p>对于原生支持 480p 画面输出的游戏，在进入游戏后的 PlayStation 2 标志出现后，按住Δ和X按钮可以激活逐行扫描模式。完成后，游戏通常会加载一个说明如何启用逐行扫描的屏幕。许多游戏只能通过这种方法提供逐行扫描，游戏选项菜单中没有相关选项。这两种方法在向后兼容的 PlayStation 3 上同样有效。</p><p>对于那些原生并不支持 480p 输出的游戏，我们还可以通过 <strong>GS Mode Selector（GSM）</strong> 软件让绝大多数游戏强制 480p，但成功率和画质因游戏而异。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>有CRT设备条件的，480i是一个很好的选择，可以在充分还原游戏创作者意图的同时，在 CRT 设备上得到很好的画面体验。</p><p>如果现有设备已经都是现代显示设备的话，选择480p的输出格式对显示设备更友好，不会出现额外<code>反交错</code>开销，延迟更低，画面更干净，是现代显示设备的最佳选项。</p><h1 id="PAL"><a href="#PAL" class="headerlink" title="PAL"></a>PAL</h1><p>上面我们讨论的是亚洲地区NTSC制式的视频输出格式，但对于欧版的游戏，其视频制式为PAL，在 PS2 上的视频输出格式为 576i。</p><p><strong>576i（50Hz）</strong>与 NTSC 的差别：</p><table><thead><tr><th>项目</th><th>PAL（欧版）</th><th>NTSC（美&#x2F;亚洲）</th></tr></thead><tbody><tr><td>分辨率</td><td>576i</td><td>480i</td></tr><tr><td>场率</td><td>50Hz（时间更慢）</td><td>60Hz（刷新更快）</td></tr><tr><td>场之间时间差</td><td>1&#x2F;50 秒</td><td>1&#x2F;60 秒</td></tr><tr><td>撕裂明显度</td><td>更明显</td><td>更轻微</td></tr></tbody></table><p>PAL 的场间时间更久，导致两个场之间“时间差”更大，画面移动时，上下场差异更大，因此也就导致梳状撕裂更容易肉眼看到。所以 PAL 游戏本来就比 NTSC 更容易出现梳状撕裂(combing artifacts)。</p><p>因此在游玩 PS2 上欧版的游戏时，建议开启 480p 模式。（游戏原生支持就开，不支持建议 GSM 强制开）</p><h1 id="倍线器"><a href="#倍线器" class="headerlink" title="倍线器"></a>倍线器</h1><p>即便是 GSM 也无法让所有 PS2 游戏强制输出 480p 逐行画面，而且还可能存在部分兼容性问题。</p><p>因此想要让 PS2 绝大部分的游戏在现代显示设备上得到良好的画面表现，一个合适的倍线器对视频输出很有帮助，下面以我自己的 GBSC 为例讨论。</p><p>GBSC（开源倍线器）具有非常出色的 <strong>反交错（deinterlacing）</strong> 能力，会把 480i 转换成类似 480p 的逐行信号输出给 HDMI。</p><p>此外，GBSC 对 <strong>逐行（480p）信号</strong> 的处理非常轻松，会直接倍线到我们设置的目标分辨率上，在现代显示设备上兼容性极佳。</p><h2 id="反交错模式"><a href="#反交错模式" class="headerlink" title="反交错模式"></a>反交错模式</h2><p>在 GBSC 的配置菜单中我们可以看到反交错选项中有两个选项：</p><ul><li>BOB</li><li>运动自适应</li></ul><p>对于 99% 的场景，选择运动自适应就是最佳实践。</p><h3 id="BOB（Bob-Deinterlacing）"><a href="#BOB（Bob-Deinterlacing）" class="headerlink" title="BOB（Bob Deinterlacing）"></a><strong>BOB（Bob Deinterlacing）</strong></h3><p><strong>特点：</strong></p><ul><li>每个场（field）都被拉伸为一整帧</li><li>结果是“上下跳动”的轻微抖动（特别是细线、UI边缘）</li><li>处理速度极快 → <strong>极低延迟（几乎 0 ms）</strong></li></ul><p><strong>优点：</strong></p><ul><li>是所有反交错方式中延迟最低</li><li>动态（移动）画面表现不错</li><li>不会出现明显的拖影或“梳状”撕裂</li></ul><p><strong>缺点：</strong></p><ul><li>静态画面会抖，比如菜单、文字</li><li>清晰度低一些</li><li>PS2 字体尤其容易闪</li></ul><p><strong>最适用场景：</strong></p><ul><li>对延迟要求极高的游戏（格斗&#x2F;节奏&#x2F;射击）</li><li>原本画质就较粗糙、抖动不明显的 3D 游戏</li></ul><h3 id="运动自适应（Motion-Adaptive）"><a href="#运动自适应（Motion-Adaptive）" class="headerlink" title="运动自适应（Motion Adaptive）"></a><strong>运动自适应（Motion Adaptive）</strong></h3><p><strong>特点：</strong></p><ul><li>GBSC 会检测画面是否运动：<ul><li>静态部分 → <strong>Weave 合并奇偶场</strong> → 超清晰（相当于伪 480p）</li><li>动态部分 → <strong>BOB</strong> → 不产生撕裂</li></ul></li><li>相当于结合了 Weave 和 BOB 的“智能反交错”</li></ul><p><strong>优点：</strong></p><ul><li>静态画面清晰稳定，不抖</li><li>画质整体明显更好（尤其 PS2 UI）</li><li>没有明显人工感</li><li>对现代屏幕最“自然”</li></ul><p><strong>缺点：</strong></p><ul><li>延迟比 BOB 高一点点（但仍极低：一般约 3~4 ms）</li><li>个别高速闪烁&#x2F;半透明效果可能出现轻微模糊（罕见）</li></ul><p><strong>最适用场景：</strong></p><ul><li><strong>绝大多数 PS2 游戏</strong></li><li>3D 游戏（动作、RPG、竞速）</li><li>字体和 UI 清晰度重要的游戏（JRPG、ACT、菜单多的游戏）</li></ul><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p>通过上面的分析我们不难看出，由于运动自适应这个反交错模式的延迟仍然很低，但因此可以带来更稳定更少瑕疵的画面，因此在绝大多数场景下是最佳选择。</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PS2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java|线程的生命周期</title>
    <link href="/2025/11/17/Java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2025/11/17/Java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>需要注意区分的是，Java中线程的生命周期概念和操作系统中线程的生命周期概念不是一个东西。</p><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>OS中线程的生命周期包含五种：</p><ul><li>创建态：OS完成线程资源的创建。</li><li>就绪态：线程启动但还未获得CPU执行权。</li><li>运行态：线程得到CPU执行权（时间片）正在运行逻辑。</li><li>阻塞态：线程因某些事件（如IO操作，网络请求）等而阻塞住，此时不会占用CPU执行权。</li><li>终止态：线程异常&#x2F;正常执行完毕都会进入终止态。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM中定义的线程的状态包括六种：</p><ul><li>创建态 NEW: 这一点和OS的创建态是对应的</li><li>运行态 RUNNABLE: 对应OS中的就绪态+运行态。</li><li>阻塞态 BLOCKED: <strong>并非OS中的阻塞态</strong>，JVM中的阻塞态<strong>特指</strong>这个线程正在等待获取<strong>监视器锁</strong>时所处的状态。</li><li>有限等待 TIMED_WAITING: 等待<strong>某个特定条件的发生</strong>，通常是<strong>其他线程的某个动作</strong>，但是是有限期的，超时就不等。</li><li>无限等待 WAITING: 和 TIMED_WAITING 类似，只不过是无限期的等。</li><li>终止态 TERMINATED: 线程执行异常或是正常结束后。</li></ul><p>下面我们展开来细说。</p><h3 id="创建态"><a href="#创建态" class="headerlink" title="创建态"></a>创建态</h3><p>当我们新建了一个 Thread 类的对象实例但是还未调用 <code>start()</code> 时，这个线程就一直保持在创建态。</p><h3 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h3><p>调用 Thread 类实例的 <code>start()</code> 来进入。</p><p>在上面我们提到了 JVM 的创建态 &#x3D; OS的就绪态 + OS的运行态，这是因为 <strong>JVM 将 CPU 的调度权交给操作系统（或者说是 JVM 采用 OS 级别的 CPU 调度）</strong>，因此，在 JVM 看来，不管线程有没有实际获得 CPU 时间片在跑，只要他就绪了，这个线程都是在 RUNNABLE 这个运行态的。</p><h3 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h3><p><strong>当且仅当</strong>尝试进入<code>synchronized</code>锁住的代码块或方法，但其他线程已经持有了这个区域的锁时，这个线程才会进入阻塞态。</p><p><code>BLOCKED</code> 状态是 JVM 专为 <code>synchronized</code> 关键字设计的。</p><p>所以 JVM 中的阻塞态并非 OS 中的阻塞态。</p><h3 id="无限等待"><a href="#无限等待" class="headerlink" title="无限等待"></a>无限等待</h3><p>等待<strong>某个特定条件的发生</strong>，通常是<strong>其他线程的某个动作</strong>。</p><p>常见进入条件：</p><ol><li><code>Object.wait()</code>注意必须在<code>synchronized</code>中使用</li><li><code>LockSupport.park()</code></li><li><code>Thread.join()</code></li></ol><p>常见退出条件：</p><ol><li><code>Object.notify() / notifyAll()</code>注意必须在<code>synchronized</code>中使用</li><li><code>LockSupport.unpark()</code></li><li>被 join 的那个线程执行完了</li></ol><blockquote><p>退出后是进入RUNNABLE状态，此时仍需要申请CPU时间片</p></blockquote><h3 id="有限等待"><a href="#有限等待" class="headerlink" title="有限等待"></a>有限等待</h3><p>等待<strong>某个特定条件的发生</strong>，通常是<strong>其他线程的某个动作</strong>。</p><p>常见触发条件：</p><ol><li><code>Thread.sleep(ms)</code></li><li><code>Object.wait(ms)</code>注意必须在<code>synchronized</code>中使用</li><li><code>Thread.join(ms)</code></li></ol><p>常见退出条件：</p><ol><li>时间到了</li><li><code>Object.notify() / notifyAll()</code>注意必须在<code>synchronized</code>中使用</li><li>被 join 的那个线程执行完了</li></ol>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Concurrency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络|自底向上实践</title>
    <link href="/2025/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/11/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="网线直连"><a href="#网线直连" class="headerlink" title="网线直连"></a><strong>网线直连</strong></h1><p>物理层面的端到端连接</p><p>+实现简单粗暴</p><p>-设备数量上升时布线混乱，物理线路数量几何式增长</p><h1 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a><strong>集线器</strong></h1><p>中央设备无脑转发，通过接收方的MAC地址进行区分</p><p>类似同一个房间说话所有人都能听得到，但是每个人都会去”检查”喊的是不是自己，不是的话就不予理会</p><p>+物理层面广播，实现较为简单</p><p>-只支持单工通信。同一个时间只能有一个人在房间内说话</p><p>-带宽浪费，由于是广播因此会浪费不必要的通信成本</p><p>-性能问题，所有设备共享一个相同的集线器带宽，设备越多，网络越拥挤</p><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>“智能学习”、精确通知的集线器</p><p>相比于集线器的广播，交换机内部维护了一个MAC地址映射表，<code>Map&lt;MAC, portNumber&gt;</code></p><p>一开始表没数据，还是通过广播的方式，收到接入设备的应答后更新表数据用于下次精准转发；</p><p>随着接入物理设备的变动，这张表会动态变更。最终实现通信数据的精准转发（指定端口）</p><p>交换机位于计算机网络模型中的数据链路层</p><h1 id="IP-amp-路由"><a href="#IP-amp-路由" class="headerlink" title="IP&amp;路由"></a>IP&amp;路由</h1><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p>随着接入设备的上升，仅靠交换机也不够了。毕竟如果1000多个人，就需要几百个交换机。数据传输开销上而言、以及网络环境复杂度而言都是极为复杂不能接受的。</p><p>要是能将1000多个人<strong>分组</strong>，组内通过MAC进行学习并精准转发指定端口；组与组之间通过某个”管理员”进行消息传递就好了。</p><p>关键是如何设计一个地址系统，让设备既知道自己属于哪个小区，管理员又能据此找到目标小组？</p><p>由于<strong>MAC地址本质上是扁平的</strong>（因为每一个设备都有唯一的MAC地址），就像是身份证号，全国所有人只靠身份证号去检索依然十分困难。而通过精确到省——市——区的<strong>层级</strong>搜索方式，能够更快且精准定位：这就是ip地址系统的设计思想。而那个根据 IP 地址在小组之间转发消息的管理员就是<strong>路由器</strong>。</p><blockquote><p>IP基础计算</p><p>1）IP地址构成：</p><ul><li>IP地址（如192.168.1.11）是32位二进制数，分 4 段显示（四个 8 bit）</li><li>每段0-255，称为”点分十进制”</li></ul><p>在同一个小组（小区），我们一般叫做一个<strong>子网：</strong></p><ul><li>同子网内的设备可以直接通信</li><li>不同子网要通过路由器转发</li></ul><p>2）那么怎么判断是不是在一个子网呢？这就需要提到子网掩码了：</p><p>子网掩码也是由 32 位二进制数组成，连续的 1 表示网络部分，连续的 0 表示主机部分。</p><p>如 255.255.255.0 转为二进制就是 24个1和 8 个 0，简写为 &#x2F;24，表示前面 24 位都是网络部分。</p><p>判断同网段：</p><ul><li><strong>将IP地址和子网掩码做”与”运算，结果相同的IP就在同一网段</strong></li><li>如：192.168.1.11和192.168.1.22都与255.255.255.0运算后得到192.168.1.0</li></ul><p>3）网关：</p><ul><li>通常是路由器的IP地址，作为子网对外的”门户”</li><li>不同子网之间进行通信时，数据先发给网关</li><li>比如192.168.1.1常作为默认网关</li></ul></blockquote><p>需要注意的是，路由器的引入只是随着计算机网络系统复杂度上升所引入的新系统。在之前的例子中，一开始我们通过直连、然后是集线器广播，再到交换机，这些都是通过MAC寻址。而路由器最终发送数据也需要借助MAC地址通过网线。<strong>随着层次上升，对于下层的系统技术只是进行了增强，在最终依赖的路径上并未舍弃</strong>。就像寄快递：</p><ul><li>IP 地址相当于城市、街道：决定包裹该送到哪个区域</li><li>MAC 地址相当于收件人身份信息：最后一步实际交付</li></ul><p>由于最终上层的协议&#x2F;系统技术还是需要下层来进行落地交付，因此位于分层模型中 下层的数据包，数据部分总是会包含完整的上一层的header和数据。</p><p>局域网内数据包传输</p><p>我们假设有两个设备，设备A（IP：192.168.1.11 MAC：AA-11）和设备B（IP：192.168.1.22 MAC：BB-22），现在设备A要向设备B发送数据，忽略更高层的数据包细节，我们现在已经到了网络层。</p><ol><li><p>A要判断B是否和自己在一个局域网内，子网掩码都是&#x2F;24，计算得出在一个子网内。</p></li><li><p>但是要发送数据，光知道 IP 地址是不够的，在同一个子网内，计算机之间要用 MAC 地址通信。</p></li><li><p>所以电脑 A 想：“我得先知道电脑 B 的 MAC 地址”。于是它在局域网内大喊一声（发送<strong>ARP广播</strong>）：**”谁是192.168.1.22啊？请告诉我你的MAC地址！”**</p></li><li><p><strong>同一个子网的所有电脑都收到了这个广播，但发现叫的不是自己，都默默丢弃了</strong>，只有设备 B 回应道：**”192.168.1.22 是我！我的MAC地址是BB-22。”**</p></li><li><p>电脑 A 收到这个回应后，会把 192.168.1.22-BB-22 这个映射关系记在自己本机缓存中，这个就叫 ARP 缓存。</p><p>而这个过程就是 ARP 协议的作用 - <strong>通过IP地址找到对应的MAC地址</strong>。</p></li><li><p>有了 MAC 地址后，设备A就可以直接发送数据包了，它把业务数据包封装成一个特殊的”双层信封”：先在内层信封上写上IP地址”192.168.1.22”（这就是IP头），然后把它放入外层信封，在外层信封上写上”收件人MAC地址：BB-22”（这就是MAC头）。</p><p>这样的双层结构保证了数据包既能通过 IP 地址确定目的地，又能通过 MAC 地址在本地网络中准确投递。</p></li><li><p>路由器(携带交换机功能)看到 MAC 地址，立刻就知道该从哪个端口转发出去，于是数据包就准确送达了设备B。</p></li></ol><p>由于是同一个局域网内，因此在IP包的下一层，也就是数据链路层的时候只需要拿到设备B的MAC地址即可</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>202511|技术日志</title>
    <link href="/2025/11/04/202511-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/"/>
    <url>/2025/11/04/202511-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1104"><a href="#1104" class="headerlink" title="1104"></a>1104</h1><h2 id="计算机网络分层模型"><a href="#计算机网络分层模型" class="headerlink" title="计算机网络分层模型"></a>计算机网络分层模型</h2><p><a href="https://csguide.cn/network/overview/20_protocol.html">参考</a></p><h3 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h3><p>应用层（HTTP FTP POP3 SMTP等）</p><p>表示层（加密、protobuf等序列化协议）</p><p>会话层（Socket API）</p><p>传输层（TCP UDP是重点）</p><p>网络层（IP，ARP）</p><p>数据链路层（MAC）</p><p>物理层（网卡，光纤）</p><h3 id="TCP-x2F-IP四层"><a href="#TCP-x2F-IP四层" class="headerlink" title="TCP&#x2F;IP四层"></a>TCP&#x2F;IP四层</h3><p>应用层（OSI的应用层+表示层+会话层）</p><p>传输层</p><p>网络层</p><p>网络接口层（OSI的物理层和数据链路层）</p><h3 id="封装和解包"><a href="#封装和解包" class="headerlink" title="封装和解包"></a>封装和解包</h3><p>从Source主机出发，一个网络包，从上往下，每一层都会在传输的过程中加上协议对应的Header，这一过程叫做封装。</p><p>之后经过层层设备，这中间可能会进行中间层的封装和解包操作。</p><p>到达目标主机后，从下往上，一层一层提取Header解析内容，这一过程叫做解包。</p><h2 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h2><h3 id="网线直连"><a href="#网线直连" class="headerlink" title="网线直连"></a><strong>网线直连</strong></h3><p>物理层面的端到端连接</p><p>+实现简单粗暴</p><p>-设备数量上升时布线混乱，物理线路数量几何式增长</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a><strong>集线器</strong></h3><p>中央设备无脑转发，通过接收方的MAC地址进行区分</p><p>类似同一个房间说话所有人都能听得到，但是每个人都会去”检查”喊的是不是自己，不是的话就不予理会</p><p>+物理层面广播，实现较为简单</p><p>-只支持单工通信。同一个时间只能有一个人在房间内说话</p><p>-带宽浪费，由于是广播因此会浪费不必要的通信成本</p><p>-性能问题，所有设备共享一个相同的集线器带宽，设备越多，网络越拥挤</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>“智能学习”、精确通知的集线器</p><p>相比于集线器的广播，交换机内部维护了一个MAC地址映射表，<code>Map&lt;MAC, portNumber&gt;</code></p><p>一开始表没数据，还是通过广播的方式，收到接入设备的应答后更新表数据用于下次精准转发；</p><p>随着接入物理设备的变动，这张表会动态变更。最终实现通信数据的精准转发（指定端口）</p><p>交换机位于计算机网络模型中的数据链路层</p><h1 id="1105"><a href="#1105" class="headerlink" title="1105"></a>1105</h1><h2 id="续"><a href="#续" class="headerlink" title="续"></a>续</h2><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>随着接入设备的上升，仅靠交换机也不够了。毕竟如果1000多个人，就需要几百个交换机。数据传输开销上而言、以及网络环境复杂度而言都是极为复杂不能接受的。</p><p>要是能将1000多个人分组，组内通过MAC进行学习并精准转发指定端口；组与组之间通过某个”管理员”进行消息传递就好了。</p><p>关键是如何设计一个地址系统，让设备既知道自己属于哪个小区，管理员又能据此找到目标小组？</p><p>由于<strong>MAC地址本质上是扁平的</strong>（因为每一个设备都有唯一的MAC地址），就像是身份证号，全国所有人只靠身份证号去检索依然十分困难。而通过精确到省——市——区的<strong>层级</strong>搜索方式，能够更快且精准定位：这就是ip地址系统的设计思想。而那个根据 IP 地址在小组之间转发消息的管理员就是<strong>路由器</strong>。</p><blockquote><p>IP基础计算</p><p>1）IP地址构成：</p><ul><li>IP地址（如192.168.1.11）是32位二进制数，分 4 段显示（四个 8 bit）</li><li>每段0-255，称为”点分十进制”</li></ul><p>在同一个小组（小区），我们一般叫做一个<strong>子网：</strong></p><ul><li>同子网内的设备可以直接通信</li><li>不同子网要通过路由器转发</li></ul><p>2）那么怎么判断是不是在一个子网呢？这就需要提到子网掩码了：</p><p>子网掩码也是由 32 位二进制数组成，连续的 1 表示网络部分，连续的 0 表示主机部分。</p><p>如 255.255.255.0 转为二进制就是 24个1和 8 个 0，简写为 &#x2F;24，表示前面 24 位都是网络部分。</p><p>判断同网段：</p><ul><li><strong>将IP地址和子网掩码做”与”运算，结果相同的IP就在同一网段</strong></li><li>如：192.168.1.11和192.168.1.22都与255.255.255.0运算后得到192.168.1.0</li></ul><p>3）网关：</p><ul><li>通常是路由器的IP地址，作为子网对外的”门户”</li><li>不同子网之间进行通信时，数据先发给网关</li><li>比如192.168.1.1常作为默认网关</li></ul></blockquote><p>需要注意的是，路由器的引入只是随着计算机网络系统复杂度上升所引入的新系统。在之前的例子中，一开始我们通过直连、然后是集线器广播，再到交换机，这些都是通过MAC寻址。而路由器最终发送数据也需要借助MAC地址通过网线。<strong>随着层次上升，对于下层的系统技术只是进行了增强，在最终依赖的路径上并未舍弃</strong>。就像寄快递：</p><ul><li>IP 地址相当于城市、街道：决定包裹该送到哪个区域</li><li>MAC 地址相当于收件人身份信息：最后一步实际交付</li></ul><p>由于最终上层的协议&#x2F;系统技术还是需要下层来进行落地交付，因此位于分层模型中下层的数据包，数据部分总是会包含完整的上一层的header和数据。</p><h1 id="1106"><a href="#1106" class="headerlink" title="1106"></a>1106</h1><h2 id="Kafka架构概念整理"><a href="#Kafka架构概念整理" class="headerlink" title="Kafka架构概念整理"></a>Kafka架构概念整理</h2><h3 id="Broker，Topic，Partition，Consumer-Group"><a href="#Broker，Topic，Partition，Consumer-Group" class="headerlink" title="Broker，Topic，Partition，Consumer Group"></a>Broker，Topic，Partition，Consumer Group</h3><p>如果用现实例子来举例：</p><p>Broker: 相当于是快递的网点，某快递在某地有多个网点，网点之间的快件是不同的，从设计上来说增加网点数量是为了增加这一片区域的快件吞吐量</p><p>Topic: 快递分类，大件&#x2F;小件，只是一个逻辑概念，并不会实际存储数据</p><p>Partition: 货架，实际存储数据的物理形式</p><p>Consumer Group: 针对快件的业务处理小队，可能有派送小队，有统计小队。小队与小队之间（消费组之间）都有某个partition全量的消息。但是同一个小队内（同一个消费者组内部）不会重复消费消息。</p><blockquote><p>从原理上来说，之所以同一个消费组内部不会重复消费消息，是因为Kafka topic的消费是依靠offset来标识的。</p><p>offset指示一个partition中的消费进度。</p><p>每一个消费者组都维护一个独立的offset。也就是消费者组id-partition才能确定一个唯一的offset。不同消费组的offset互不干扰</p></blockquote><p>而关联关系上来说：</p><ul><li>同一个消费组内<ul><li>一个消费者可对应多个partition</li><li>但一个topic下的某个partition只能被一个消费组内的一个消费者消费（本质上是避免同组内重复消费）</li></ul></li><li>不同消费组之间<ul><li>一个topic下的某个partition可被n个消费组内的n个消费者消费</li><li>（本质是 “每个消费组独立消费该分区的全量消息”，互不干扰）</li></ul></li></ul><h1 id="1107"><a href="#1107" class="headerlink" title="1107"></a>1107</h1><h2 id="覆盖索引，回表"><a href="#覆盖索引，回表" class="headerlink" title="覆盖索引，回表"></a>覆盖索引，回表</h2><p>参考 <a href="https://trevorlink.github.io/2025/09/01/MySQL-%E7%B4%A2%E5%BC%95/">MySQL 索引</a></p><h1 id="1110"><a href="#1110" class="headerlink" title="1110"></a>1110</h1><h2 id="禁止join以及最佳实践"><a href="#禁止join以及最佳实践" class="headerlink" title="禁止join以及最佳实践"></a>禁止join以及最佳实践</h2><p>这里的禁止一般来说是禁止在三张表以上的关联查询需求时禁止使用join语句。</p><p>原因在于三张表以上join存在严重的性能问题以及会带来数据库侧的查询压力，在高并发场景下应当禁止。</p><p>这一规约的核心思想在于，在高并发环境下，<strong>将数据库侧的密集计算压力，转移到应用业务服务中</strong>进行处理</p><h3 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h3><p>用户购买商品下订单，这里关联三张单独的表</p><p>现在有一个频繁查询的接口，查询所有已经支付的订单（<code>Order</code>）并展示它们对应的用户信息（<code>User</code>）和产品信息（<code>Product</code>）</p><p>如果是简单暴力的SQL，是这样的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    o.<span class="hljs-operator">*</span>, <br>    u.name, <br>    p.product_name <br><span class="hljs-keyword">FROM</span> <br>    t_order o<br><span class="hljs-keyword">JOIN</span> <br>    t_user u <span class="hljs-keyword">ON</span> o.user_id <span class="hljs-operator">=</span> u.id<br><span class="hljs-keyword">JOIN</span> <br>    t_product p <span class="hljs-keyword">ON</span> o.product_id <span class="hljs-operator">=</span> p.id<br><span class="hljs-keyword">WHERE</span> <br>    o.status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;paid&#x27;</span> <span class="hljs-comment">-- 假设这里条件很复杂</span><br>LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><h4 id="①-锁定风暴：高并发的头号杀手-Lock-Contention"><a href="#①-锁定风暴：高并发的头号杀手-Lock-Contention" class="headerlink" title="① 锁定风暴：高并发的头号杀手 (Lock Contention)"></a>① 锁定风暴：高并发的头号杀手 (Lock Contention)</h4><p>这是<strong>最致命</strong>的原因。</p><ul><li><strong>事务变长：</strong> 一个复杂的 <code>JOIN</code> 查询会比单表查询慢几个数量级。</li><li><strong>锁粒度变大：</strong> 这条 <code>JOIN</code> 查询会同时锁定<strong>多张表</strong>中相关的行（InnoDB 的行锁）。</li><li><strong>阻塞与雪崩：</strong> 在高并发时，一个缓慢的 <code>JOIN</code> 事务（A）持有了 3 张表的锁，会导致其他所有试图读写这些表的事务（B, C, D…）全部**阻塞 (Blocking)**。在高并发场景下会迅速耗尽数据库连接池，导致整个服务雪崩。</li></ul><h4 id="②-优化器黑盒：不可控的性能炸弹-Optimizer-Instability"><a href="#②-优化器黑盒：不可控的性能炸弹-Optimizer-Instability" class="headerlink" title="② 优化器黑盒：不可控的性能炸弹 (Optimizer Instability)"></a>② 优化器黑盒：不可控的性能炸弹 (Optimizer Instability)</h4><ul><li><strong><code>JOIN</code> 顺序爆炸：</strong> 2 张表 <code>JOIN</code> 只有 2 种执行顺序（A-&gt;B, B-&gt;A）。3 张表有 6 种。4 张表有 24 种… 随着表增多，MySQL 查询优化器（Optimizer）需要做的“排列组合”呈指数级增长。</li><li><strong>选错执行计划：</strong> 当表越多，优化器越容易“估算失误”（例如选错了驱动表，或者用错了索引），导致本应很快的查询突然退化为全表扫描，造成<strong>不可控的性能抖动</strong>。</li></ul><h4 id="③-数据库资源消耗：CPU-与内存的噩梦"><a href="#③-数据库资源消耗：CPU-与内存的噩梦" class="headerlink" title="③ 数据库资源消耗：CPU 与内存的噩梦"></a>③ 数据库资源消耗：CPU 与内存的噩梦</h4><ul><li><code>JOIN</code> 操作（如 Hash Join, Nested Loop Join）需要大量的 CPU 计算。</li><li>如果 <code>JOIN</code> 无法全部在索引中完成，MySQL 需要在内存中创建<strong>临时表 (Temporary Table)</strong> 或 <strong><code>join_buffer</code></strong> 来排序和匹配数据，这会极大消耗数据库服务器宝贵的内存和 I&#x2F;O 资源。</li></ul><h4 id="④-架构伸缩性差：拖垮整个系统-Poor-Scalability"><a href="#④-架构伸缩性差：拖垮整个系统-Poor-Scalability" class="headerlink" title="④ 架构伸缩性差：拖垮整个系统 (Poor Scalability)"></a>④ 架构伸缩性差：拖垮整个系统 (Poor Scalability)</h4><p>这是架构层面的核心原因。</p><ul><li><strong>应用层（Java）</strong> 是<strong>无状态</strong>的，可以水平扩展（加机器）来分摊压力。</li><li><strong>数据库（MySQL）</strong> 通常是<strong>有状态</strong>的，尤其是主库（写库），是整个系统的<strong>单一瓶颈</strong>。</li><li><strong>结论：</strong> 我们必须不惜一切代价（包括增加 Java 层的复杂度），来保证数据库这个“瓶颈”只做最简单、最快的事情（如：<code>SELECT ... WHERE id = ?</code>）。而 <code>JOIN</code> 这种“重计算”任务，<strong>应该交给可以无限扩展的应用层服务器去做</strong>。</li></ul><h4 id="⑤-业务解耦与微服务：天然的冲突"><a href="#⑤-业务解耦与微服务：天然的冲突" class="headerlink" title="⑤ 业务解耦与微服务：天然的冲突"></a>⑤ 业务解耦与微服务：天然的冲突</h4><p>在微服务架构中，<code>user</code> 表可能在“用户服务”的库里，<code>order</code> 表在“订单服务”的库里。物理上的隔离，使得你<strong>根本无法</strong>使用 <code>JOIN</code>。</p><p>这条规约也是在强制我们，在单体应用中就要养成“服务拆分”的思维，<strong>避免跨业务领域的强耦合查询</strong>。</p><h3 id="应用层组装处理"><a href="#应用层组装处理" class="headerlink" title="应用层组装处理"></a>应用层组装处理</h3><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>核心思想：将臃肿的<code>JOIN</code>等价替换为多个粒度更小，能覆盖到索引，查询效率极快的单表查询，将多个单表查询结果在内存组装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderVO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> Long userId;<br>    <span class="hljs-keyword">private</span> Long productId;<br>    <br>    <span class="hljs-comment">// 组装的数据</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String productName;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span>&#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ProductMapper productMapper;<br><br>    <span class="hljs-meta">@Override</span> <br>    <span class="hljs-keyword">public</span> List&lt;OrderVO&gt; <span class="hljs-title function_">getPaidOrders</span><span class="hljs-params">()</span> &#123;<br>        <br>        <span class="hljs-comment">// --- 步骤 1: 查询主表 (Order) ---</span><br>        <span class="hljs-comment">// 这是一个简单的、基于索引的查询</span><br>          <span class="hljs-comment">// SELECT * FROM t_order WHERE status = &#x27;paid&#x27; LIMIT 10</span><br>        List&lt;Order&gt; orders = orderMapper.findPaidOrders(<span class="hljs-number">10</span>);<br>        <br>        <span class="hljs-keyword">if</span> (orders.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> Collections.emptyList();<br>        &#125;<br><br>        <span class="hljs-comment">// --- 步骤 2: 收集所有需要查询的 ID ---</span><br>        <span class="hljs-comment">// (使用 Java 8 Stream API)</span><br>        List&lt;Long&gt; userIds = orders.stream()<br>                                   .map(Order::getUserId)<br>                                   .distinct() <span class="hljs-comment">// 去重</span><br>                                   .collect(Collectors.toList());<br>        <br>        List&lt;Long&gt; productIds = orders.stream()<br>                                      .map(Order::getProductId)<br>                                      .distinct()<br>                                      .collect(Collectors.toList());<br><br>        <span class="hljs-comment">// --- 步骤 3: 批量查询辅表 (User &amp; Product) ---</span><br>        <span class="hljs-comment">// 关键：使用 WHERE id IN (...)</span><br>        <span class="hljs-comment">// 这是两次最高效的主键查询，速度极快</span><br>          <span class="hljs-comment">// SELECT * FROM t_user WHERE id IN (id1, id2, ...)</span><br>        Map&lt;Long, User&gt; userMap = userMapper.findByIds(userIds)<br>                                          .stream()<br>                                          .collect(Collectors.toMap(User::getId, user -&gt; user));<br>        <br>          <span class="hljs-comment">// SELECT * FROM t_product WHERE id IN (p1, p2, ...)</span><br>        Map&lt;Long, Product&gt; productMap = productMapper.findByIds(productIds)<br>                                                .stream()<br>                                                .collect(Collectors.toMap(Product::getId, product -&gt; product));<br><br>        <span class="hljs-comment">// --- 步骤 4: 在应用层内存中组装数据 ---</span><br>        List&lt;OrderVO&gt; vos = orders.stream().map(order -&gt; &#123;<br>            <span class="hljs-type">OrderVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderVO</span>();<br>            BeanUtils.copyProperties(order, vo); <span class="hljs-comment">// 复制基础属性</span><br>            <br>            <span class="hljs-comment">// 从 Map 中高效获取数据并设置</span><br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMap.get(order.getUserId());<br>            <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) &#123;<br>                vo.setUserName(user.getName());<br>            &#125;<br>            <br>            <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productMap.get(order.getProductId());<br>            <span class="hljs-keyword">if</span> (product != <span class="hljs-literal">null</span>) &#123;<br>                vo.setProductName(product.getProductName());<br>            &#125;<br>            <span class="hljs-keyword">return</span> vo;<br>        &#125;).collect(Collectors.toList());<br><br>        <span class="hljs-keyword">return</span> vos;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ol><li>潜在OOM：如果<code>orders</code>列表非常长，那么查询出的辅助表记录也会很大，不仅查询慢，在生产环境还可能会导致OOM 的问题。考虑在客户端接口场景下通过分页的方式返回接口数据；在内部服务Service部分通过分批处理的方式批量执行n次。限制主表order表查询出来的所有已经支付的 orders 数据量在可控的范围内。</li><li>微服务远程调用：如果辅助表记录查询的服务模块已经拆分，可以考虑采用<code>RPC</code>框架。</li></ol><h3 id="大宽表字段冗余存储"><a href="#大宽表字段冗余存储" class="headerlink" title="大宽表字段冗余存储"></a>大宽表字段冗余存储</h3><p>除了在应用层进行数据组装，还有一种可选的方案是在设计表的时候就进行字段的冗余存储</p><p>原始表结构（简化）：</p><ul><li><code>t_order</code> (id, user_id, product_id, …)</li><li><code>t_user</code> (id, name, …)</li><li><code>t_product</code> (id, product_name, …)</li></ul><p>大宽表设计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_order_full (<br>  order_id <span class="hljs-type">INT</span>,<br>  user_id <span class="hljs-type">INT</span>,   <br>  user_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>  product_id <span class="hljs-type">INT</span>,   <br>  product_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>)<br>);<br></code></pre></td></tr></table></figure><p>这种方式本质上是在<strong>用空间换时间</strong>。</p><p>+简化SQL逻辑</p><p>-数据冗余存储增加成本</p><p>-维护逻辑复杂度提升</p><h4 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h4><p>关于维护逻辑复杂度这一块，我们详细分析，其实是架构设计中常见的数据一致性问题。</p><p>在使用这种方式的时候，用户修改名称&#x2F;产品修改名称时，需要更新大宽表中所有和这个用户&#x2F;产品相关的订单记录。</p><p>在更新的时候不能采用同步事务更新，可能会导致 order 表大量更新记录时锁表，导致服务延时。</p><p>一种最佳实践是采用 MQ 异步通知订阅的方式来实现<strong>最终一致性</strong>。</p><h4 id="最佳实践场景"><a href="#最佳实践场景" class="headerlink" title="最佳实践场景"></a>最佳实践场景</h4><p>因此我们也得出了这种方式适合的场景：</p><ol><li>读多写少</li><li>对数据一致性要求不高，可容忍数据不及时更新，能接受“数据在短时间内可能不一致”这个事实。</li><li><strong>历史快照（Snapshot）：</strong> 某些业务场景可能<strong>要求</strong>保留“下单那一刻”的快照。例如，订单中的 <code>product_name</code> 和 <code>price</code>，即使后来商品改名或降价了，历史订单<strong>也不应该</strong>改变。在这种情况下，“冗余”不再是缺陷，反而成了<strong>必需的功能</strong>。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在高并发场景下，禁止在多表数量3张以上时使用JOIN，尽可能考虑业务层组装数据 &#x2F; 大宽表设计冗余存储</p><ul><li>表结构不好扩展，有强一致性数据要求：用业务层组装数据替换JOIN</li><li>表结构好扩展，可以容忍最终一致性，读多写少，有历史快照数据需求：用大宽表冗余字段设计</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>找工作</tag>
      
      <tag>自我提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java|SPI</title>
    <link href="/2025/10/30/Java-SPI/"/>
    <url>/2025/10/30/Java-SPI/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>SPI &#x3D; Service Producer Interface</p><p>常常会把SPI和API进行对比，他俩之间的区别一言以蔽之就是：</p><ul><li>API暴露功能给外部<strong>用</strong></li><li>SPI是定义规范给外部<strong>扩展</strong></li></ul><h1 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a>JDK SPI</h1><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>下面我们快速看一个demo</p><p>假设我们正在开发一个电商平台。在用户下单后，需要调用支付服务进行付款。平台初期可能只支持“支付宝”，但未来需要方便地扩展，以支持“微信支付”、“信用卡支付”等，而<strong>不希望每次新增支付方式都去修改核心订单业务的代码</strong>。</p><h3 id="结构规划"><a href="#结构规划" class="headerlink" title="结构规划"></a>结构规划</h3><p>为了清晰地展示解耦，我们把项目（逻辑上）分为四个模块：</p><ol><li><code>payment-api</code>：<strong>服务接口模块</strong>。定义支付服务的标准接口 <code>PaymentService</code>。</li><li><code>alipay-provider</code>：<strong>支付宝实现模块</strong>。提供 <code>PaymentService</code> 的支付宝实现。</li><li><code>wechatpay-provider</code>：<strong>微信支付实现模块</strong>。提供 <code>PaymentService</code> 的微信支付实现。</li><li><code>order-system</code>：<strong>服务消费模块</strong>。模拟订单系统，它只依赖 <code>payment-api</code>，并使用 <code>ServiceLoader</code> 来发现并使用所有可用的支付实现。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li><code>payment-api</code> 模块 (定义服务标准)</li></ol><p>这是所有模块都依赖的核心契约。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// package: com.example.payment.api</span><br><br><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 支付服务的标准接口 (Service Interface)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaymentService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理支付请求</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderId 订单ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount  支付金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String orderId, BigDecimal amount)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>alipay-provider</code> 模块 (第一个服务实现)</li></ol><p>实现了支付宝支付的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// package: com.example.payment.alipay</span><br><br><span class="hljs-keyword">import</span> com.example.payment.api.PaymentService;<br><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 支付宝支付实现 (Service Provider Implementation)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentService</span> &#123;<br><br>    <span class="hljs-comment">// SPI要求实现类必须有一个公共的、无参的构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AlipayService</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> &#123;<br>        System.out.printf(<span class="hljs-string">&quot;【支付宝】接收到订单 [%s] 的支付请求，金额：¥ %s%n&quot;</span>, orderId, amount);<br>        <span class="hljs-comment">// ... 此处省略调用支付宝网关的复杂逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;【支付宝】支付成功！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>关键配置 (SPI核心)</strong></p><p>在该模块的 <code>src/main/resources</code> 目录下，创建 <code>META-INF/services/</code> 文件夹，并创建一个文件，文件名是<strong>接口的全限定名</strong>：</p><ul><li><strong>文件名:</strong> <code>com.example.payment.api.PaymentService</code></li><li><strong>文件内容:</strong> <code>com.example.payment.alipay.AlipayService</code> (实现类的全限定名)</li></ul><p>这一步是实现 SPI “服务发现”的核心</p></blockquote><ol start="3"><li><code>wechatpay-provider</code> 模块 (第二个服务实现)</li></ol><p>实现了微信支付的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// package: com.example.payment.wechat</span><br><br><span class="hljs-keyword">import</span> com.example.payment.api.PaymentService;<br><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 微信支付实现 (Service Provider Implementation)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatPayService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeChatPayService</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> &#123;<br>        System.out.printf(<span class="hljs-string">&quot;【微信支付】接收到订单 [%s] 的支付请求，金额：¥ %s%n&quot;</span>, orderId, amount);<br>        <span class="hljs-comment">// ... 此处省略调用微信支付API的复杂逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;【微信支付】支付成功！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>还是需要SPI的配置</p><p>同样，在该模块的 <code>src/main/resources/META-INF/services/</code> 目录下创建同名文件：</p><ul><li><strong>文件名:</strong> <code>com.example.payment.api.PaymentService</code></li><li><strong>文件内容:</strong> <code>com.example.payment.wechat.WeChatPayService</code></li></ul></blockquote><ol start="4"><li><code>order-system</code> 模块 (服务消费者)</li></ol><p>这是我们的主应用，它只知道（依赖） <code>PaymentService</code> 接口，不知道任何具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// package: com.example.order</span><br><br><span class="hljs-keyword">import</span> com.example.payment.api.PaymentService;<br><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><span class="hljs-keyword">import</span> java.util.ServiceLoader;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 模拟一个订单</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;199.99&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;订单系统启动，正在加载所有可用的支付服务...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;----------------------------------------&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 使用 ServiceLoader 动态发现并加载所有 PaymentService 的实现</span><br>        ServiceLoader&lt;PaymentService&gt; services = ServiceLoader.load(PaymentService.class);<br><br>        <span class="hljs-comment">// 3. 检查是否找到了任何支付服务</span><br>        <span class="hljs-keyword">if</span> (!services.iterator().hasNext()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;错误：未找到任何可用的支付服务提供商！请检查类路径。&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4. 遍历所有找到的服务并执行支付 (Java 8+ Stream API 风格)</span><br>        <span class="hljs-comment">// 在实际业务中，可能会根据用户选择调用其中一个</span><br>        services.forEach(service -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;发现支付服务: &quot;</span> + service.getClass().getSimpleName());<br>            service.pay(orderId, amount);<br>            System.out.println(<span class="hljs-string">&quot;----------------------------------------&quot;</span>);<br>        &#125;);<br><br>        System.out.println(<span class="hljs-string">&quot;所有支付流程演示完毕。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>当 <code>OrderApplication</code> 运行时，即使它的代码里没有一行 <code>new AlipayService()</code> 或 <code>new WeChatPayService()</code>，<code>ServiceLoader</code> 也会扫描 classpath，找到 <code>META-INF/services/</code> 下的配置文件，并自动加载和实例化这两个实现类。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">订单系统启动，正在加载所有可用的支付服务...<br>----------------------------------------<br>发现支付服务: AlipayService<br>【支付宝】接收到订单 [some-uuid-string] 的支付请求，金额：¥ 199.99<br>【支付宝】支付成功！<br>----------------------------------------<br>发现支付服务: WeChatPayService<br>【微信支付】接收到订单 [some-uuid-string] 的支付请求，金额：¥ 199.99<br>【微信支付】支付成功！<br>----------------------------------------<br>所有支付流程演示完毕。<br></code></pre></td></tr></table></figure><h2 id="SQL-Driver"><a href="#SQL-Driver" class="headerlink" title="SQL Driver"></a>SQL Driver</h2><p>在JDK的源码中，一个很常见的SPI机制的应用就是JDBC Driver的实现。</p><p>JDK本身只定义了规范，也就是Connection相关的接口，具体如何获取数据以及数据字段类型这些不同数据库厂商的实现细节都放在了不同的驱动jar中。</p><p>不同数据库厂商实现的驱动jar中，都会有一个实现了<code>java.sql.Driver</code>的实现类。</p><p>以MySQL为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mysql.cj.jdbc;<br><br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.sql.Driver &#123;<br>    <span class="hljs-comment">// Register ourselves with the DriverManager.</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Construct a new driver and register it with DriverManager</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">     *             if a database error occurs.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-comment">// Required for Class.forName().newInstance().</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>/resources/META-INF/services</code>中有一个名为<code>java.sql.Driver</code>的文件，内容是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">com.mysql.cj.jdbc.Driver<br></code></pre></td></tr></table></figure><p>实际上不止MySQL的驱动是保持这样的结构，所有JDBC的驱动都需要保持这样的结构。</p><p>当我们调用<code>DriverManager.getConnection(jdbcUrl, username, password)</code>时，就是通过<code>ServiceLoader.load(java.sql.Driver.class)</code>来加载所有classpath下的JDBC驱动包。</p><p>我们没有明确指定使用哪个数据库厂商的<code>JDBC</code>驱动程序，因为<code>DriverManager</code>会自动为我们选择合适的驱动程序：JDK内部都扫描了一次，但是只是有一个驱动能满足我们输入的 jdbcUrl。</p><p>所以这也就是为什么我们只引入了驱动的jar包，但是能够直接通过JDBC的接口开箱即用。</p><p>SPI这种灵活的机制能够保证不修改代码（比如上面的例子中就是JDBC暴露的DriverManager.getConnection）的情况下，对功能进行扩展。</p>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java|JavaMemoryModel</title>
    <link href="/2025/10/23/Java-JavaMemoryModel/"/>
    <url>/2025/10/23/Java-JavaMemoryModel/</url>
    
    <content type="html"><![CDATA[<p>&#x2F;&#x2F;Java 内存模型在设计并发程序的时候至关重要，它规定了<strong>不同线程何时以及如何看到其他线程写入共享变量的值</strong>，以及<strong>在必要时如何同步对共享变量的访问</strong>。</p><p>需要知道的一点是，Java内存区域模型是一个抽象概念的模型。本身还是基于物理机器物理内存的一部分。</p><p><a href="https://javaguide.cn/java/jvm/memory-area.html">https://javaguide.cn/java/jvm/memory-area.html</a></p><h1 id="内存区域模型总览"><a href="#内存区域模型总览" class="headerlink" title="内存区域模型总览"></a>内存区域模型总览</h1><p>以 JDK8 为例，内存区域模型如下：</p><table><thead><tr><th>内存区域</th><th>线程共享or私有</th><th>存储内容</th><th>生命周期</th></tr></thead><tbody><tr><td>PC</td><td>私有</td><td>当前线程执行指令行号</td><td>线程创建时创建，线程结束时销毁</td></tr><tr><td>虚拟机栈</td><td>私有</td><td>栈帧包含局部变量（未逃逸对象）、方法返回地址等</td><td>线程创建时创建，线程结束时销毁</td></tr><tr><td>本地方法栈</td><td>私有</td><td>与虚拟机栈类似，区别是本地方法栈服务于native方法</td><td>线程创建时创建，线程结束时销毁</td></tr><tr><td>堆</td><td>共享</td><td>绝大部分对象（逃逸的），<strong>字符串常量池</strong>，<strong>静态变量</strong></td><td>JVM启动时创建，JVM关闭时销毁</td></tr><tr><td>元空间(方法区)</td><td>共享</td><td>已被虚拟机加载的 <strong>类信息、常量、即时编译器编译后的代码</strong>，运行时常量池</td><td>JVM启动时创建，JVM关闭时销毁</td></tr></tbody></table><h1 id="关键内存区域模型详解"><a href="#关键内存区域模型详解" class="headerlink" title="关键内存区域模型详解"></a>关键内存区域模型详解</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是JMM中最核心的区域，也是JVM垃圾回收器的重点工作区域，也被称作GC堆</p><p>绝大部分程序执行过程中创建的对象都位于堆中</p><blockquote><p>需要注意的是JDK1.7开始引入的逃逸分析优化机制：方法执行过程中如果一个对象未发生逃逸，那么这个对象将在虚拟机栈的栈帧中存储，并且可能会采用标量替换的方式存储。</p><p>这类的对象由于未逃逸出方法作用域，因此生命周期和方法完全相同。</p><p>方法执行结束后，栈帧弹出，对象自动销毁。</p><p>这类的对象不在堆中，自然也不需要进行垃圾回收。</p></blockquote><p>对于堆，重点关注垃圾回收机制（不同垃圾回收算法，对堆进行分代）</p><h3 id="为什么需要分代"><a href="#为什么需要分代" class="headerlink" title="为什么需要分代"></a>为什么需要分代</h3><p>分代是为了更好地管理堆中的对象，更好地回收内存，更快地分配内存</p><h3 id="常见的分代区域"><a href="#常见的分代区域" class="headerlink" title="常见的分代区域"></a>常见的分代区域</h3><p>年轻代：Eden，S0, S1</p><p>老年代：Tenured</p><p>Metaspace</p><table><thead><tr><th>内存区域</th><th>作用</th><th>对象生命周期</th><th>GC 行为</th></tr></thead><tbody><tr><td>伊甸区（Eden）</td><td>新对象 “出生地”</td><td>刚创建的对象（比如<code>new User()</code>）先放这</td><td>频繁回收（Young GC），速度快</td></tr><tr><td>幸存区（Survivor，分 S0 和 S1）</td><td>伊甸区活下来的对象 “暂住地”</td><td>伊甸区 GC 后没被回收的对象，会移到这里</td><td>每次 Young GC 后，存活对象在 S0 和 S1 之间移动，次数够多就进老年代</td></tr><tr><td>老年代（Tenured）</td><td>长期存活对象 “养老院”</td><td>幸存区里活了很多次 GC 的对象（比如静态变量引用的对象）</td><td>很少回收（Full GC），速度慢</td></tr></tbody></table><ol><li>程序代码执行<code>User u1 = new User()</code>：<code>u1</code>对象先进入伊甸区；</li><li>伊甸区满了，触发<strong>Young GC</strong>：没用的对象被回收，<code>u1</code>如果还被引用（比如<code>u1</code>是类的成员变量），就移到幸存区 S0；</li><li>下次伊甸区满了，再触发 Young GC：S0 里没用的对象被回收，<code>u1</code>如果还活着，就移到 S1（同时 S0 清空）；</li><li>这样来回移动几次到达阈值后（默认 15 次），<code>u1</code>如果还活着，就会被 “晋升” 到老年代；</li><li>老年代满了，触发<strong>Full GC</strong>：回收老年代里没用的对象（这个过程很慢，会暂停程序）。</li></ol><h3 id="Young-GC-amp-Full-GC"><a href="#Young-GC-amp-Full-GC" class="headerlink" title="Young GC &amp; Full GC"></a>Young GC &amp; Full GC</h3><table><thead><tr><th>对比维度</th><th>Young GC（年轻代 GC）</th><th>Full GC（老年代 GC）</th></tr></thead><tbody><tr><td>触发条件</td><td>Eden区满</td><td>老年代满</td></tr><tr><td>回收区域</td><td>Eden+幸存区</td><td>老年代 + 年轻代 + 元空间（少数情况）</td></tr><tr><td>执行速度</td><td>快</td><td>慢</td></tr><tr><td>对程序影响</td><td>不大</td><td>很大</td></tr><tr><td>正常频率</td><td>高</td><td>低</td></tr></tbody></table><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>虚拟机栈为线程私有，存储的都是某一个线程执行方法所压入的栈帧。一个方法的调用和结束，对应的就是在虚拟机栈中压入和弹出的过程。</p><p>虚拟机栈中的一个栈帧主要包含：</p><ul><li><strong>局部变量表 (Local Variable Table)：</strong>存储方法参数和方法内部定义的局部变量（也就是未逃逸的变量）</li><li><strong>操作数栈 (Operand Stack)：</strong> 字节码执行引擎工作区。</li><li><strong>动态连接 (Dynamic Linking)：</strong> 指向运行时常量池中的符号引用。</li><li><strong>方法返回地址 (Return Address)：</strong> <em>正常返回</em>（遇到<code>return</code>指令）或<em>异常返回</em>。</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>本质上是JVM定义的一个规范，是<strong>线程共享</strong>的<strong>逻辑区域</strong>。</p><p>具体的实现有两种：永久代（JDK7及以前）和 元空间（JDK8开始）。</p><p>这俩的区别就在于，永久代位于JVM堆中，受堆的空间大小限制；而元空间位于堆外的<strong>本地内存</strong>，只受机器物理内存的限制。</p><p>方法区的规范定义了方法区中存储的是：类加载器信息、类结构信息（字段、方法数据）、<strong>静态变量</strong>、<strong>常量</strong>、<strong>JIT 编译器编译后的代码</strong>。</p><h3 id="为什么要改成元空间"><a href="#为什么要改成元空间" class="headerlink" title="为什么要改成元空间"></a>为什么要改成元空间</h3><p>本质上其实是将原先的”永久代”迁移出了JVM内存，改用本地内存，主要有两点：</p><ol><li>由于方法区中存储的是类加载器信息以及类结构信息、静态数据等，改用本地内存实现的元空间不再像原先永久代那样固定收到JVM空间的限制，可以存储更多的类相关信息</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低（因为基本上运行过程这些数据都要保证存在，很少会回收）</li></ol><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>由于我们上面说到方法区存储的是类相关的结构信息以及一些常量，所以运行时常量池是属于方法区的一部分的</p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>字符串常量池的设计是JDK为了优化性能以及减少重复创建字符串导致的内存开销所设计的常量池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-keyword">return</span> aa == bb; <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="为什么要移动"><a href="#为什么要移动" class="headerlink" title="为什么要移动"></a>为什么要移动</h3><p>在 JDK 1.7及以后，<strong>字符串常量池和静态变量</strong> 放到了堆中</p><p>这是因为原先放在方法区时，由于方法区1.7以前的实现都是永久代，这部分区域的回收频率很低，而且真回收的时候也很慢；这与字符串需要频繁回收的需求相悖。把字符串常量池放入堆中，可以更高效地及时回收字符串</p><h1 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h1><h2 id="HotSpot区域发展变动"><a href="#HotSpot区域发展变动" class="headerlink" title="HotSpot区域发展变动"></a>HotSpot区域发展变动</h2><h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><p>字符串常量池以及静态变量 方法区（永久代） –&gt; 堆</p><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><p>移除JVM中的永久代</p><p>本地内存新增元空间，存储原先永久代剩余的数据（方法区定义的类相关结构数据）</p>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>202510|技术日志</title>
    <link href="/2025/10/09/202510-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/"/>
    <url>/2025/10/09/202510-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1009"><a href="#1009" class="headerlink" title="1009"></a>1009</h1><h2 id="HashMap-null-key"><a href="#HashMap-null-key" class="headerlink" title="HashMap null key"></a>HashMap null key</h2><p>HashMap 允许 null key 的存在</p><p>因为早期HashTable不支持，HashMap作为HashTable的后续替代方案，在设计结构上引入了对null key的支持</p><p>HashMap在计算null key的散列函数时默认会将null key永远设置在0号桶，也正因此HashMap只允许一个null key</p><p>虽然<code>map.put(null, null)</code>是一个合法操作，但是不推荐。因为会导致<code>get(null)</code>仍然返回null，而一般情况我们使用 map ，如果返回null就下意识的认为key不存在，在上面描述的这种情况下，key存在，只是key和value都为null；</p><p>因此判断key是否存在的最佳实践是：应当使用<code>map.containsKey()</code></p><h2 id="单核CPU支持多线程吗"><a href="#单核CPU支持多线程吗" class="headerlink" title="单核CPU支持多线程吗"></a>单核CPU支持多线程吗</h2><p>单核CPU是支持的，在程序执行时底层通过操作系统时间片轮转的方式，把CPU的时间片分给不同的线程执行。</p><p>由于现代CPU的处理速度一般都比较快，虽然受限于单个核心，同一个时间只能执行一个线程，但是可以快速在多个线程之间进行切换，给我们一种多个任务在同时执行的”多线程”的感觉</p><h1 id="1010"><a href="#1010" class="headerlink" title="1010"></a>1010</h1><h2 id="操作系统线程调度方案"><a href="#操作系统线程调度方案" class="headerlink" title="操作系统线程调度方案"></a>操作系统线程调度方案</h2><p>线程调度是 操作系统 管理 <strong>程序线程执行顺序</strong> 以及 <strong>系统整体资源</strong> 的一个重要机制。</p><p>主要可以分为两种调度方案：</p><ul><li>非抢占式调度：任务必须主动让出CPU执行权，否则会一直占用CPU。也就是线程执行完毕后，主动通知系统切换到另一个线程</li><li>抢占式调度：操作系统调度器来统一控制CPU的执行权，调度器可以强制中断CPU对于当前任务的处理，将CPU分配给更高优先级的任务</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th></th><th>抢占式</th><th>非抢占式（协同式调度）</th></tr></thead><tbody><tr><td>切换机制</td><td>调度器强制中断</td><td>任务主动让出</td></tr><tr><td>资源开销</td><td>存在线程上下文切换开销</td><td>不存在线程上下文切换</td></tr><tr><td>死锁饥饿风险</td><td>低，调度器可介入干预</td><td>高，可能一直占用CPU资源</td></tr><tr><td>适用场景</td><td>对响应时间敏感的实时性场景，如现代操作系统；多线程编程场景</td><td>资源有限、协程或事件驱动框架</td></tr></tbody></table><h3 id="常见的抢占式调度机制"><a href="#常见的抢占式调度机制" class="headerlink" title="常见的抢占式调度机制"></a>常见的抢占式调度机制</h3><p>优先级调度：高优先级线程优先执行，Windows的线程调度使用的就是这个机制</p><p>时间片轮转：OS决定每个线程分配到固定时间片轮流执行</p><p>短任务优先：短任务可以抢占长任务的CPU执行权</p><h2 id="单核多线程最佳实践场景"><a href="#单核多线程最佳实践场景" class="headerlink" title="单核多线程最佳实践场景"></a>单核多线程最佳实践场景</h2><p>单核多线程适合IO密集型场景，而多核更适用于CPU密集型计算场景。</p><p>因为IO密集型的任务，CPU利用率低，更多时间是在等待IO设备，瓶颈在IO。采用单核多线程可以让单核的这个CPU在多个IO密集的任务之间轮转执行，最大化利用CPU；</p><p>而CPU密集型的任务，使用多核CPU运行能最大化利用CPU同时获得最大的执行效率。</p><h1 id="1013"><a href="#1013" class="headerlink" title="1013"></a>1013</h1><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><p>并发Concurrency，对应单核CPU，多个任务<strong>同一时间只有一个任务在跑，源于操作系统的线程调度策略快速切换制造 “同时” 的错觉</strong></p><p>并行Parallelism，对应多核CPU，多个任务实际真的在多个物理处理单元上执行</p><h2 id="为什么ConcurrentHashMap不支持null-key"><a href="#为什么ConcurrentHashMap不支持null-key" class="headerlink" title="为什么ConcurrentHashMap不支持null key"></a>为什么ConcurrentHashMap不支持null key</h2><p>关联[HashMap null key注意事项](#HashMap null key)</p><p>ConcurrentHashMap不仅不支持null key，甚至还不支持null value</p><h3 id="二义性问题"><a href="#二义性问题" class="headerlink" title="二义性问题"></a>二义性问题</h3><p>当我们map.get(null)发现等于null的时候，就会出现一个问题：</p><ul><li>是Map中不包含这个null key</li><li>还是Map中包含这个key，只是value是null</li></ul><p>在HashMap中，设计之初就是为了单线程考虑的，我们可以进行这样的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (map.get(<span class="hljs-literal">null</span>) == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">//调用 containsKey 判断 key 是否存在</span><br>    <span class="hljs-keyword">if</span> (!map.containsKey(<span class="hljs-literal">null</span>)) &#123; <br>        map.put(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;error&quot;</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在ConcurrentHashMap中，由于是多线程环境，并且map.get()以及map.containsKey()这两个操作是两个独立的原子操作，因此中间可能存在 “线程切换导致的状态变化”，导致判断结果不一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//假设 ConcurrentHashMap 允许 null key</span><br><span class="hljs-comment">// 线程A执行</span><br><span class="hljs-keyword">if</span> (map.get(<span class="hljs-literal">null</span>) == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 步骤1：线程A判断get(null)返回null（此时map中确实没有null key）</span><br>    <span class="hljs-comment">// 步骤2：线程A执行到此处时，CPU时间片耗尽，线程切换到B</span><br>    <span class="hljs-keyword">if</span> (!map.containsKey(<span class="hljs-literal">null</span>)) &#123;  <span class="hljs-comment">// 步骤4：线程A恢复执行，判断containsKey(null)</span><br>        <span class="hljs-comment">// 步骤5：此时线程B已插入null key，因此containsKey(null)返回true，条件不成立</span><br>        map.put(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;error&quot;</span>);  <span class="hljs-comment">// 步骤6：因此这行代码不会执行，与程序预期出现偏差</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程B在步骤2和步骤4之间执行</span><br>map.put(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;value&quot;</span>);  <span class="hljs-comment">// 步骤3：线程B插入null key，此时map中已有null key</span><br></code></pre></td></tr></table></figure><h1 id="1015"><a href="#1015" class="headerlink" title="1015"></a>1015</h1><h2 id="对象逃逸-amp-标量替换"><a href="#对象逃逸-amp-标量替换" class="headerlink" title="对象逃逸&amp;标量替换"></a>对象逃逸&amp;标量替换</h2><p>本内容属于Java内存模型优化、JVM内存管理相关知识点</p><h3 id="对象逃逸"><a href="#对象逃逸" class="headerlink" title="对象逃逸"></a>对象逃逸</h3><p>对象逃逸是指是对象的作用域超出了某个方法&#x2F;线程</p><p>我们分三种情况进行讨论</p><ul><li>未逃逸</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建对象：仅在当前方法内使用</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); <br>    user.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>    <span class="hljs-comment">// 仅在当前方法内调用对象的方法，没有把对象传出</span><br>    System.out.println(user.getName()); <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法逃逸</li></ul><p>对象被作为方法返回值返回，或被传递给其他方法（但未被其他线程访问），导致其作用范围超出当前方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 场景1：对象被作为返回值返回</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-keyword">return</span> user; <span class="hljs-comment">// 对象逃出当前方法，被外部接收</span><br>&#125;<br><br><span class="hljs-comment">// 场景2：对象被传递给其他方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    otherMethod(user); <span class="hljs-comment">// 对象被传给其他方法，可能在其他方法中被进一步传递</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">(User user)</span> &#123;<br>    <span class="hljs-comment">// 使用user...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述两种方式本质上都是方法内创建的user对象作用域超出了本身的方法</p><ul><li>线程逃逸</li></ul><p>在这种情况下，对象一般会被存储到类的静态变量、实例变量中，或被传递给其他线程（如作为线程的 <code>Runnable</code> 参数），导致其他线程可以访问该对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 场景1：对象被存储到静态变量（全局可见）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> User staticUser;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    staticUser = user; <span class="hljs-comment">// 其他线程可以通过staticUser访问该对象</span><br>&#125;<br><br><span class="hljs-comment">// 场景2：对象被传递给其他线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 其他线程访问该对象</span><br>        System.out.println(user.getName()); <br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="未逃逸对象栈上分配"><a href="#未逃逸对象栈上分配" class="headerlink" title="未逃逸对象栈上分配"></a>未逃逸对象栈上分配</h3><p>在编译期间，JVM引入了一个机制：如果某个对象未发生逃逸，则会将这个对象分配到栈上</p><p>原因是因为栈相比于堆，更适合存储短期存在的对象，减轻GC压力</p><table><thead><tr><th>内存区域</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td>堆</td><td>线程共享，对象需要通过GC回收</td><td>长期存在的对象</td></tr><tr><td>栈</td><td>线程私有，方法内产生创建，方法结束后自动销毁回收</td><td>短期存在的对象</td></tr></tbody></table><p>未逃逸的对象生命周期和方法一致，方法调用时创建，方法执行结束后就应当被回收。这种特性刚好匹配栈的 “自动回收” 机制 —— 无需 GC 介入，方法执行完栈帧弹出，对象内存直接释放，效率远高于堆分配。</p><h3 id="分配前提：未逃逸-标量替换"><a href="#分配前提：未逃逸-标量替换" class="headerlink" title="分配前提：未逃逸+标量替换"></a>分配前提：未逃逸+标量替换</h3><p>当然在栈上的对象并不是完整的对象实例，JVM会通过标量替换优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// User对象未逃逸，可被标量替换</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(); <br>    user.name = <span class="hljs-string">&quot;张三&quot;</span>;  <span class="hljs-comment">// 实际被替换为栈上的&quot;张三&quot;字符串引用</span><br>    user.age = <span class="hljs-number">20</span>;      <span class="hljs-comment">// 实际被替换为栈上的int变量（值20）</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于对象未逃逸，只会在方法内部进行使用，因此在JVM的<strong>标量替换</strong>优化作用下，栈上并不会存储完整的User对象，而是直接在栈上分配 <code>name</code>（引用类型）和 <code>age</code>（int 类型）两个标量，方法结束后随栈帧销毁。</p><h1 id="1016"><a href="#1016" class="headerlink" title="1016"></a>1016</h1><h2 id="包装类缓存"><a href="#包装类缓存" class="headerlink" title="包装类缓存"></a>包装类缓存</h2><p>我们都知道包装类是在基础数据类型的基础上套了一层对象。为了减少对象的创建，JVM引入了对包装类的缓存机制：</p><p>在一定范围内，当我们通过<strong>自动装箱</strong>或使用**<code>valueOf()</code><strong>方法创建包装类对象时，JVM 不会每次都创建新的对象，而是会从一个预先创建好的</strong>内部缓存数组（或称为对象池&#x2F;常量池）**中直接返回已有对象的引用。</p><table><thead><tr><th><strong>包装类</strong></th><th><strong>是否支持缓存</strong></th><th><strong>默认缓存范围</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>Byte</strong></td><td><strong>✅</strong></td><td><code>-128</code> 到 <code>127</code></td><td>缓存<strong>所有</strong>可能的 <code>Byte</code> 值</td></tr><tr><td><strong>Short</strong></td><td><strong>✅</strong></td><td><code>-128</code> 到 <code>127</code></td><td>范围较小，仅缓存常用范围</td></tr><tr><td><strong>Integer</strong></td><td><strong>✅</strong></td><td><code>-128</code> 到 <code>127</code></td><td><strong>最常用</strong>，可通过 <strong>JVM 参数</strong> (<code>-XX:AutoBoxCacheMax</code>) 调整上限</td></tr><tr><td><strong>Long</strong></td><td><strong>✅</strong></td><td><code>-128</code> 到 <code>127</code></td><td>范围较小，仅缓存常用范围</td></tr><tr><td><strong>Character</strong></td><td><strong>✅</strong></td><td><code>\u0000</code> 到 <code>\u007F</code></td><td>对应十进制 <code>0</code> 到 <code>127</code>，缓存<strong>ASCII</strong>字符集</td></tr><tr><td><strong>Boolean</strong></td><td><strong>✅</strong></td><td><code>true</code> 和 <code>false</code></td><td>缓存<strong>所有</strong>可能的 <code>Boolean</code> 值（只有两个）</td></tr><tr><td><strong>Float&#x2F;Double</strong></td><td><strong>❌</strong></td><td>无</td><td><strong>不缓存</strong>，因为浮点数的特性（数量过多、精度问题）不适合缓存</td></tr></tbody></table><p>💡 重点关注：<code>Integer</code> 缓存：默认缓存上限 <code>127</code> 可以通过 <strong>JVM 启动参数</strong> <code>-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来调整（但下限 <code>-128</code> 是固定的，不能调整）</p><p>知道了这一个，下面我们看经典面试题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><br>System.out.println(a == b); <span class="hljs-comment">// 1. true</span><br>System.out.println(c == d); <span class="hljs-comment">// 2. false</span><br></code></pre></td></tr></table></figure><p>值 <code>100</code> 在 <code>Integer</code> 的缓存范围 <code>[-128, 127]</code> 内。<code>a</code> 和 <code>b</code> 都是通过自动装箱（即调用 <code>Integer.valueOf(100)</code>）创建。因此，<code>a</code> 和 <code>b</code> 引用的是<strong>同一个缓存对象</strong>。</p><p>而 200 超出了默认的缓存上限，因此 c 和 d 是两个不同的对象。</p><blockquote><p>需要注意，并不是只要在缓存范围内命中就会返回缓存，只有自动装箱或是调用<code>valueOf()</code>的时候才会采用缓存。</p><p>如果直接new包装类对象，永远都不会命中缓存。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">40</span>);<br>System.out.println(i1==i2); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>在比较两个包装类对象的时候，始终选择用<code>equals()</code>来进行比较。避免使用 <code>==</code> 运算符，因为它比较的是对象的<strong>引用地址</strong>，容易因<strong>包装类的缓存机制的存在而产生意想不到的结果</strong>（如上面的 <code>a == b</code> 和 <code>c == d</code>）。</p><p>但是如果比较的是一个基本数据类和包装类的时候，就要用 <code>==</code> 来比较了。因为此时会自动拆箱，通过 <code>==</code> 来进行基础数据类型的比较。</p><h2 id="拼接字符串时，加号还是StringBuilder"><a href="#拼接字符串时，加号还是StringBuilder" class="headerlink" title="拼接字符串时，加号还是StringBuilder"></a>拼接字符串时，加号还是StringBuilder</h2><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方案</strong></th><th><strong>理由</strong></th><th><strong>核心面试考点</strong></th></tr></thead><tbody><tr><td><strong>少量（2-3 次）</strong> 且在 <strong>同一行</strong> 拼接</td><td>使用 <code>+</code> 运算符</td><td>编译器会自动优化成 <code>StringBuilder</code>（语法糖），代码简洁。</td><td><strong>编译器的自动优化</strong></td></tr><tr><td><strong>循环内</strong> 或 <strong>大量（4 次及以上）</strong> 拼接</td><td>使用 <code>StringBuilder</code></td><td>避免在循环中<strong>重复创建</strong>大量临时的 <code>String</code> 和 <code>StringBuilder</code> 对象，性能开销小。</td><td><strong><code>String</code> 的不可变性</strong>、<strong>对象创建开销</strong></td></tr><tr><td><strong>多线程环境</strong> 下拼接</td><td>使用 <code>StringBuffer</code></td><td><code>StringBuffer</code> 是 <strong>线程安全</strong> 的，但性能比 <code>StringBuilder</code> 稍差。</td><td><strong>线程安全性</strong>、<strong>锁竞争</strong></td></tr></tbody></table><p>需要注意的是在循环中拼接，一定不能用加号，因为加号会触发编译器的语法糖，编译器会将其转为<code>new StringBuilder().append().toString()</code>假设循环 N 次，就会创建 N 个 <code>StringBuilder</code> 对象和 N 个新的 <code>String</code> 对象，导致<strong>大量的对象创建和内存开销</strong>，性能是 O(N2) 级别的。</p><p>如果有循环拼接的场景，且是单线程，采用 StringBuilder，可变字符串，直接修改 <code>value</code>数组</p><h1 id="1021"><a href="#1021" class="headerlink" title="1021"></a>1021</h1><p>整理Java内存模型笔记</p>]]></content>
    
    
    <categories>
      
      <category>技术日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>找工作</tag>
      
      <tag>自我提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式|建造者设计模式Remastered</title>
    <link href="/2025/09/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FRemastered/"/>
    <url>/2025/09/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FRemastered/</url>
    
    <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>建造者设计模式核心解决的是”<strong>复杂对象的分步构建</strong>“问题。</p><p>当一个对象字段很多，并且有的是必选，有的是可选，一般来说我们会写多个构造函数进行重载，然后复用某个构造函数。</p><p>但是这样的实现往往可读性很差，必选字段和可选字段耦合在一起。</p><p>为了解决这一个问题，我们可以使用建造者模式来进行优化。</p><h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><p>在 Java 中，建造者模式的实现通常我们借助<code>public</code>的<strong>静态内部类</strong>(一般命名为<code>Builder</code>)来实现</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>只要遇到下面的几个场景，就可以考虑使用Builder进行重构</p><ul><li>对象字段多，必选和可空字段耦合在多个重载的构造函数，经常会需要传<code>null</code>进行实例化</li><li>对象的部分字段存在依赖关系，实例化流程存在依赖校验逻辑</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>我们以电商系统中的 “订单对象”为例：订单包含<strong>必选属性</strong>（订单 ID、用户 ID、商品列表）和<strong>可选属性</strong>（优惠券、配送地址、支付方式、备注），且部分属性有依赖关系（如选择 “货到付款” 则无法使用优惠券）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-comment">// 必选属性</span><br>    <span class="hljs-keyword">private</span> String orderId;       <span class="hljs-comment">// 订单ID</span><br>    <span class="hljs-keyword">private</span> String userId;        <span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; goods;   <span class="hljs-comment">// 商品列表</span><br>    <span class="hljs-comment">// 可选属性</span><br>    <span class="hljs-keyword">private</span> String couponId;      <span class="hljs-comment">// 优惠券ID（可选）</span><br>    <span class="hljs-keyword">private</span> String address;       <span class="hljs-comment">// 配送地址（可选）</span><br>    <span class="hljs-keyword">private</span> String payType;       <span class="hljs-comment">// 支付方式（可选）</span><br>    <span class="hljs-keyword">private</span> String remark;        <span class="hljs-comment">// 订单备注（可选）</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不使用设计模式"><a href="#不使用设计模式" class="headerlink" title="不使用设计模式"></a>不使用设计模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 产品：复杂订单对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-comment">// 必选属性</span><br>    <span class="hljs-keyword">private</span> String orderId;       <span class="hljs-comment">// 订单ID</span><br>    <span class="hljs-keyword">private</span> String userId;        <span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; goods;   <span class="hljs-comment">// 商品列表</span><br>    <span class="hljs-comment">// 可选属性</span><br>    <span class="hljs-keyword">private</span> String couponId;      <span class="hljs-comment">// 优惠券ID（可选）</span><br>    <span class="hljs-keyword">private</span> String address;       <span class="hljs-comment">// 配送地址（可选）</span><br>    <span class="hljs-keyword">private</span> String payType;       <span class="hljs-comment">// 支付方式（可选）</span><br>    <span class="hljs-keyword">private</span> String remark;        <span class="hljs-comment">// 订单备注（可选）</span><br>    <br>    <span class="hljs-comment">// 痛点1：构造方法膨胀——必选+可选属性组合导致重载泛滥</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(String orderId, String userId, List&lt;String&gt; goods)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderId = orderId;<br>        <span class="hljs-built_in">this</span>.userId = userId;<br>        <span class="hljs-built_in">this</span>.goods = goods;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重载1：添加优惠券</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(String orderId, String userId, List&lt;String&gt; goods, String couponId)</span> &#123;<br>        <span class="hljs-built_in">this</span>(orderId, userId, goods);<br>        <span class="hljs-built_in">this</span>.couponId = couponId;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重载2：添加优惠券+地址</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(String orderId, String userId, List&lt;String&gt; goods, String couponId, String address)</span> &#123;<br>        <span class="hljs-built_in">this</span>(orderId, userId, goods, couponId);<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重载3：添加优惠券+地址+支付方式...（属性越多，重载越多）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(String orderId, String userId, List&lt;String&gt; goods, String couponId, String address, String payType)</span> &#123;<br>        <span class="hljs-built_in">this</span>(orderId, userId, goods, couponId, address);<br>        <span class="hljs-built_in">this</span>.payType = payType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//如果选择货到付款则无法再次使用优惠券</span><br>    &#125;<br>     <br>    <span class="hljs-comment">//省略 getter setter</span><br> &#125;<br></code></pre></td></tr></table></figure><p>我们的客户端一般来说是Service类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 客户端：创建订单（痛点集中体现）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 准备必选参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ORDER_20240520_001&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;USER_1001&quot;</span>;<br>        List&lt;String&gt; goods = Arrays.asList(<span class="hljs-string">&quot;手机&quot;</span>, <span class="hljs-string">&quot;耳机&quot;</span>);<br>        <br>        <span class="hljs-comment">// 痛点2：参数顺序易混淆——若需添加备注，需找到对应重载，且参数位置易写错</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(orderId, userId, goods, <span class="hljs-string">&quot;COUPON_50&quot;</span>, <span class="hljs-string">&quot;北京市朝阳区&quot;</span>, <span class="hljs-string">&quot;ALIPAY&quot;</span>);<br>        <br>        <span class="hljs-comment">// 痛点3：可选属性缺失时，需传null占位，代码丑陋且易出错</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(orderId, userId, goods, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;上海市浦东新区&quot;</span>, <span class="hljs-literal">null</span>);<br>        <br>        <span class="hljs-comment">// 痛点4：构建过程无校验——若选择“货到付款”却传了支付方式，无法在创建时拦截</span><br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(orderId, userId, goods, <span class="hljs-string">&quot;COUPON_30&quot;</span>, <span class="hljs-string">&quot;广州市天河区&quot;</span>, <span class="hljs-string">&quot;CASH_ON_DELIVERY&quot;</span>);<br>        order3.setPayType(<span class="hljs-string">&quot;WECHAT&quot;</span>); <span class="hljs-comment">// 后续修改对象可能破坏逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用建造者模式"><a href="#使用建造者模式" class="headerlink" title="使用建造者模式"></a>使用建造者模式</h2><ol><li>新建静态内部类Builder，将必要参数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String orderId;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String userId;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; goods;<br><br>   <span class="hljs-keyword">private</span> String couponId;<br>   <span class="hljs-keyword">private</span> String address;<br>   <span class="hljs-keyword">private</span> String payType;<br>   <span class="hljs-keyword">private</span> String remark;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(String orderId, String userId, List&lt;String&gt; goods)</span> &#123;<br>      <span class="hljs-built_in">this</span>.orderId = orderId;<br>      <span class="hljs-built_in">this</span>.userId = userId;<br>      <span class="hljs-built_in">this</span>.goods = goods;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>私有化构造函数，入参只有Builder</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>   <span class="hljs-comment">// 必选属性</span><br>   <span class="hljs-keyword">private</span> String orderId;       <span class="hljs-comment">// 订单ID</span><br>   <span class="hljs-keyword">private</span> String userId;        <span class="hljs-comment">// 用户ID</span><br>   <span class="hljs-keyword">private</span> List&lt;String&gt; goods;   <span class="hljs-comment">// 商品列表</span><br>   <span class="hljs-comment">// 可选属性</span><br>   <span class="hljs-keyword">private</span> String couponId;      <span class="hljs-comment">// 优惠券ID（可选）</span><br>   <span class="hljs-keyword">private</span> String address;       <span class="hljs-comment">// 配送地址（可选）</span><br>   <span class="hljs-keyword">private</span> String payType;       <span class="hljs-comment">// 支付方式（可选）</span><br>   <span class="hljs-keyword">private</span> String remark;        <span class="hljs-comment">// 订单备注（可选）</span><br><br>   <span class="hljs-comment">// 禁止外部直接实例化 Order 对象  </span><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(Builder builder)</span> &#123;<br>      <span class="hljs-built_in">this</span>.orderId = builder.orderId;<br>      <span class="hljs-built_in">this</span>.userId = builder.userId;<br>      <span class="hljs-built_in">this</span>.goods = builder.goods;<br>      <span class="hljs-built_in">this</span>.couponId = builder.couponId;<br>      <span class="hljs-built_in">this</span>.address = builder.address;<br>      <span class="hljs-built_in">this</span>.payType = builder.payType;<br>      <span class="hljs-built_in">this</span>.remark = builder.remark;<br>   &#125;<br>     <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String orderId;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String userId;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; goods;<br><br>      <span class="hljs-keyword">private</span> String couponId;<br>      <span class="hljs-keyword">private</span> String address;<br>      <span class="hljs-keyword">private</span> String payType;<br>      <span class="hljs-keyword">private</span> String remark;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(String orderId, String userId, List&lt;String&gt; goods)</span> &#123;<br>         <span class="hljs-built_in">this</span>.orderId = orderId;<br>         <span class="hljs-built_in">this</span>.userId = userId;<br>         <span class="hljs-built_in">this</span>.goods = goods;<br>      &#125;<br><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>实现Builder类链式set方法以及核心构建最终对象的<code>build()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String orderId;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String userId;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; goods;<br><br>   <span class="hljs-keyword">private</span> String couponId;<br>   <span class="hljs-keyword">private</span> String address;<br>   <span class="hljs-keyword">private</span> String payType;<br>   <span class="hljs-keyword">private</span> String remark;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(String orderId, String userId, List&lt;String&gt; goods)</span> &#123;<br>      <span class="hljs-built_in">this</span>.orderId = orderId;<br>      <span class="hljs-built_in">this</span>.userId = userId;<br>      <span class="hljs-built_in">this</span>.goods = goods;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//根据业务要求进行参数校验</span><br>      <span class="hljs-keyword">if</span> (payType != <span class="hljs-literal">null</span> &amp;&amp; !payType.isEmpty()<br>              &amp;&amp; <span class="hljs-string">&quot;CASH_ON_DELIVERY&quot;</span>.equals(payType)<br>              &amp;&amp; couponId != <span class="hljs-literal">null</span> &amp;&amp; !couponId.isEmpty()) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;PAY ON DELIVERED NOT SUPPORT COUPON&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-built_in">this</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setCouponId</span><span class="hljs-params">(String couponId)</span> &#123;<br>      <span class="hljs-built_in">this</span>.couponId = couponId;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setAddress</span><span class="hljs-params">(String address)</span> &#123;<br>      <span class="hljs-built_in">this</span>.address = address;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setPayType</span><span class="hljs-params">(String payType)</span> &#123;<br>      <span class="hljs-built_in">this</span>.payType = payType;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">setRemark</span><span class="hljs-params">(String remark)</span> &#123;<br>      <span class="hljs-built_in">this</span>.remark = remark;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>客户端只能先实例化 Builer 对象后调用<code>build()</code>才能实例业务对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 准备必选参数</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ORDER_20240520_001&quot;</span>;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;USER_1001&quot;</span>;<br>      List&lt;String&gt; goods = Arrays.asList(<span class="hljs-string">&quot;手机&quot;</span>, <span class="hljs-string">&quot;耳机&quot;</span>);<br><br>      <span class="hljs-type">Order</span> <span class="hljs-variable">order1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>.Builder(orderId, userId, goods)<br>              .setCouponId(<span class="hljs-string">&quot;COUPON_50&quot;</span>)<br>              .setAddress(<span class="hljs-string">&quot;北京市朝阳区&quot;</span>)<br>              .setPayType(<span class="hljs-string">&quot;ALIPAY&quot;</span>)<br>              .build();<br><br>      <span class="hljs-type">Order</span> <span class="hljs-variable">order2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>.Builder(orderId, userId, goods)<br>              .setAddress(<span class="hljs-string">&quot;上海市浦东新区&quot;</span>)<br>              .build();<br><br>      <span class="hljs-type">Order</span> <span class="hljs-variable">order3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>.Builder(orderId, userId, goods)<br>              .setCouponId(<span class="hljs-string">&quot;COUPON_30&quot;</span>)<br>              .setPayType(<span class="hljs-string">&quot;CASH_ON_DELIVERY&quot;</span>)<br>              .build();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一般情况下，当出现下述的场景时，可以考虑使用建造者设计模式进行重构：</p><ul><li>对象字段数量多且复杂，并且部分字段是可选的。</li><li>现有的构造函数很多而且臃肿，可选字段只能通过传递<code>null</code>的方式才能实例化，可读性依托。</li><li>业务对象的字段之间存在某些关联，需要在实例化阶段进行校验。</li></ul><p>针对上述的痛点，使用建造者设计模式来重构可以根据以下的步骤：</p><ol><li>区分必选字段和可选字段都有哪些。</li><li>在对象类中新增静态内部类<code>Builder</code>，将必选字段作为<code>Builder</code>的构造函数参数。</li><li>私有化业务对象的构造函数，并只接收<code>Builder</code>参数，防止外部直接实例化。</li><li>对于可选字段，<code>Builder</code>中提供<code>setter()和build()</code>，只有<code>build()</code>才能实例化业务对象。</li><li>根据业务需要，在<code>build()</code>中先进行逻辑校验后再返回业务对象实例。</li></ol><p>通过上述的重构实现，我们不仅简化了复杂对象多个字段实例化时构造函数臃肿的问题，同时也更加优雅地处理了业务对象依赖字段的校验逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程交替打印0-100</title>
    <link href="/2025/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B00-100/"/>
    <url>/2025/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B00-100/</url>
    
    <content type="html"><![CDATA[<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>本质上这一题是考察对于线程等待同步机制的掌握</p><p>核心思路是：</p><ol><li>两个线程（分别称其为打印奇数和偶数的线程）共同持有一个锁，这个锁是用来打印的，只有获取到这个锁才能进行打印。</li><li>打印奇数和偶数的线程分别先判断共享变量是奇数还是偶数<ol><li>如果是符合自己当前要求的数，就打印，打印完唤醒另一个等待的线程</li><li>如果不是自己当前要求的数，就释放锁，给另一个线程打印</li></ol></li></ol><h2 id="synchronized-wait-x2F-notify"><a href="#synchronized-wait-x2F-notify" class="headerlink" title="synchronized + wait&#x2F;notify"></a>synchronized + wait&#x2F;notify</h2><p>基于JVM级别自动获取和释放锁的 <code>synchronized + Object.wait()/Object.notify()</code> 我们有了如下的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiThreadPrint</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRINT_LOCK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; printNum(<span class="hljs-literal">false</span>), <span class="hljs-string">&quot;odd thread&quot;</span>);<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">even</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; printNum(<span class="hljs-literal">true</span>), <span class="hljs-string">&quot;even thread&quot;</span>);<br><br>      even.start();<br>      odd.start();<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNum</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isEven)</span> &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>         <span class="hljs-keyword">synchronized</span> (PRINT_LOCK) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt; MAX_NUM) &#123;<br>               PRINT_LOCK.notify();<br>               <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> isEven ? num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> : num % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (condition) &#123;<br>               System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:num=&quot;</span> + num++);<br>               PRINT_LOCK.notify();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                  PRINT_LOCK.wait();<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  Thread.currentThread().interrupt();<br>                  <span class="hljs-keyword">return</span>;<br>               &#125;<br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ReentrantLock-Condition"><a href="#ReentrantLock-Condition" class="headerlink" title="ReentrantLock + Condition"></a>ReentrantLock + Condition</h2><p>ReentrantLock 可以看作是 synchronized 的升级版，支持的功能更多。配合 Condition 使用可以实现类似 synchronized + wait&#x2F;notify 的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiThreadPrintReentrantLock</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">LOCK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">ODD_PRINT</span> <span class="hljs-operator">=</span> LOCK.newCondition();<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">EVEN_PRINT</span> <span class="hljs-operator">=</span> LOCK.newCondition();<br><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">evenThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; printNum(<span class="hljs-literal">true</span>), <span class="hljs-string">&quot;evenThread&quot;</span>);<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">oddThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; printNum(<span class="hljs-literal">false</span>), <span class="hljs-string">&quot;oddThread&quot;</span>);<br>      evenThread.start();<br>      oddThread.start();<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNum</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isEven)</span> &#123;<br>      <span class="hljs-type">Condition</span> <span class="hljs-variable">signalCondition</span> <span class="hljs-operator">=</span> isEven ? ODD_PRINT : EVEN_PRINT;<br>      <span class="hljs-type">Condition</span> <span class="hljs-variable">awaitCondition</span> <span class="hljs-operator">=</span> isEven ? EVEN_PRINT : ODD_PRINT;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>         LOCK.lock();<br>         <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (num &gt; MAX_COUNT) &#123;<br>               ODD_PRINT.signal();<br>               EVEN_PRINT.signal();<br>               <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">print</span> <span class="hljs-operator">=</span> isEven ? num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> : num % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (print) &#123;<br>               System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:num=&quot;</span> + num);<br>               num++;<br>               signalCondition.signal();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                  awaitCondition.await();<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  Thread.currentThread().interrupt();<br>                  <span class="hljs-keyword">return</span>;<br>               &#125;<br>            &#125;<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>            LOCK.unlock();<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式|策略模式</title>
    <link href="/2025/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>策略模式的核心目的在于：解决 <strong>算法 &#x2F; 行为选择</strong> 问题：封装不同的业务逻辑（算法），让逻辑可替换、可扩展</p><h1 id="核心角色"><a href="#核心角色" class="headerlink" title="核心角色"></a>核心角色</h1><h2 id="通用的抽象策略"><a href="#通用的抽象策略" class="headerlink" title="通用的抽象策略"></a>通用的抽象策略</h2><p>是一个接口，定义了不同业务逻辑算法相同的抽象，相同的入参，相同的返回值类型</p><h2 id="策略实现类"><a href="#策略实现类" class="headerlink" title="策略实现类"></a>策略实现类</h2><p>实现通用的抽象策略接口</p><h2 id="策略上下文"><a href="#策略上下文" class="headerlink" title="策略上下文"></a>策略上下文</h2><p>选择和使用不同的策略</p><h2 id="业务注入"><a href="#业务注入" class="headerlink" title="业务注入"></a>业务注入</h2><p>在业务中使用时，通过上下文来选择使用不同策略</p><h1 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h1><p>我们以经典的支付问题为例，原先没有使用设计模式的代码是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentService</span> &#123;<br>    <span class="hljs-comment">// 支付方式常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ALIPAY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alipay&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WECHAT_PAY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wechat&quot;</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 统一支付方法（包含所有支付逻辑）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> paymentType 支付方式</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount 金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> accountInfo 账户信息（支付宝账号/微信openId/银行卡号）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String paymentType, <span class="hljs-type">double</span> amount, String accountInfo)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始支付...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 用大量if-else判断处理不同支付方式</span><br>        <span class="hljs-keyword">if</span> (ALIPAY.equals(paymentType)) &#123;<br>            <span class="hljs-comment">// 支付宝支付逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;使用支付宝账户 &quot;</span> + accountInfo + <span class="hljs-string">&quot; 支付了 &quot;</span> + amount + <span class="hljs-string">&quot; 元&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;支付宝支付成功！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WECHAT_PAY.equals(paymentType)) &#123;<br>            <span class="hljs-comment">// 微信支付逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;使用微信账号 &quot;</span> + accountInfo + <span class="hljs-string">&quot; 支付了 &quot;</span> + amount + <span class="hljs-string">&quot; 元&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;微信支付成功！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 未知支付方式</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;不支持的支付方式：&quot;</span> + paymentType);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果支付方式越来越多，Service中的pay方法就会非常冗长，不好维护并且耦合度太高</p><p>我们可以采用策略模式进行重构</p><p>策略模式本质上是使用了面向对象中接口的特性</p><p>对于上述应用场景，我们可以将【支付】这一个主题抽象一种策略，一个策略具体对应到代码就是一个接口</p><h2 id="通用的抽象策略-1"><a href="#通用的抽象策略-1" class="headerlink" title="通用的抽象策略"></a>通用的抽象策略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaymentStrategy</span> &#123;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 不同厂商的核心实现逻辑不同，但是出入参都是相同（或是近似）的</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> amount 支付金额</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;<br><br>   String <span class="hljs-title function_">getPaymentName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="策略实现类-1"><a href="#策略实现类-1" class="headerlink" title="策略实现类"></a>策略实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentStrategy</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Successfully pay &quot;</span> + amount + <span class="hljs-string">&quot; with &quot;</span> + getPaymentName());<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPaymentName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Wechat Pay&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentStrategy</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Alipay login ...&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;Successfully pay &quot;</span> + amount + <span class="hljs-string">&quot; with &quot;</span> + getPaymentName());<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPaymentName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Alipay&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="策略上下文-1"><a href="#策略上下文-1" class="headerlink" title="策略上下文"></a>策略上下文</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentContext</span> &#123;<br>   <span class="hljs-keyword">public</span> PaymentStrategy <span class="hljs-title function_">getStrategyByPayType</span><span class="hljs-params">(String payType)</span> &#123;<br>      <span class="hljs-keyword">switch</span> (payType) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;WECHAT&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatStrategy</span>();<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ALIPAY&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlipayStrategy</span>();<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;不支持的支付类型:&quot;</span> + payType);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="业务注入-1"><a href="#业务注入-1" class="headerlink" title="业务注入"></a>业务注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentService</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PaymentContext paymentContext;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">PaymentService</span><span class="hljs-params">(PaymentContext paymentContext)</span> &#123;<br>      <span class="hljs-built_in">this</span>.paymentContext = paymentContext;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String payType, <span class="hljs-type">double</span> amount)</span> &#123;<br>      <span class="hljs-type">PaymentStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.paymentContext.getStrategyByPayType(payType);<br>      strategy.pay(amount);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模拟调用Service的客户端"><a href="#模拟调用Service的客户端" class="headerlink" title="模拟调用Service的客户端"></a>模拟调用Service的客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyTest</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>      <span class="hljs-type">PaymentContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaymentContext</span>();<br>      <span class="hljs-type">PaymentService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaymentService</span>(context);<br><br>      service.doPay(<span class="hljs-string">&quot;WECHAT&quot;</span>, <span class="hljs-number">2.3</span>);<br><br>      System.out.println(<span class="hljs-string">&quot;-----&quot;</span>);<br><br>      service.doPay(<span class="hljs-string">&quot;ALIPAY&quot;</span>, <span class="hljs-number">2.3</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="和工厂方法模式的区别"><a href="#和工厂方法模式的区别" class="headerlink" title="和工厂方法模式的区别"></a>和工厂方法模式的区别</h2><p>策略模式和工厂方法设计模式的核心区别在于应用的场景（也就是设计的目的）完全不同</p><ul><li>策略模式关注的是：将算法&#x2F;业务逻辑进行封装抽象</li><li>工厂方法模式关注的是：将业务对象的创建过程进行封装，使用方只关注业务使用，工厂只关注业务对象的创建</li></ul><p>当核心需求是<code>逻辑选择</code>而非<code>对象创建</code>，且 <strong>对象创建相关的业务逻辑足够简单</strong>时，无需额外引入工厂方法模式，直接用策略模式即可满足需求</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式|工厂方法模式</title>
    <link href="/2025/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>工厂方法本质是为了解决 **“对象创建” 与 “业务使用” 的强耦合问题 **，并通过 “抽象化” 让系统更灵活、更易扩展</p><p>工厂方法模式的核心思路，可以总结为 <strong>“定义一个创建对象的抽象接口（工厂接口），让具体的对象创建工作由其子类（具体工厂）完成，业务层只依赖抽象工厂和抽象产品，不依赖具体实现”</strong>。</p><p>我们可以用一个 “分工比喻” 理解：</p><ul><li>不使用工厂方法的模式：“厨师（业务层）既要买菜（创建对象），又要做菜（业务逻辑）”；</li><li>工厂方法模式：“厨师（业务层）只负责做菜，买菜的工作交给专门的‘采购工厂’（具体工厂），厨师只需要告诉工厂‘要什么菜’（抽象产品），不用管‘菜从哪来’（具体实现）”。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="原始代码实现"><a href="#原始代码实现" class="headerlink" title="原始代码实现"></a>原始代码实现</h2><p>在没有使用工厂方法时，我们通常会直接用 <code>new</code> 关键字创建对象，比如一个电商系统中创建 “支付方式” 的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 业务代码中直接new具体支付对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-comment">// 处理订单支付</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String payType, <span class="hljs-type">double</span> amount)</span> &#123;<br>        Payment payment;<br>        <span class="hljs-comment">// 直接根据类型new具体实现类</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;WECHAT&quot;</span>.equals(payType)) &#123;<br>            payment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatPayment</span>(); <span class="hljs-comment">// 耦合WechatPayment</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ALIPAY&quot;</span>.equals(payType)) &#123;<br>            payment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlipayPayment</span>();  <span class="hljs-comment">// 耦合AlipayPayment</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;不支持的支付方式&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 使用支付对象完成业务</span><br>        payment.processPayment(amount);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 支付接口与具体实现</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPayment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;微信支付：&quot;</span> + amount + <span class="hljs-string">&quot;元&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayPayment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;支付宝支付：&quot;</span> + amount + <span class="hljs-string">&quot;元&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">OrderService</span> <span class="hljs-variable">orderService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderService</span>();<br>      orderService.pay(<span class="hljs-string">&quot;WECHAT&quot;</span>, <span class="hljs-number">3.3</span>);<br>      System.out.println(<span class="hljs-string">&quot;Switching payment ...&quot;</span>);<br>      orderService.pay(<span class="hljs-string">&quot;ALIPAY&quot;</span>, <span class="hljs-number">3.3</span>);<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码其实也不会很屎，甚至还知道要抽取通用的逻辑<code>processPayment</code>来进行处理</p><p>但是还是将实际支付逻辑对象的创建，与对象支付逻辑的使用 耦合在了一起</p><p>我们可以使用工厂方法设计模式来解决这一问题</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="“产品抽象化”"><a href="#“产品抽象化”" class="headerlink" title="“产品抽象化”"></a>“产品抽象化”</h3><p>定义统一的抽象产品接口(这里的产品、也就是被创建对象的类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>; <span class="hljs-comment">// 通用支付方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayPayment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Paid &quot;</span> + amt + <span class="hljs-string">&quot;$ with alipay&quot;</span>);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPayment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Payment</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Paid &quot;</span> + amt + <span class="hljs-string">&quot;$ with wechat&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="“工厂抽象化”"><a href="#“工厂抽象化”" class="headerlink" title="“工厂抽象化”"></a>“工厂抽象化”</h3><p>定义创建对象的抽象工厂接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaymentFactory</span> &#123;<br>    Payment <span class="hljs-title function_">createPayment</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象的“创建产品”方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayPaymentFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentFactory</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Payment <span class="hljs-title function_">createPayment</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlipayPayment</span>();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPaymentFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentFactory</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Payment <span class="hljs-title function_">createPayment</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatPayment</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="业务层依赖抽象，脱离具体实现"><a href="#业务层依赖抽象，脱离具体实现" class="headerlink" title="业务层依赖抽象，脱离具体实现"></a>业务层依赖抽象，脱离具体实现</h3><p>将创建于使用解耦，业务层只负责使用，创建交由工厂的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceRefactored</span> &#123;<br><br>   <span class="hljs-keyword">private</span> PaymentFactory paymentFactory;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderServiceRefactored</span><span class="hljs-params">(PaymentFactory paymentFactory)</span> &#123;<br>      <span class="hljs-built_in">this</span>.paymentFactory = paymentFactory;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPaymentFactory</span><span class="hljs-params">(PaymentFactory paymentFactory)</span> &#123;<br>      <span class="hljs-built_in">this</span>.paymentFactory = paymentFactory;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payOrder</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span> &#123;<br>      <span class="hljs-type">Payment</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.paymentFactory.createPayment();<br>      payment.processPayment(amt);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模拟客户端测试"><a href="#模拟客户端测试" class="headerlink" title="模拟客户端测试"></a>模拟客户端测试</h3><p>由于原先的代码中有根据 payType 枚举参数进行判断的逻辑，而这一段逻辑主要是用来决定对象的创建的</p><p>而对象的创建本质上和 OrderService 无关，是 Factory 需要做的事情，因此我们可以将其从 OrderService 中抽离出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentFactorySelector</span> &#123;<br>    <span class="hljs-comment">// 根据支付类型字符串获取对应的工厂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PaymentFactory <span class="hljs-title function_">getFactory</span><span class="hljs-params">(String payType)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;WECHAT&quot;</span>.equals(payType)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatPaymentFactory</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ALIPAY&quot;</span>.equals(payType)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlipayPaymentFactory</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;不支持的支付方式: &quot;</span> + payType);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryMethodClientRefactored</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">PaymentFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> PaymentFactorySelector.getFactory(<span class="hljs-string">&quot;WECHAT&quot;</span>);<br>      <span class="hljs-type">OrderServiceRefactored</span> <span class="hljs-variable">orderService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderServiceRefactored</span>(factory);<br>      orderService.payOrder(<span class="hljs-number">3.3</span>);<br><br>      System.out.println(<span class="hljs-string">&quot;Switching payment ...&quot;</span>);<br><br>      <span class="hljs-type">PaymentFactory</span> <span class="hljs-variable">alipayFactory</span> <span class="hljs-operator">=</span> PaymentFactorySelector.getFactory(<span class="hljs-string">&quot;ALIPAY&quot;</span>);<br>      <span class="hljs-comment">//切换payment</span><br>      orderService.setPaymentFactory(alipayFactory);<br>      orderService.payOrder(<span class="hljs-number">3.3</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工厂方法模式的核心思想，本质是对<strong>依赖倒置原则</strong>（依赖抽象，不依赖具体）和<strong>单一职责原则</strong>（一个类只做一件事）的落地，是将业务逻辑类中关联业务逻辑处理对象的创建 与 使用进行解耦</p><p>业务类只专注于处理具体业务逻辑，不再进行相关对象的创建</p><p>对象的创建统一在工厂接口的实现类中各自决定</p><p>简单来说，工厂方法设计模式就是 <strong>将对象的创建权交给专门的‘抽象工厂’，业务层只关心‘要什么产品’（通过抽象工厂拿抽象产品），不关心‘产品怎么造’（具体工厂实现），从而实现‘创建’与‘使用’的解耦，让系统易扩展、易维护</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL|索引</title>
    <link href="/2025/09/01/MySQL-%E7%B4%A2%E5%BC%95/"/>
    <url>/2025/09/01/MySQL-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="如何理解索引"><a href="#如何理解索引" class="headerlink" title="如何理解索引"></a>如何理解索引</h1><h2 id="索引的目的"><a href="#索引的目的" class="headerlink" title="索引的目的"></a>索引的目的</h2><p>我们可以将索引类比为字典、目录</p><p>在海量数据的查询时，我们可以<strong>借助原先生成并维护的索引，将每一次不同的复杂查询都以一种相同的查询顺序（模式）来进行</strong></p><p>在使用索引时，本质上是通过不断地缩小想要获得的数据的范围来筛选出最终的结果，<strong>将随机的复杂查询目的数据，变成顺序的查询流程</strong></p><h2 id="磁盘-IO-与预读原理"><a href="#磁盘-IO-与预读原理" class="headerlink" title="磁盘 IO 与预读原理"></a>磁盘 IO 与预读原理</h2><p>在开始讨论索引设计之前，我们需要对计算机（操作系统）针对磁盘 IO 操作读取数据的优化有所了解</p><p>对于磁盘 IO 操作，实际上相比于直接访存获取数据而言是很慢的。大概一次 IO 的耗时，是访存的 10w 倍左右</p><p>因此计算机的操作系统会在一次 IO 操作读取数据时，不光光是读取指定地址的磁盘数据，而是读取这一地址附近的所有数据。（因为一般来说当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到）</p><p>这一地址附近的所有数据我们称之为<code>页</code>(page)，具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO</p><h1 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/7af22798.jpg" alt="b+树"></p><p>在B+树中，叶子节点和非叶子节点有着明显的存储行为区别</p><ul><li>非叶子节点不会存储真实数据，只会存储区间的左右端点数据（指引搜索方向的数据项），以及指针</li><li>只有叶子节点会存储实际的数据</li></ul><p>例如上图中，磁盘上并未存储17和35这两个数据，实际存储的数据只有最下面一排叶子节点的数据，例如3、5、9等</p><h2 id="索引的查找过程"><a href="#索引的查找过程" class="headerlink" title="索引的查找过程"></a>索引的查找过程</h2><p>例如查找29号数据，那么首先会在第一次IO，将磁盘块1加载到内存</p><p>然后发现29介于17与35之间，于是通过P2指针，得到磁盘块3的地址，将磁盘块3加载到内存，这是第二次IO</p><p>之后基于磁盘块3的数据（内存处理），发现29在26和30的中间，于是通过磁盘块3的P2指针，得到磁盘块8的地址，将磁盘块8加载到内存，这是第三次IO</p><p>之后基于磁盘块8的数据（内存处理），得到了29这条数据，查找结束，一共进行了3次磁盘IO操作</p><hr><p>3层的B+树在实际的应用场景离可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的</p><p>如果没有索引，扫描所有数据项，每一个数据项都要发生一次磁盘IO，那么百万级别的数据中查找总共需要百万次的IO</p><h1 id="覆盖索引和回表"><a href="#覆盖索引和回表" class="headerlink" title="覆盖索引和回表"></a>覆盖索引和回表</h1><h2 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h2><p>在讨论覆盖索引和回表之前，我们需要先了解聚簇索引和二级索引。</p><p>假设我们有这么一张表，DDL内容如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> product (<br>  id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY</span> KEY,     <span class="hljs-comment">-- 主键</span><br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>  category_id <span class="hljs-type">INT</span>,<br>  description TEXT,<br>  stock_count <span class="hljs-type">INT</span>,<br>  <span class="hljs-comment">-- ... 其他字段</span><br>  INDEX idx_category (category_id) <span class="hljs-comment">-- 我们在 category_id 上创建了一个索引</span><br>);<br></code></pre></td></tr></table></figure><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>当一张表有主键时，聚簇索引又叫做主键索引。</p><p>聚簇索引是按照每张表的<strong>主键</strong>构造一颗B+树，对MySQL而言，InnoDB会基于主键来构建这颗树；这棵树叶子节点中存放的是表每一行(包含全量字段)的数据记录。</p><p>类似<strong>按拼音排序的字典</strong>，拼音（主键）和内容（整行数据）是存放在一起的。</p><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>二级索引又叫做非聚簇索引&#x2F;辅助索引。</p><p>二级索引一般是我们手动设计并创建的索引，上面的例子中就是<code>idx_category</code>。二级索引所对应的B+树叶子节点存储的数据是 <strong>索引字段+主键字段</strong>，并不会像聚簇索引那样存储一行完整的数据。</p><p>类似字典的<strong>“偏旁部首检字表”</strong>。它只告诉你这个“偏旁”（<code>category_id</code>）对应的字的拼音（<code>id</code>）在第几页，但不会告诉你字的完整解释（整行数据）。</p><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, description <span class="hljs-keyword">FROM</span> product <span class="hljs-keyword">WHERE</span> category_id <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>此时索引命中流程如下：</p><ol><li><p>查询条件是category_id，刚好是辅助索引。所以 InnoDB 根据 category_id 的辅助索引树，找到 category_id &#x3D; 123 的所有记录，假设有3行，也就是在辅助索引树上有 3 个符合条件的叶子节点。</p></li><li><p>这三个叶子节点的数据中，并不包含实际的行记录，但 category_id 都是 123，id 分别是 10, 20, 30</p></li><li><p>但也仅此而已了，我们最终查询的结果需要 name 和 description 数据，但是这三个辅助索引树的叶子节点里只有 id 和 category_id 的值。</p></li><li><p>于是 InnoDB 只能根据拿到的三个 id 值，重新回去查以主键 id 构建的聚簇索引树</p></li><li><p>“<code>id = 10</code> 的完整数据是什么？” -&gt; 找到，取出 <code>name</code> 和 <code>description</code>。</p><p>“<code>id = 20</code> 的完整数据是什么？” -&gt; 找到，取出 <code>name</code> 和 <code>description</code>。</p><p>“<code>id = 30</code> 的完整数据是什么？” -&gt; 找到，取出 <code>name</code> 和 <code>description</code>。</p></li></ol><p>上述<strong>“拿着二级索引查到的主键值，再返回聚簇索引查整行数据”</strong>的过程，就叫做<strong>回表</strong>。</p><p>分析上述流程，我们会发现导致回表的原因在于: select 的字段并未包含在辅助索引中。因此，当使用<strong>二级索引</strong>查询，但需要的列<strong>不在</strong>这个二级索引中时，就会发生“回表”。</p><p>回表是一个随机性IO，这一次二级索引拿到的符合条件的记录有3条，下一次可能是1w条，数据库就需要执行 1 次索引树查询 + 1w 次回表（随机 I&#x2F;O），性能会非常差。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>知道回表是如何触发的，那么覆盖索引就是指: 索引列完美覆盖查询列的场景。</p><p>我们修改索引结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> product (<br>  id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY</span> KEY,     <span class="hljs-comment">-- 主键</span><br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>  category_id <span class="hljs-type">INT</span>,<br>  description TEXT,<br>  stock_count <span class="hljs-type">INT</span>,<br>  <span class="hljs-comment">-- ... 其他字段</span><br>  INDEX idx_multi (category_id, name) <span class="hljs-comment">-- 索引扩展</span><br>);<br></code></pre></td></tr></table></figure><p>查询语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id, name <span class="hljs-keyword">FROM</span> product <span class="hljs-keyword">WHERE</span> category_id <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>这一次，在根据 category_id &#x3D; 123 去辅助索引树查找时，还是定位到那三个叶子节点。</p><p>但这次叶子节点的数据扩展了，包含 category_id, name, id 数据。</p><p>InnoDB 发现查询所需要的 id 和 name 字段在辅助索引树的叶子节点里都有，不再需要进行回表操作，这就是覆盖索引。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="禁止使用SELECT"><a href="#禁止使用SELECT" class="headerlink" title="禁止使用SELECT *"></a>禁止使用SELECT *</h3><p>通过上述讨论我们可以得出一个最佳实践：在对性能有严格要求的场景下，禁止使用 <code>SELECT *</code> 操作。</p><p>因为索引的设计必不可能包含所有列，而<code>SELECT *</code>会查询所有列记录，必定无法进行覆盖索引，必定回表，影响性能。</p><h1 id="最左匹配原则与索引覆盖"><a href="#最左匹配原则与索引覆盖" class="headerlink" title="最左匹配原则与索引覆盖"></a>最左匹配原则与索引覆盖</h1><p>一开始学习的时候很容易把这两个概念混在一起。实际上这两个概念是独立但是高度相关的。</p><p>概括总结就是：</p><blockquote><p>最左匹配原则解决的是<strong>如何高效定位数据</strong>，可以理解为受到<code>WHERE</code>和<code>ORDER BY</code>的影响。</p><p>覆盖索引解决的是<strong>定位到数据后是否能直接满足查询需求，是否还需要回表</strong>。受到<code>SELECT</code>内容的影响。</p><p>他们的共同点是都和索引有关，因此在设计索引时需要综合考虑，同时兼顾最左匹配原则以及覆盖索引，避免回表查询。</p></blockquote><h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><p>主要的目的是为了高效筛选，定位符合查询条件的数据，还在查询条件过滤这一步。</p><p>这是由 B+ 树索引的<strong>数据结构</strong>决定的。</p><p>当创建一个联合索引 <code>INDEX idx_abc (a, b, c)</code> 时，可以将其想象成一个“多级排序”的电话簿：</p><ol><li>首先，所有条目<strong>严格按照 <code>a</code> 排序</strong>。</li><li>在 <code>a</code> 相同的情况下，<strong>再按照 <code>b</code> 排序</strong>。</li><li>在 <code>a</code> 和 <code>b</code> 都相同的情况下，<strong>最后按照 <code>c</code> 排序</strong>。</li></ol><p><strong>最左匹配原则</strong>就是：你必须从“最左边”的列（<code>a</code>）开始使用，才能利用上这个“排序”结构来快速缩小查询范围。</p><ul><li><strong><code>WHERE a = ?</code></strong> -&gt; 能用索引（高效定位）。</li><li><strong><code>WHERE a = ? AND b = ?</code></strong> -&gt; 能用索引（高效定位）。</li><li><strong><code>WHERE a = ? AND b = ? AND c = ?</code></strong> -&gt; 能用索引（高效定位）。</li></ul><p><strong>为什么 <code>WHERE b = ?</code> 不行？</strong></p><ul><li>因为 <code>b</code> 只有在 <code>a</code> 确定的情况下才是有序的。</li><li>如果直接查 <code>b</code>，<code>b</code> 在整个索引中是“乱序”的（B+树的第一层是按 <code>a</code> 排序的），数据库无法快速定位，只能全索引扫描（Index Full Scan）或全表扫描（Table Scan）。</li></ul><p>所以从查询流程的先后顺序来看，最左匹配原则是首要目的，是<strong>让你能用上索引</strong>的 B+ 树快速搜索能力，而不是进行全表扫描。如果连最左匹配都不满足，那么只好全扫，性能最差，更谈不上覆盖索引了。</p><h2 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>覆盖索引的目的是：<strong>仅仅通过辅助索引，查询条件过滤完，定位到符合条件的辅助索引树叶子节点后，能不能直接满足查询需求，不用再回表</strong>。</p><p>所以从查询流程的先后顺序来看，覆盖索引场景在最左匹配原则生效的后面。</p><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>在设计索引时，最左匹配是<strong>必须要遵守的原则</strong>。这直接决定了是否能让 <code>WHERE</code> 子句命中索引，是优化的<strong>前提</strong>。</p><p>覆盖索引是在最左匹配的基础上，尽可能让查询只通过一次二级索引（辅助索引）树就获取到查询所需的所有列数据，省略回表的IO消耗。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/TheMagicalRainbowSea/p/18760275">https://www.cnblogs.com/TheMagicalRainbowSea/p/18760275</a></p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">https://tech.meituan.com/2014/06/30/mysql-index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>SQL BOY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>202509|技术日志</title>
    <link href="/2025/09/01/202509-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/"/>
    <url>/2025/09/01/202509-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="0901"><a href="#0901" class="headerlink" title="0901"></a>0901</h1><h2 id="SQL索引失效的情况"><a href="#SQL索引失效的情况" class="headerlink" title="SQL索引失效的情况"></a>SQL索引失效的情况</h2><p>面试的时候经常会考察SQL的索引，而SQL索引失效的情况就是在业务场景中使用SQL索引时经常会遇到的问题</p><p>常见的索引失效，也就是我们通常说的查询未命中索引，这样的情况有：</p><ol><li>复合索引是遵循<strong>最左匹配原则</strong>，如果索引列顺序错了，会导致索引无法命中</li><li>MySQL 分析本次查询最终查询出来的数据有900条，整张表有1000条数据，查询索引的成本比全表扫描来得高，因此会直接扫描全表不会命中索引</li></ol><h3 id="分析查询是否命中索引"><a href="#分析查询是否命中索引" class="headerlink" title="分析查询是否命中索引"></a>分析查询是否命中索引</h3><p>可以使用 MySQL 自带的 EXPLAIN 关键字</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>已整理成单独文章笔记</p><h1 id="0902"><a href="#0902" class="headerlink" title="0902"></a>0902</h1><h2 id="CPU占用过高排查"><a href="#CPU占用过高排查" class="headerlink" title="CPU占用过高排查"></a>CPU占用过高排查</h2><p>top显示进程CPU利用率，找到最高的那个进程，定位PID</p><p>之后通过 <code>jstack</code> 命令导出这个进程的堆栈信息以便定位是哪一段代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#将指定PID的堆栈信息导出到当前目录下的 stack.log 文件中</span><br>jstack &lt;PID&gt; &gt; stack.log<br></code></pre></td></tr></table></figure><p>同时我们查看这个进程中哪些线程占用过高，获得他们的线程ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">top -Hp &lt;PID&gt;<br></code></pre></td></tr></table></figure><p>有了线程ID，就可以去 stack.log 中查找，但是堆栈日志文件中是十六进制，因此需要先转换一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%x\n&quot;</span> &lt;线程ID&gt;<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看堆栈日志中30行这个线程相关方法</span><br>grep -A 30 <span class="hljs-string">&#x27;nid=0x&lt;十六进制线程ID&gt;&#x27;</span> stack.log<br></code></pre></td></tr></table></figure><p>这样就可以定位具体是哪里出了问题</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>笔记回顾整理</p><h1 id="0903"><a href="#0903" class="headerlink" title="0903"></a>0903</h1><h2 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail Fast"></a>Fail Fast</h2><p>我们在开发中有的时候会遇到这样的错误</p><h3 id="常见错误1-迭代中修改"><a href="#常见错误1-迭代中修改" class="headerlink" title="常见错误1: 迭代中修改"></a>常见错误1: 迭代中修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailFastDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>        <span class="hljs-comment">// 1. 获取迭代器（此时 expectedModCount = modCount = 3）</span><br>        Iterator&lt;String&gt; iterator = list.iterator();<br><br>        <span class="hljs-comment">// 2. 遍历集合</span><br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> iterator.next(); <span class="hljs-comment">// 每次 next() 都会检查 modCount</span><br>            System.out.println(<span class="hljs-string">&quot;遍历元素：&quot;</span> + element);<br><br>            <span class="hljs-comment">// 3. 非迭代器方法修改集合（直接调用 list.remove()）</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;B&quot;</span>.equals(element)) &#123;<br>                list.remove(element); <span class="hljs-comment">// modCount 自增为 4</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常见错误2-多线程修改"><a href="#常见错误2-多线程修改" class="headerlink" title="常见错误2: 多线程修改"></a>常见错误2: 多线程修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailFastMultiThreadDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 线程1：遍历集合</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (String element : list) &#123; <span class="hljs-comment">// 增强 for 循环底层依赖 Iterator</span><br>                System.out.println(<span class="hljs-string">&quot;线程1遍历：&quot;</span> + element);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠，给线程2修改时间</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 线程2：修改集合</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>); <span class="hljs-comment">// 等待线程1开始遍历</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            list.add(<span class="hljs-string">&quot;D&quot;</span>); <span class="hljs-comment">// 修改集合，modCount 自增</span><br>            System.out.println(<span class="hljs-string">&quot;线程2添加元素：D&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h3><p>Fail Fast 是软件编程的一种设计思想</p><p>是指当检测到错误发生的时候，立刻执行拒绝策略</p><p>我们平时写接口的时候会优先处理参数，当发现参数非法的时候立刻返回错误响应，其实也是这种思想的落地</p><p>在 JDK的 ArrayList 中就有 Fail Fast 思想的落地实现</p><p><code>ArrayList</code> 继承自 <code>AbstractList</code>，在 <code>AbstractList</code> 中定义了 <code>modCount</code> 变量，用于记录集合被修改的次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractList.java（JDK8）</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">modCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>每当集合发生<strong>结构性修改</strong>（添加、删除元素，或调整容量导致底层数组替换）时，<code>modCount</code> 会自增。</p><p>例如 <code>ArrayList</code> 的 <code>add()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ArrayList.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 确保容量，可能触发数组扩容（修改操作）</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;  <span class="hljs-comment">// 结构性修改，modCount 自增</span><br>    <span class="hljs-comment">// ... 后续扩容逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而在 ArrayList 的内部迭代器中，初始化的时候会拷贝一份当前的 modCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ArrayList.java 中的内部类 Itr（实现 Iterator 接口）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// 下一个要返回的元素索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 最后一个返回的元素索引，-1 表示没有</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;  <span class="hljs-comment">// 初始化时记录当前 modCount</span><br><br>    <span class="hljs-comment">// ... 其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在每一次遍历的时候会优先检测是否在迭代中非法调用 remove() 导致 modCount 被修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Itr 的核心检测方法</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)  <span class="hljs-comment">// 核心判断：实际修改次数 vs 预期修改次数</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();  <span class="hljs-comment">// 不一致则抛出异常</span><br>&#125;<br><br><span class="hljs-comment">// 迭代器的 next() 方法</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    checkForComodification();  <span class="hljs-comment">// 先检测</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>    <span class="hljs-keyword">if</span> (i &gt;= size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>    <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    cursor = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>&#125;<br><br><span class="hljs-comment">// 迭代器的 remove() 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>    checkForComodification();  <span class="hljs-comment">// 先检测</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);  <span class="hljs-comment">// 调用集合的 remove()</span><br>        cursor = lastRet;<br>        lastRet = -<span class="hljs-number">1</span>;<br>        expectedModCount = modCount;  <span class="hljs-comment">// 同步 expectedModCount（关键！）</span><br>    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若通过迭代器自身的 <code>remove()</code> 方法修改集合，会同步更新 <code>expectedModCount = modCount</code>，避免抛出异常（这是唯一允许的修改方式）</p><p>而当通过集合自身的方法（如 <code>add()</code>、<code>remove()</code>）修改集合时，只会更新 <code>modCount</code>，但不会同步更新迭代器的 <code>expectedModCount</code>，导致二者不一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ArrayList 自身的 remove() 方法（非迭代器）</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    rangeCheck(index);<br>    modCount++;  <span class="hljs-comment">// 仅更新 modCount，不影响迭代器的 expectedModCount</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    <span class="hljs-comment">// ... 后续删除逻辑</span><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，若在遍历期间调用 <code>list.remove()</code>（而非 <code>iterator.remove()</code>），<code>modCount</code> 会增加，而 <code>expectedModCount</code> 不变，下次调用 <code>next()</code> 时就会抛出异常</p><h1 id="0904"><a href="#0904" class="headerlink" title="0904"></a>0904</h1><h2 id="Fail-Safe"><a href="#Fail-Safe" class="headerlink" title="Fail Safe"></a>Fail Safe</h2><p><strong>Fail-Safe</strong> 机制是一种以尽可能保证系统正常运行为目标的设计方式，即使在遇到错误或异常情况下，系统仍能继续工作，避免崩溃或数据损坏</p><p>它的核心原则是：<strong>宁可以退为进，也要保证系统的健壮性和稳定性</strong></p><p>在 JDK 中，Fail Safe 的实现可以参考 <code>CopyOnWriteArrayList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock(); <span class="hljs-comment">// 加锁，保证多线程写操作的原子性</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray(); <span class="hljs-comment">// 获取原数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">// 复制原数组到新数组（新数组长度+1）</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e; <span class="hljs-comment">// 添加新元素到新数组</span><br>        setArray(newElements); <span class="hljs-comment">// 用新数组替换原数组</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock(); <span class="hljs-comment">// 释放锁</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0908"><a href="#0908" class="headerlink" title="0908"></a>0908</h1><h2 id="HashMap-和-HashTable"><a href="#HashMap-和-HashTable" class="headerlink" title="HashMap 和 HashTable"></a>HashMap 和 HashTable</h2><table><thead><tr><th></th><th>HashMap</th><th>HashTable</th></tr></thead><tbody><tr><td>线程安全</td><td>不安全 效率高</td><td>安全（底层synchronized)效率低</td></tr><tr><td>容量</td><td>初始16，始终保证2的整次幂</td><td>初始11，扩容2n+1</td></tr><tr><td>null key</td><td>支持，单只能有一个</td><td>一个都不允许存在</td></tr><tr><td>底层数据结构</td><td>数组+链表，若相同数组位置中的链表长度大于8（并且数组长度大于64，转为红黑树，否则优先进行数组的扩容操作）</td><td>数组+链表（无转换优化机制）</td></tr></tbody></table><h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h2><p>当我们在 HashSet 中调用 add,实际上也只是底层调用了 HashMap 的<code>put</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet</span>     <br>     <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;<br>     <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 Map 的 put 方法，底层调用的 putVal 方法返回值的定义是：元素不存在返回 null，元素已存在返回该key原先的元素</p><p>因此我们程序多次调用同一个 set 对相同的 key 进行 add 操作，都是对底层的 map 进行了 put 覆盖操作，只是 HashSet 封装了一层，通过 HashMap 返回的是否存在元素，来间接返回布尔值</p><h1 id="0909"><a href="#0909" class="headerlink" title="0909"></a>0909</h1><h2 id="为什么n小于64的时候优先扩容"><a href="#为什么n小于64的时候优先扩容" class="headerlink" title="为什么n小于64的时候优先扩容"></a>为什么n小于64的时候优先扩容</h2><p>因为对数组扩容是在数据量不大的时候更为高效的方式，数组扩容可以显著解决哈希冲突的问题</p><p>如果数组长度不大，当链表长度超过8的时候直接就转红黑树，由于红黑树本身维持自平衡需要自旋，本身也有性能开销，过早引入反而会提升复杂度影响 HashMap 的性能</p><h2 id="自定义对象作为HashMap-key时的最佳实践"><a href="#自定义对象作为HashMap-key时的最佳实践" class="headerlink" title="自定义对象作为HashMap key时的最佳实践"></a>自定义对象作为HashMap key时的最佳实践</h2><h3 id="重写equals和hashCode"><a href="#重写equals和hashCode" class="headerlink" title="重写equals和hashCode"></a>重写equals和hashCode</h3><p>当采用自定义对象作为 HashMap 的 key 时，需要保证该对象重写了 <code>hashCode()</code> 以及 <code>equals()</code></p><p>这是由于 HashMap 在底层维护数据时的逻辑结构决定的</p><p>HashMap 底层首先会根据 key 对象的 <code>hashCode()</code> 计算出哈希值，这个值决定了数组中桶(bucket)的位置。当多个 <code>key</code> 的哈希值相同时（哈希冲突），<code>HashMap</code> 会通过 <code>equals()</code> 逐一比较桶中的对象，找到真正相等的 <code>key</code>。若 <code>equals</code> 实现不当，会导致无法识别相同的 <code>key</code></p><h3 id="保证参与-hash-值计算的字段不可变性"><a href="#保证参与-hash-值计算的字段不可变性" class="headerlink" title="保证参与 hash 值计算的字段不可变性"></a>保证参与 hash 值计算的字段不可变性</h3><p>由于该对象作为 HashMap 的 key，参与该对象 hashCode 方法的字段需要严格保证不可变性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MutableKey</span> &#123;<br>    <span class="hljs-keyword">private</span> String value; <span class="hljs-comment">// 可修改的字段</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(String value)</span> &#123; <span class="hljs-comment">// 提供修改方法，风险！</span><br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> Objects.hash(value); &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123; <span class="hljs-comment">/* 依赖value判断 */</span> &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试：修改key后无法找到value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    HashMap&lt;MutableKey, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">MutableKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutableKey</span>();<br>    key.setValue(<span class="hljs-string">&quot;old&quot;</span>);<br>    map.put(key, <span class="hljs-string">&quot;value&quot;</span>);<br><br>    key.setValue(<span class="hljs-string">&quot;new&quot;</span>); <span class="hljs-comment">// 修改key的字段，导致hashCode变化</span><br>    System.out.println(map.get(key)); <span class="hljs-comment">// 输出：null（找不到值）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>正确的做法应该是在代码层面严格保证参与 hashCode 方法的字段在初始化后不可变</p><p>具体的实现思路有：</p><ul><li>使用 final 修饰：强推，语言自带关键字约束0910</li><li>不提供字段的 <code>setter</code> 方法</li><li>如果外部真的需要修改对象某个参与 hash 值计算字段的状态，返回新的实例（参考 String 类的实现，replace 方法看似修改实际上是创建了新的字符串，为的就是保证不可变性，因为 String 常常用作 HashMap 的 key）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImmutableKey</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String value;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ImmutableKey</span><span class="hljs-params">(String value)</span> &#123;<br>      <span class="hljs-built_in">this</span>.value = value;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-type">ImmutableKey</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (ImmutableKey) o;<br>      <span class="hljs-keyword">return</span> value.equals(that.value);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> Objects.hashCode(value);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多线程交替打印-0-100"><a href="#多线程交替打印-0-100" class="headerlink" title="多线程交替打印 0-100"></a>多线程交替打印 0-100</h2><p>整理成博客</p><h1 id="0910"><a href="#0910" class="headerlink" title="0910"></a>0910</h1><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><p>整理成博客</p><h1 id="0911"><a href="#0911" class="headerlink" title="0911"></a>0911</h1><p>OOM排查</p><h1 id="0912"><a href="#0912" class="headerlink" title="0912"></a>0912</h1><h2 id="JDBC-动态参数最佳实践"><a href="#JDBC-动态参数最佳实践" class="headerlink" title="JDBC 动态参数最佳实践"></a>JDBC 动态参数最佳实践</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>今天遇到一个问题，在调用JDBC传入代码中SQL参数的时候，参数SQL使用了类似如下的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T_TABLE <span class="hljs-keyword">WHERE</span> c_column <span class="hljs-keyword">IN</span> (?)<br></code></pre></td></tr></table></figure><p>代码中采用 PreparedStatement 来执行 SQL 参数，此时针对占位符的参数传入的是 list 的字符串形式 <code>&#39;foo&#39;,&#39;bar&#39;</code>.</p><p>从主观理解上来说，我们希望这一段SQL可以去查询 c_column 这一个字段值为 <code>foo</code>&#x2F;<code>bar</code> 的所有记录。</p><p>但是这条 SQL 执行完成后没有任何结果，奇怪的是也没有任何的报错。</p><p>其实这是由于 PreparedStatement 的特性造成的。</p><p>我们都知道 PreparedStatement 支持防止 SQL 注入，因此引入占位符机制。上述我们的 SQL，看似参数是传入了两个元素，通过 IN 来实现 or 的查询效果。但是在 PreparedStatement 的作用下，实际上 MySQL 会将其解析为一个完整的元素，因此 IN 的括号中只算做了一个元素。相当于去表里寻找 code &#x3D; ‘foo,bar’ 的记录，那当然是没有的，自然也没有任何结果，也不会有任何的报错。</p><p>网络上常见的一种实现方式是采用动态拼接 <code>?</code> 占位符的方式进行实现。</p><p>但是实际上这样的实现方式并不合理。</p><p>要理解为什么不能这么做以及应该如何做，我们需要了解 PreparedStatement 和 Statement 语句的区别。</p><h3 id="PreparedStatement和Statement"><a href="#PreparedStatement和Statement" class="headerlink" title="PreparedStatement和Statement"></a>PreparedStatement和Statement</h3><p>在 JDBC 中，<code>PreparedStatement</code> 和普通 <code>Statement</code> 都是用于执行 SQL 语句的接口，但核心区别在于：</p><ol><li><strong>预编译机制</strong>：<code>PreparedStatement</code> 会对 SQL 语句进行预编译，而普通 <code>Statement</code> 每次不会。</li><li><strong>SQL 注入防护</strong>：<code>PreparedStatement</code> 通过参数绑定（<code>?</code> 占位符）避免 SQL 注入，而普通 <code>Statement</code> 直接拼接字符串有注入风险。</li><li><strong>性能</strong>：重复执行相同结构的 SQL 时，<code>PreparedStatement</code> 性能更优（预编译只需一次）。</li></ol><p>我们重点关注预编译机制。预编译语句在数据库侧是需要通过缓存进行维护的。我们在服务代码中通过 JDBC 调用创建了 PreparedStatement 对象，<strong>此时数据库会预先解析 SQL 结构、生成执行计划，之后只需传入参数即可重复执行，无需重新解析</strong>。这样的场景十分适合 “<strong>相同结构的SQL</strong>“，也就是那些参数位置和数量都是在程序运行期间确定的 SQL.</p><p>而对于上述问题中的 SQL，我们可能传入需要 IN 查询的 list，某一个请求是3个长度，也有可能是100个长度。如果采用根据数组长度动态拼接占位符的策略，在实际执行 PreparedStatement 的时候，对应的就是两个完全不一样的 SQL，但数据库侧都需要进行维护。</p><p><strong>此时预编译的效果已经失效，因为前一次根据 list 动态拼接占位符生成SQL的预编译缓存，不一定就会在下一次 list 参数的到来时进行命中。</strong>同时由于数据库侧还需要不断维护这些缓存数据，不但没有利用上预编译的性能优化，反倒增大了系统的开销。数据库连接池对 <code>PreparedStatement</code> 数量有上限，大量动态 <code>IN</code> 子句会耗尽这个上限，甚至导致内存溢出（OOM）。</p><p>不要简单地认为在代码中显式调用 <code>close()</code> 释放了 <code>PreparedStatement</code> 对象就可以销毁这些缓存。数据库仍可能大量维护预编译语句的缓存，原因与数据库的 <strong>预编译语句缓存机制</strong> 有关，而非我们作为应用层的服务中对象的生命周期。</p><p>此时，直接使用 Statement 动态根据 list 参数拼接条件更为妥当。无论 <code>IN</code> 子句参数数量如何变化，都只需生成一次 SQL 并执行，不会产生大量冗余的预编译对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于结构固定相同的SQL，在程序运行期间能够确定参数位置和数量的SQL，使用 PreparedStatement 执行，充分利用预编译机制</p><p>对于在程序运行期间可能存在动态参数拼接导致结构改变的SQL，采用 Statement 执行，避免预编译缓存爆炸导致的性能问题。</p><h1 id="0916"><a href="#0916" class="headerlink" title="0916"></a>0916</h1><h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h2><p>确保在 try 语句块结束时自动关闭资源，从而避免资源泄漏</p><p>但是要求使用的资源类实现<code>AutoClosable</code>接口，JVM底层会在<code>try</code>块代码执行完成后调用实现类重写的<code>close()</code></p><p>相比于普通的 try-catch 而言更好用：</p><ul><li>更简洁，当申请多个系统资源都需要catch的时候，传统方法会出现catch金字塔现象</li><li>能够有效解决某些资源在catch中进行关闭但是失败导致原先try中抛出的异常被覆盖的问题</li></ul><p>下面直接以代码举例</p><h3 id="写法更简洁"><a href="#写法更简洁" class="headerlink" title="写法更简洁"></a>写法更简洁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">copyTraditional</span><span class="hljs-params">(String src, String desc)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>   <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(desc);<br>      <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>      <span class="hljs-type">int</span> n;<br>      <span class="hljs-comment">//还需要考虑释放另一个资源，因此又套一层 try-catch</span><br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">while</span> ((n = inputStream.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>            outputStream.write(bytes, <span class="hljs-number">0</span> ,n);<br>         &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         outputStream.close();<br>      &#125;<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>      inputStream.close();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">copyTryWithResource</span><span class="hljs-params">(String src, String desc)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>   <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>       <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(desc)) &#123;<br>      <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>      <span class="hljs-type">int</span> n;<br>      <span class="hljs-keyword">while</span> ((n = in.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>         out.write(bytes, <span class="hljs-number">0</span> ,n);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>比较常见的就是 <code>InnoDB</code> 和 <code>MyISAM</code></p><table><thead><tr><th></th><th>InnoDB(default)</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务支持</td><td>支持</td><td>不支持</td></tr><tr><td>外键支持</td><td>支持</td><td>不支持</td></tr><tr><td>最小锁粒度</td><td>行级</td><td>表级</td></tr><tr><td>索引</td><td>聚簇索引，叶子节点存储实际数据</td><td>非聚簇索引，叶子节点存储数据地址</td></tr><tr><td>count(*)</td><td>慢，需要扫描全表</td><td>快，有一个变量自动维护某张表的所有记录数</td></tr><tr><td>自增主键最大ID存储位置</td><td>内存，重启后丢失，以表的最后一个+1为准</td><td>磁盘文件，重启后不会丢失</td></tr></tbody></table><p>上述两种引擎的特性决定了他们的最佳使用场景：</p><ul><li>MyISAM 适合读取多、更新少的场景，如数据仓库</li><li>InnoDB 适合在高并发场景下为业务系统提供高负载的事务处理以及查询功能</li></ul><h1 id="0926"><a href="#0926" class="headerlink" title="0926"></a>0926</h1><h2 id="单一职责优化"><a href="#单一职责优化" class="headerlink" title="单一职责优化"></a>单一职责优化</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>之前我们的系统有这么一个需求：需要采集一些JVM以及系统信息相关的指标用于服务监控，最早我的实现方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ServerResource <span class="hljs-title function_">generateServerResource</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">//服务监控指标对象实体，包含一些监控字段</span><br>     <span class="hljs-type">ServerResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerResource</span>();<br>     <br>     <span class="hljs-comment">//获取CPU利用率</span><br>     <br>     <span class="hljs-comment">//获取JVM堆内存使用率</span><br>     <br>     <span class="hljs-comment">//获取磁盘占用</span><br>     <br>     <span class="hljs-keyword">return</span> resource;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的实现固然简单粗暴，但是每一段获取系统资源的逻辑都很长，并且还需要根据业务需求进行单位转换等二次操作，不知不觉一个方法写了一百多行。</p><p>第一个想到的是抽取成方法，某一个指标（例如CPU利用率）可能还会依赖多个私有的工具方法，方法一多，各个指标数据采集的方法都堆在一起，逻辑上互不关联但是维护起来十分麻烦。</p><p>同时：所有逻辑都堆砌在一个方法中，职责不清晰，可读性和可维护性较差，且难以扩展（比如现在又要新增一个监控指标，这个时候需要修改核心的generateServerResource方法，新插入一段逻辑）</p><p>我们可以通过<strong>单一职责原则</strong>（拆分不同资源的收集逻辑）进行优化，使代码结构更清晰、扩展性更强。</p><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>generateServerResource 一个方法承担了太多的职责，同时包含了多种监控指标的数据生成；我们希望针对一个类（对象）只专注一种监控指标数据的处理。</p><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResourceCollector</span> &#123;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">collectResource</span><span class="hljs-params">(ServerResource serverResource)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JVMResourceCollector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResourceCollector</span> &#123;<br>     <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiskResourceCollector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResourceCollector</span>&#123;<br>     <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CPUResourceCollector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResourceCollector</span>&#123;<br> <span class="hljs-comment">//    </span><br>&#125;<br></code></pre></td></tr></table></figure><p>几种工厂模式的区别</p><p>工厂模式作为一种创建型设计模式，核心解决的是 对象的创建与使用耦合在一起 的问题</p><p>在实际开发中根据业务复杂度分为三种不同的工厂模式（从简单到复杂）：</p><ul><li>简单工厂</li><li>工厂方法</li><li>抽象工厂</li></ul><table><thead><tr><th>模式类型</th><th>核心特征</th><th>典型结构</th></tr></thead><tbody><tr><td><strong>简单工厂模式</strong></td><td>一个工厂类负责创建所有产品（无抽象工厂接口），通过参数或固定逻辑决定创建哪种产品。</td><td>1 个工厂类 + 多种产品（被创建的对象）</td></tr><tr><td><strong>工厂方法模式</strong></td><td>定义抽象工厂接口，每个具体工厂类负责创建一种具体产品（工厂与产品一一对应）。</td><td>1 个抽象工厂接口 + N 个具体工厂类 + N 个具体产品类</td></tr><tr><td><strong>抽象工厂模式</strong></td><td>定义抽象工厂接口，每个具体工厂负责创建一系列相关联的产品（产品族）。</td><td>1 个抽象工厂接口 + N 个具体工厂类 + 多组产品接口（每组包含相关联的产品）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>找工作</tag>
      
      <tag>自我提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式|观察者模式</title>
    <link href="/2025/08/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/08/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>观察者模式也是比较常用的一个模式，常常用于，当一个对象的状态发生改变时，对于所有”<strong>订阅</strong>“了这个对象的对象，需要做出对应的行为。但是这些对象往往需要在运行过程中才会被确定</p><p>这个场景我们就可以使用观察者模式</p><p>例如商品库存的例子，商品库存不够时，需要通知其他订阅了商品库存数量的服务</p><h1 id="代码最佳实践"><a href="#代码最佳实践" class="headerlink" title="代码最佳实践"></a>代码最佳实践</h1><h2 id="被观察者接口"><a href="#被观察者接口" class="headerlink" title="被观察者接口"></a>被观察者接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>   <span class="hljs-comment">// 添加观察者</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(Observer observer)</span>;<br><br>   <span class="hljs-comment">// 移除观察者</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span>;<br><br>   <span class="hljs-comment">// 通知所有观察者</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>;<br><br><br>   String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-type">int</span> <span class="hljs-title function_">getStock</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="被观察者实现类"><a href="#被观察者实现类" class="headerlink" title="被观察者实现类"></a>被观察者实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 商品类（具体被观察者）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> stock; <span class="hljs-comment">// 库存数量</span><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Product</span><span class="hljs-params">(String id, String name, <span class="hljs-type">int</span> stock)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.stock = stock;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 减少库存</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduceStock</span><span class="hljs-params">(<span class="hljs-type">int</span> quantity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (quantity &gt; <span class="hljs-number">0</span> &amp;&amp; quantity &lt;= stock) &#123;<br>            stock -= quantity;<br>            System.out.println(name + <span class="hljs-string">&quot; 减少库存 &quot;</span> + quantity + <span class="hljs-string">&quot;，当前库存：&quot;</span> + stock);<br>            <br>            <span class="hljs-comment">// 当库存低于阈值时，通知观察者</span><br>            <span class="hljs-keyword">if</span> (stock &lt;= <span class="hljs-number">5</span>) &#123;<br>                notifyObservers();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 添加库存</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addStock</span><span class="hljs-params">(<span class="hljs-type">int</span> quantity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (quantity &gt; <span class="hljs-number">0</span>) &#123;<br>            stock += quantity;<br>            System.out.println(name + <span class="hljs-string">&quot; 增加库存 &quot;</span> + quantity + <span class="hljs-string">&quot;，当前库存：&quot;</span> + stock);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// getter方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> id; &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStock</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> stock; &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.add(observer);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.remove(observer);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;=== 库存不足，开始通知相关方 ===&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>            observer.update(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="观察者接口"><a href="#观察者接口" class="headerlink" title="观察者接口"></a>观察者接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>   <span class="hljs-comment">// 接收通知的方法</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="观察者实现类"><a href="#观察者实现类" class="headerlink" title="观察者实现类"></a>观察者实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前端观察者（收到通知后显示缺货标识）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrontendObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;前端收到通知：&quot;</span> + subject.getName() + <span class="hljs-string">&quot; 库存不足&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;前端操作：已显示&#x27;库存紧张&#x27;标识&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 用户观察者（收到通知后提醒用户）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserObserver</span><span class="hljs-params">(String username)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;用户 &quot;</span> + username + <span class="hljs-string">&quot; 收到通知：您关注的 &quot;</span> + subject.getName() + <span class="hljs-string">&quot; 库存不足（当前：&quot;</span> + subject.getStock() + <span class="hljs-string">&quot;）&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;用户通知：建议尽快购买&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 仓库观察者（收到通知后补充库存）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WarehouseObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Subject subject)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;仓库收到通知：&quot;</span> + subject.getName() + <span class="hljs-string">&quot; 库存不足（当前：&quot;</span> + subject.getStock() + <span class="hljs-string">&quot;）&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;仓库操作：已安排补货，预计24小时内到货&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h1><p>观察者模式的核心设计在于，被观察者会在程序运行时，持有所有观察者的引用（商品持有所有的观察者List）</p><p>一旦触发某些状态变动后（商品库存更新）</p><p>被观察者调用观察者的指定逻辑（商品调用观察者的update方法）</p><h1 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h1><p>Spring中的事件就是基于观察者模式的扩展</p><p>主要有三个角色</p><table><thead><tr><th>观察者模式角色</th><th>Spring 组件</th><th>作用说明</th></tr></thead><tbody><tr><td>被观察者（Subject）</td><td><code>ApplicationEventPublisher</code></td><td>负责发布事件（通知观察者），Spring 容器（<code>ApplicationContext</code>）默认实现该接口</td></tr><tr><td>观察者（Observer）</td><td><code>ApplicationListener&lt;T&gt;</code></td><td>泛型接口，<code>T</code>是具体事件类型，实现<code>onApplicationEvent(T event)</code>方法接收通知<br />也可以通过在Spring bean中的某个方法上标记<code>@EventListener</code>注解来替换这个 onApplicationEvent实现</td></tr><tr><td>通知数据</td><td><code>ApplicationEvent</code></td><td>事件基类，自定义事件需继承它，用于传递通知时的业务数据</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式|单例模式</title>
    <link href="/2025/08/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/08/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="需求作用"><a href="#需求作用" class="headerlink" title="需求作用"></a>需求作用</h1><p>我们一般代码里编写的时候会使用上单例，主要就是因为有些类的对象是无状态的，在程序运行期间字段的类型几乎不会发生变更，也只需要存在一份实例引用即可。同时如果出现了两个实例，就很可能会导致程序作出异常的行为。</p><p>最经典的应用就是应用程序的配置文件映射类，配置类</p><h1 id="基于JVM类的饿汉式加载"><a href="#基于JVM类的饿汉式加载" class="headerlink" title="基于JVM类的饿汉式加载"></a>基于JVM类的饿汉式加载</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HungrySingleton</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">HungrySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HungrySingleton</span>();<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">HungrySingleton</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这种实现方式首先是一种饿汉式加载，也就是JVM在加载类的时候就完成类对象的创建，并不是用到的时候再加载</p><p>同时也是借用了 JVM 加载类的机制来做到线程安全，并不存在线程不安全的问题：因为 <strong>JVM 加载静态类只会加载一次，并且类的静态字段初始化也是原子性的操作</strong>，因此这种实现方式天然就是线程安全的</p><h1 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h1><h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazySingleton</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">LazySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazySingleton</span><span class="hljs-params">()</span> &#123;<br><br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingleton</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>上述实现为线程不安全的实现方式</p><p>也就是在多线程场景下，不同线程调用 <code>LazySingleton.getInstance()</code> 可能会创建多个实例</p><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>为了解决线程不安全的问题，我们可以在方法上加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedLazySingleton</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SynchronizedLazySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">SynchronizedLazySingleton</span><span class="hljs-params">()</span> &#123;<br><br>   &#125;<br><br>   <span class="hljs-comment">//同步方法，性能较差</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SynchronizedLazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedLazySingleton</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上述的实现方式同样也引出了一个问题：由于是在get方法级别进行同步，这就会导致所有调用 getInstance 方法的线程都会阻塞住，存在性能问题</p><p>我们可以尝试进行优化：<strong>只有当第一次初始化单例对象的时候，才进行加锁防止多线程并发问题</strong>，这就引出了我们的双重检查锁的方式</p><h2 id="Double-check-Locing"><a href="#Double-check-Locing" class="headerlink" title="Double-check Locing"></a>Double-check Locing</h2><p>双重检查锁的实现，只有在第一次初始化单例对象的时候才加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DclLazySingleton</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">DclLazySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">DclLazySingleton</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DclLazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">//仅在实例还未创建的时候加锁</span><br>         <span class="hljs-keyword">synchronized</span> (DclLazySingleton.class) &#123;<br>            <span class="hljs-comment">//这里第二次检查，是为了在锁释放的时候，后面的线程发现已经创建了那就不创建了</span><br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>               instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DclLazySingleton</span>();<br>            &#125;<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> instance;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面有两次检查(<code>instance == null</code>)，分别对应解决不同的问题：</p><ul><li>第一次检查，是为了减少不必要的加锁；因为如果没有第一次加锁，那就是上面在方法级别上进行加锁；此时多个线程get，如果实例已经创建了，还是需要阻塞等待，严重影响性能；因此使用第一次检查，只有实例没有初始化的时候才加锁限制创建</li><li>第二次检查，是为了<strong>防止多个等待锁的线程重复创建实例</strong></li></ul><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p>基于静态内部类实现</p><p>这种方法利用的机制是：JVM 在加载外部类的时候，对于静态内部类不会进行加载，只有当内部类的属性或者方法被调用的时候才会加载并进行唯一一次初始化</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInnerClassSingleton</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">StaticInnerClassSingleton</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StaticInnerClassSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>   &#125;<br><br>     <span class="hljs-comment">//静态内部类只有被用到的时候才会加载</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StaticInnerClassSingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticInnerClassSingleton</span>();<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>推荐使用静态内部类的方式</p><p>基于JVM初始化类时对静态变量的原子初始化操作，无锁，线程安全，用到的时候才加载，并发性高</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring|@Component与@Bean</title>
    <link href="/2025/08/26/Spring-Component%E4%B8%8E-Bean/"/>
    <url>/2025/08/26/Spring-Component%E4%B8%8E-Bean/</url>
    
    <content type="html"><![CDATA[<p>在Spring的应用中都很常见到这两个注解</p><p>这两个注解的核心作用都是将对象（Bean）纳入 Spring 容器管理</p><p>但它们的<strong>设计初衷、使用场景、底层逻辑</strong>有显著区别</p><p>理解二者的差异，是掌握 Spring 依赖注入（DI）和控制反转（IoC）的关键</p><h1 id="作用对象与作用方式"><a href="#作用对象与作用方式" class="headerlink" title="作用对象与作用方式"></a>作用对象与作用方式</h1><h2 id="Component：类级别的自动注册"><a href="#Component：类级别的自动注册" class="headerlink" title="@Component：类级别的自动注册"></a>@Component：类级别的自动注册</h2><p><code>@Component</code> 是 “声明式” 注解，作用是告诉 Spring：<strong>“这个类需要被你管理，请自动创建它的实例并放入容器”</strong></p><p>Spring会在启动的时候使用默认扫描策略或是<code>@ComponentScan</code>定义的策略（如果有）来通过反射扫描所有标注了<code>@Component</code>以及类似衍生注解的类，实例化这些类，并自动注入到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 标注在类上，Spring 自动扫描后创建 userService Bean</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-comment">// 类的业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;获取用户信息&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Spring Boot 启动类（默认扫描当前包及子包下的 @Component 类）</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(Application.class, args);<br>        <span class="hljs-comment">// 从容器中获取 UserService 实例（已自动注册）</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> context.getBean(UserService.class);<br>        userService.getUserInfo(); <span class="hljs-comment">// 输出：获取用户信息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Bean-方法级别的手动注册"><a href="#Bean-方法级别的手动注册" class="headerlink" title="@Bean: 方法级别的手动注册"></a>@Bean: 方法级别的手动注册</h2><p><code>@Bean</code> 是方法级别注解，只能做用在方法上</p><p><code>@Bean</code> 是 “编程式” 注解，作用是告诉 Spring：<strong>“这个方法的返回值需要被你管理，请将其作为 Bean 放入容器”</strong>。</p><p><code>@Bean</code> 必须定义在 <strong><code>@Configuration</code> 标注的配置类</strong> 或 <strong><code>@Component</code> 标注的类</strong> 中，用于手动控制 Bean 的创建逻辑</p><blockquote><p>在使用<code>@Bean</code>注解注入的时候，推荐搭配<code>@Configuration</code>使用，因为 <code>@Configuration</code> 会通过 CGLIB 增强，保证 Bean 的单例性）</p><p>在Spring容器启动的时候，会扫描指定包下所有标注<code>@Configuration</code>注解的类，执行其中定义的方法，以方法名作为bean名，返回值作为具体的bean对象，注入到Spring容器中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第三方类（无法修改源码，不能用 @Component 标注）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThirdPartyHttpClient</span> &#123;<br>    <span class="hljs-keyword">private</span> String baseUrl;<br>    <span class="hljs-comment">// 有参构造，初始化逻辑复杂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThirdPartyHttpClient</span><span class="hljs-params">(String baseUrl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.baseUrl = baseUrl;<br>        <span class="hljs-comment">// 可能还有其他复杂初始化（如连接池配置、超时设置）</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRequest</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;向 &quot;</span> + baseUrl + <span class="hljs-string">&quot; 发送请求&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 配置类：用 @Bean 手动注册第三方类的 Bean</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanConfig</span> &#123;<br>    <span class="hljs-comment">// 方法返回值作为 Bean，Bean 名称默认是方法名 &quot;httpClient&quot;</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ThirdPartyHttpClient <span class="hljs-title function_">httpClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 手动控制初始化逻辑：传入参数、配置细节</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdPartyHttpClient</span>(<span class="hljs-string">&quot;https://api.example.com&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试：从容器中获取 @Bean 注册的 Bean</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(Application.class, args);<br>        <span class="hljs-type">ThirdPartyHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> context.getBean(ThirdPartyHttpClient.class);<br>        httpClient.sendRequest(); <span class="hljs-comment">// 输出：向 https://api.example.com 发送请求</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用场景最佳实践"><a href="#使用场景最佳实践" class="headerlink" title="使用场景最佳实践"></a>使用场景最佳实践</h1><p><code>@Component</code> 与 <code>@Bean</code> 二者从设计上的初衷就不同</p><p><strong>@Component：适用于 “自定义类” 的自动注册</strong>，当开发的是<strong>自己项目中的类</strong>（如 <code>UserService</code>、<code>OrderRepository</code>），且这些类的<strong>初始化逻辑简单</strong>（无复杂参数、无需调用第三方 API）时，使用 <code>@Component</code>（或其衍生注解）+ 组件扫描，能让 Spring 自动完成 Bean 注册，减少手动配置代码</p><p>而 <strong>@Bean：适用于 “非自定义类” 或 “复杂初始化” 的手动注册</strong>，常常用在：</p><ol><li><strong>第三方类的 Bean 注册</strong>：因为我们无法修改第三方库的源码（如 <code>RedisTemplate</code>、<code>HttpClient</code>、<code>MyBatis</code> 的 <code>SqlSessionFactory</code>），不能在这些类上标注 <code>@Component</code>，此时必须通过 <code>@Bean</code> 手动创建实例并注册到Spring容器中使用</li><li><strong>复杂初始化逻辑</strong>：即使是自定义类，若初始化需要复杂逻辑（如动态参数、条件判断、调用其他服务获取配置），<code>@Component</code> 无法满足（只能依赖默认构造或 <code>@Autowired</code> 注入），而 <code>@Bean</code> 可在方法内编写任意逻辑。</li></ol><h2 id="补充-自定义类复杂初始化的Bean注入对比"><a href="#补充-自定义类复杂初始化的Bean注入对比" class="headerlink" title="补充: 自定义类复杂初始化的Bean注入对比"></a>补充: 自定义类复杂初始化的Bean注入对比</h2><p>这里针对【如果是自定义类复杂初始化逻辑】的情况，需要使用<code>@Bean</code>的方式，下面是代码案例</p><h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>我们以 <strong>“自定义支付客户端”</strong> 为例：</p><p>假设现在这个自定义支付客户端在初始化的时候需要根据环境（开发 &#x2F; 生产）动态选择支付网关地址、调用配置中心获取密钥、初始化连接池，且需支持 “是否启用沙箱模式” 的条件判断 —— 这些复杂逻辑用 <code>@Component</code> 难以实现，而 <code>@Bean</code> 可优雅应对</p><ol><li><strong>动态参数</strong>：支付网关地址（开发环境 <code>dev-url</code> &#x2F; 生产环境 <code>prod-url</code>）从配置文件读取，而非硬编码</li><li><strong>条件判断</strong>：若配置 <code>pay.sandbox.enable=true</code>，则启用沙箱模式（跳过真实签名校验）；否则启用生产模式（严格校验）</li><li><strong>依赖外部服务</strong>：支付密钥需从 “配置中心服务”动态获取，而非直接写在配置文件</li><li><strong>资源初始化</strong>：初始化支付连接池（设置最大连接数、超时时间），确保客户端性能</li></ol><p>假设我们的配置文件内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 激活的环境（dev/prod）</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br><br><span class="hljs-comment"># 支付客户端配置</span><br><span class="hljs-attr">pay:</span><br>  <span class="hljs-comment"># 网关地址（分环境）</span><br>  <span class="hljs-attr">gateway:</span><br>    <span class="hljs-attr">dev-url:</span> <span class="hljs-string">https://dev-pay-gateway.example.com</span><br>    <span class="hljs-attr">prod-url:</span> <span class="hljs-string">https://prod-pay-gateway.example.com</span><br>  <span class="hljs-comment"># 沙箱模式配置（开发环境启用，生产环境禁用）</span><br>  <span class="hljs-attr">sandbox:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-string">$&#123;spring.profiles.active</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;dev&#x27;</span> <span class="hljs-string">?</span> <span class="hljs-attr">true :</span> <span class="hljs-literal">false</span><span class="hljs-string">&#125;</span><br>  <span class="hljs-comment"># 连接池配置</span><br>  <span class="hljs-attr">connection:</span><br>    <span class="hljs-attr">max:</span> <span class="hljs-number">10</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><h3 id="Bean实现"><a href="#Bean实现" class="headerlink" title="@Bean实现"></a>@Bean实现</h3><h4 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayClient</span> &#123;<br>    <span class="hljs-comment">// 1. 动态参数：支付网关地址（开发/生产环境不同）</span><br>    <span class="hljs-keyword">private</span> String gatewayUrl;<br>    <span class="hljs-comment">// 2. 条件参数：是否启用沙箱模式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> sandboxEnable;<br>    <span class="hljs-comment">// 3. 外部依赖：支付密钥（从配置中心获取）</span><br>    <span class="hljs-keyword">private</span> String apiKey;<br>    <span class="hljs-comment">// 4. 资源初始化：连接池配置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxConnections; <span class="hljs-comment">// 最大连接数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> connectTimeout; <span class="hljs-comment">// 连接超时时间（毫秒）</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务方法：发起支付请求</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doPay</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> &#123;<br>        <span class="hljs-comment">// 根据沙箱模式判断是否跳过签名校验</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> sandboxEnable ? <span class="hljs-string">&quot;sandbox-sign&quot;</span> : generateRealSign(orderId, amount);<br>        <span class="hljs-keyword">return</span> String.format(<br>            <span class="hljs-string">&quot;支付请求已发送 -&gt; 网关：%s，订单号：%s，金额：%s，沙箱模式：%s，签名：%s&quot;</span>,<br>            gatewayUrl, orderId, amount, sandboxEnable, sign<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">// 模拟生产环境的真实签名逻辑</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">generateRealSign</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;real-sign-&quot;</span> + orderId + <span class="hljs-string">&quot;-&quot;</span> + amount + <span class="hljs-string">&quot;-&quot;</span> + apiKey;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="配置服务Service"><a href="#配置服务Service" class="headerlink" title="配置服务Service"></a>配置服务Service</h4><p>这个配置服务同样注入到Spring容器中，我们的支付类在实例化时、注入之前需要调用这个配置服务设置字段值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟外部配置中心服务（非自定义类/第三方服务）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigCenterService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据key从配置中心获取配置值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConfig</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 模拟配置中心返回数据（实际可能是HTTP调用、Nacos/Apollo获取）</span><br>        <span class="hljs-keyword">switch</span> (key) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pay.api.key&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;prod_8a7b6c5d4e3f2a1b&quot;</span>; <span class="hljs-comment">// 生产环境密钥</span><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;未知配置key：&quot;</span> + key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例化逻辑"><a href="#实例化逻辑" class="headerlink" title="实例化逻辑"></a>实例化逻辑</h4><p>在配置类中，我们使用 <code>@Bean</code> 实例化我们的自定义支付类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 支付客户端配置类：用<span class="hljs-doctag">@Bean</span>处理复杂初始化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayClientConfig</span> &#123;<br>    <span class="hljs-comment">// 1. 注入外部依赖：配置中心服务（用于获取密钥）</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ConfigCenterService configCenterService;<br><br>    <span class="hljs-comment">// 2. 读取动态参数（从application.yml/properties配置文件）</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.gateway.dev-url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String devGatewayUrl; <span class="hljs-comment">// 开发环境网关</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.gateway.prod-url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String prodGatewayUrl; <span class="hljs-comment">// 生产环境网关</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.profiles.active&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String activeEnv; <span class="hljs-comment">// 当前激活的环境（dev/prod）</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.sandbox.enable:false&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> sandboxEnable; <span class="hljs-comment">// 是否启用沙箱模式（默认false）</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.connection.max:5&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxConnections; <span class="hljs-comment">// 连接池最大连接数（默认5）</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.connection.timeout:3000&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> connectTimeout; <span class="hljs-comment">// 连接超时时间（默认3000ms）</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3. 用<span class="hljs-doctag">@Bean</span>创建PayClient实例：包含所有复杂初始化逻辑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PayClient <span class="hljs-title function_">payClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 步骤1：动态选择支付网关地址（根据当前环境）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">gatewayUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dev&quot;</span>.equals(activeEnv) ? devGatewayUrl : prodGatewayUrl;<br>        System.out.println(<span class="hljs-string">&quot;当前环境：&quot;</span> + activeEnv + <span class="hljs-string">&quot;，选择网关：&quot;</span> + gatewayUrl);<br><br>        <span class="hljs-comment">// 步骤2：调用外部服务（配置中心）获取支付密钥</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">apiKey</span> <span class="hljs-operator">=</span> configCenterService.getConfig(<span class="hljs-string">&quot;pay.api.key&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;从配置中心获取密钥：&quot;</span> + apiKey);<br><br>        <span class="hljs-comment">// 步骤3：条件判断（是否启用沙箱模式）</span><br>        System.out.println(<span class="hljs-string">&quot;沙箱模式启用状态：&quot;</span> + sandboxEnable);<br><br>        <span class="hljs-comment">// 步骤4：初始化PayClient实例（设置所有参数+资源）</span><br>        <span class="hljs-type">PayClient</span> <span class="hljs-variable">payClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PayClient</span>();<br>        payClient.setGatewayUrl(gatewayUrl);<br>        payClient.setSandboxEnable(sandboxEnable);<br>        payClient.setApiKey(apiKey);<br>        payClient.setMaxConnections(maxConnections);<br>        payClient.setConnectTimeout(connectTimeout);<br><br>        <span class="hljs-comment">// 步骤5：额外资源初始化（如连接池预热）</span><br>        initConnectionPool(payClient);<br><br>        <span class="hljs-keyword">return</span> payClient;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 辅助方法：初始化支付连接池（模拟复杂资源初始化）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initConnectionPool</span><span class="hljs-params">(PayClient payClient)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化支付连接池：最大连接数=&quot;</span> + payClient.getMaxConnections() <br>            + <span class="hljs-string">&quot;，超时时间=&quot;</span> + payClient.getConnectTimeout() + <span class="hljs-string">&quot;ms&quot;</span>);<br>        <span class="hljs-comment">// 实际场景：可能初始化HttpClient连接池、数据库连接池等</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Component实现"><a href="#Component实现" class="headerlink" title="@Component实现"></a>@Component实现</h3><p>若强行用 <code>@Component</code> 标注 <code>PayClient</code>，会面临以下不可解决的问题：</p><ol><li><strong>动态参数无法灵活选择</strong>：<br><code>@Component</code> 只能通过 <code>@Value</code> 直接注入单一值（如 <code>@Value(&quot;$&#123;pay.gateway.dev-url&#125;&quot;)</code>），无法根据 <code>activeEnv</code> 的值动态切换 <code>dev-url</code>&#x2F;<code>prod-url</code>。</li><li><strong>条件判断无法嵌入</strong>：<br><code>@Component</code> 无法在初始化时添加 “是否启用沙箱模式” 的逻辑，只能在业务方法中判断，导致客户端实例创建时就携带无效配置（如生产环境仍加载沙箱参数）。</li><li><strong>依赖外部服务获取配置困难</strong>：<br>若用 <code>@Component</code>，为了实现调用配置中心服务，我们需在 <code>PayClient</code> 中 <code>@Autowired</code> 配置中心服务，再通过 <code>@PostConstruct</code> 初始化密钥：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayClient</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ConfigCenterService configCenterService;<br>    <span class="hljs-keyword">private</span> String apiKey;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.apiKey = configCenterService.getConfig(<span class="hljs-string">&quot;pay.api.key&quot;</span>);<br>        <span class="hljs-comment">// 但动态网关、条件判断仍无法实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>@Component</code>与<code>@Bean</code>本身都是注入Bean到Spring容器的两个注解</p><p>如果是自己编写的类，并且初始化逻辑并不复杂，只是简单的调用别的bean，那么使用<code>@Component</code>（及其类似衍生物）是更方便的实现方式</p><p>而相比于 <code>@Component</code>,<code>@Bean</code>更适合：</p><ul><li>第三方包里不会自动注入的类</li><li>自定义的类、但是这个类由于业务关系，初始化的时候依赖比较多</li></ul><p>虽然实现和配置较为复杂（因为还需要编写一个额外的<code>@Configuration</code>的配置类供Spring扫描）但更灵活</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏札记|生化奇兵 无限</title>
    <link href="/2025/08/20/%E6%B8%B8%E6%88%8F%E6%9C%AD%E8%AE%B0-%E7%94%9F%E5%8C%96%E5%A5%87%E5%85%B5-%E6%97%A0%E9%99%90/"/>
    <url>/2025/08/20/%E6%B8%B8%E6%88%8F%E6%9C%AD%E8%AE%B0-%E7%94%9F%E5%8C%96%E5%A5%87%E5%85%B5-%E6%97%A0%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h1 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a><strong>基础信息</strong></h1><p>游戏名称：生化奇兵无限</p><p>发行年份：2013</p><p>开发商&#x2F;发行商：Irrational Games （传奇人物 Ken Levine）</p><p>平台与版本：我是在 XBOX ONE X 上玩的完整版，实体版本则是购入原版的PS3版本</p><h1 id="游戏性（Gameplay）"><a href="#游戏性（Gameplay）" class="headerlink" title="游戏性（Gameplay）"></a><strong>游戏性（Gameplay）</strong></h1><h2 id="核心循环"><a href="#核心循环" class="headerlink" title="核心循环"></a><strong>核心循环</strong></h2><p>游戏本身的玩法更像是以 [泰坦陨落2] 为代表的第一人称单人线性射击游戏。游戏流程采用一本道的关卡设计，并无明显的章节划分，玩家只需要跟随布克德维特的视角体验故事。</p><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a><strong>系统设计</strong></h2><p>在战斗系统方面，本作沿用了和其他沉浸式模拟类，或者说是 0451 type of game 一样的、经典的左手魔法与右手打枪的设计。但是游戏本身的设计并不能算得上有任何的沉浸式模拟要素。整个流程中推进剧情的方式十分简单：跟随箭头指引，到目的地点，观看剧情&#x2F;进行遭遇战，仅此而已。相比于生化奇兵1而言，弱化了探索、简化了资源管理、移除了沉浸式模拟要素。</p><p>此外游戏还提供了装备的选择，分为身体四个部位，每个部位只能同时装备一件道具，道具随着流程可以通过解开钥匙房间或是完成支线任务获得更多装备道具。这些装备有的是增强魔法技能效果，有些是扩充弹夹，玩家可以自己自由组合。但是组合的丰富度上，相比生化奇兵1来说我认为是退步或者说是简化的，生化奇兵1的装备系统。</p><p>上面提到了支线任务，本作提供了支线任务的选项，但是在我的流程体验中，游戏前期我还是当作生化奇兵1来玩，任何角落都要舔一遍，就这样我也只发现了两处支线任务。而这两处支线任务设计也很一般，只需要找到某个条件后再回到原处就算完成。任务的奖励也只有装备道具，血量&#x2F;魔法&#x2F;护甲上限提升。整体来说正反馈不够强，因此进行到游戏的中后期，我一心只想推剧情，直接无视支线任务XD</p><h2 id="节奏感"><a href="#节奏感" class="headerlink" title="节奏感"></a><strong>节奏感</strong></h2><p>然而游戏本身的节奏感并未因此受到影响。恰恰相反，每一场遭遇战都不拖沓，没有明显的堆怪或是刻意为难的地方。我是在普通难度下通关的，在我长达10小时左右的流程中，唯一觉得有难度的就是最后的一个战点。同时，随着游戏流程的推进，扣人心弦的故事情节也更让玩家想要继续了解后面的故事。整体来说，作为一款线性流程的单机游戏，本作在节奏感方面把握的十分恰当，相比于我今年同期玩的 [神秘海域2] 以及 [泰坦陨落2] 来说更加出色.</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK8|LockSupport</title>
    <link href="/2025/08/13/JDK8-LockSupport/"/>
    <url>/2025/08/13/JDK8-LockSupport/</url>
    
    <content type="html"><![CDATA[<p>LockSupport 是一个用来创建锁和其他同步工具类的<strong>基本线程阻塞原语</strong></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>说到线程阻塞和唤醒自然而然就会拿他和 <code>Object.wait()/Object.notify()</code> 进行对比</p><p>我们直接上代码</p><h2 id="任何地方都可以使用"><a href="#任何地方都可以使用" class="headerlink" title="任何地方都可以使用"></a>任何地方都可以使用</h2><p>以 wait &amp; notify 举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitNotify</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">waitThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>            lock.wait(); <span class="hljs-comment">//释放锁并进入阻塞态</span><br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>         &#125;<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;waitThread get notified&quot;</span>);<br>   &#125;, <span class="hljs-string">&quot;waitThread&quot;</span>);<br><br>   waitThread.start();<br><br>   <span class="hljs-comment">//确保waitThread先拿到锁</span><br>   Thread.sleep(<span class="hljs-number">500L</span>);<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">notifyThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;notifyThread notify waitThread&quot;</span>);<br>      <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>         lock.notify();<br>      &#125;<br>   &#125;, <span class="hljs-string">&quot;notifyThread&quot;</span>);<br>   notifyThread.start();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>换成 LockSupport</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUnpark</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">parkThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;parkThread blocked by park&quot;</span>);<br><br>      LockSupport.park();<br><br>      System.out.println(<span class="hljs-string">&quot;parkThread notified by unparkThread&quot;</span>);<br>   &#125;, <span class="hljs-string">&quot;parkThread&quot;</span>);<br>   parkThread.start();<br><br>   <span class="hljs-comment">//确保parkThread先拿到锁</span><br>   Thread.sleep(<span class="hljs-number">500L</span>);<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">unparkThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>      System.out.println(<span class="hljs-string">&quot;unparkThread notify parkThread&quot;</span>);<br><br>      LockSupport.unpark(parkThread);<br><br>   &#125;, <span class="hljs-string">&quot;unparkThread&quot;</span>);<br>   unparkThread.start();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现 LockSupport 不像是 wait&#x2F;notify 那样必须要在 synchronized 下才能使用</p><h2 id="无唤醒顺序依赖"><a href="#无唤醒顺序依赖" class="headerlink" title="无唤醒顺序依赖"></a>无唤醒顺序依赖</h2><p>此外，LockSupport 相比于  wait&#x2F;notify ，还解决了顺序问题，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unorderedWaitNotify</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">waitThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-comment">//模拟先notify再wait</span><br>      <span class="hljs-keyword">try</span> &#123;<br>         Thread.sleep(<span class="hljs-number">2000L</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>      &#125;<br>      <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>            lock.wait(); <span class="hljs-comment">//释放锁并进入阻塞态</span><br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>         &#125;<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;waitThread get notified&quot;</span>);<br>   &#125;, <span class="hljs-string">&quot;waitThread&quot;</span>);<br>   waitThread.start();<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">notifyThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;notifyThread notify waitThread&quot;</span>);<br>      <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>         lock.notify();<br>      &#125;<br>   &#125;, <span class="hljs-string">&quot;notifyThread&quot;</span>);<br>   notifyThread.start();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码，我们模拟先 notify 再 wait，结果就是 waitThread 永远地阻塞住了，程序无法正常结束</p><p>但是如果换用 LockSupport</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unorderedParkUnpark</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">parkThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-comment">//先unpark再park</span><br>      <span class="hljs-keyword">try</span> &#123;<br>         Thread.sleep(<span class="hljs-number">2000L</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;parkThread blocked by park&quot;</span>);<br><br>      LockSupport.park();<br><br>      System.out.println(<span class="hljs-string">&quot;parkThread notified by unparkThread&quot;</span>);<br>   &#125;, <span class="hljs-string">&quot;parkThread&quot;</span>);<br>   parkThread.start();<br><br><br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">unparkThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>      System.out.println(<span class="hljs-string">&quot;unparkThread notify parkThread&quot;</span>);<br><br>      LockSupport.unpark(parkThread);<br><br>   &#125;, <span class="hljs-string">&quot;unparkThread&quot;</span>);<br>   unparkThread.start();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们先 unpark 再 park，结果可以发现虽然 unparkThread 先执行了 unpark 尝试唤醒，但是此时 parkThread 还在睡，还没 park 操作。但是不影响，2s 后 parkThread 调用 park 后立刻就被唤醒了</p><p>这也是 <code>park/unpark</code> 和 <code>wait/notify</code> 的另一个核心区别：不论调用顺序，只要成对出现，必然可以唤醒线程</p><h2 id="中断状态处理"><a href="#中断状态处理" class="headerlink" title="中断状态处理"></a>中断状态处理</h2><p>在使用层面，<code>wait()</code> 会抛出 InterruptedException 需要手动 catch 处理，但是 <code>park()</code> 不会，<code>park()</code> 确实会响应线程中断，但是只是不抛出异常。除此之外 <code>park()</code> 中断后不会 clear 中断状态，而 <code>wait()</code> 中断后抛出异常会 clear 中断状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitInterrupted</span><span class="hljs-params">()</span> &#123;<br><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">waitThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>            lock.wait();<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">//中断后被Catch，中断状态被clear</span><br>            System.out.println(<span class="hljs-string">&quot;park thread interrupted, interrupted: &quot;</span> + Thread.currentThread().isInterrupted());<br>         &#125;<br>      &#125;<br>   &#125;, <span class="hljs-string">&quot;waitThread&quot;</span>);<br><br>   waitThread.start();<br>   waitThread.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkInterrupted</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">parkThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>      LockSupport.park();<br>      <span class="hljs-comment">//中断后 park 方法立刻返回，中断状态未被clear</span><br>      System.out.println(<span class="hljs-string">&quot;park thread interrupted, interrupted: &quot;</span> + Thread.currentThread().isInterrupted());<br><br>   &#125;, <span class="hljs-string">&quot;parkThread&quot;</span>);<br><br>   parkThread.start();<br>   parkThread.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么不会清除中断状态"><a href="#为什么不会清除中断状态" class="headerlink" title="为什么不会清除中断状态"></a>为什么不会清除中断状态</h3><p>那么为什么 wait() 中断后会清除状态而 park() 中断后不会清除状态呢？</p><p>原因需要从 wait() 以及 park() 使用和设计的角度出发：</p><ul><li>wait() 面向程序业务编写者，抛出的 InterruptedException 就是在强制要求处理中断后的逻辑，清除状态是为了后续业务逻辑能正常运行</li><li>park() 面向上层工具（例如 ReentrantLock），保留中断状态是为了供上层工具调用 <code>Thread.currentThread().interrupted()</code> 查询中断状态后进行定制化的进一步处理（例如告警、忽略、抛出异常）</li></ul><p>还是看代码</p><p>对于 wait，就像是餐厅等餐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitScenario</span> &#123;<br>    <span class="hljs-comment">// 共享锁对象（相当于餐厅的取餐台）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">foodCounter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">// 标记餐是否做好</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">foodReady</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 顾客线程（等待取餐）</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (foodCounter) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 没做好就等</span><br>                    <span class="hljs-keyword">while</span> (!foodReady) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;顾客：餐还没好，我先等会儿...&quot;</span>);<br>                        foodCounter.wait(); <span class="hljs-comment">// 等待时可能被中断（接到紧急电话）</span><br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;顾客：拿到餐了，走人～&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-comment">// 接到紧急电话，必须显式处理中断</span><br>                    System.out.println(<span class="hljs-string">&quot;顾客：接到紧急电话，不等了！&quot;</span>);<br>                    <span class="hljs-comment">// 关键：此时中断状态已被清除（wait()自动做的）</span><br>                    System.out.println(<span class="hljs-string">&quot;中断状态（清除后）：&quot;</span> + Thread.currentThread().isInterrupted()); <span class="hljs-comment">// false</span><br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;顾客&quot;</span>);<br><br>        customer.start();<br>        <span class="hljs-comment">// 模拟500ms后，顾客接到紧急电话（中断）</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        customer.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>wait()</code>的核心是 “等待某个条件（餐做好）”，中断的含义是 “外部要求停止等待”</p><p>在中断后如果不清除中断状态，假设顾客中断后又想 “重新等待”（比如电话是误报）（其实就对应线程后续可能存在的业务逻辑），后续的<code>wait()</code>会因为 “中断状态残留” 直接失败（因为<code>wait()</code>会检查中断状态，有残留就直接抛异常）</p><p>而对于 park，更像是用在客制化锁的锁芯设计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkScenario</span> &#123;<br>    <span class="hljs-comment">// 门禁锁（用park/unpark实现）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoorLock</span> &#123;<br>        <span class="hljs-comment">// 记录当前持有锁的线程（谁刷脸成功了）</span><br>        Thread owner;<br><br>        <span class="hljs-comment">// 上锁（门外的人等待）</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 如果不是自己持有锁，就一直等</span><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().equals(owner)) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：在门外等...&quot;</span>);<br>                LockSupport.park(); <span class="hljs-comment">// 等待时可能被撬锁（中断）</span><br><br>                <span class="hljs-comment">// 关键：park()被中断后，保留中断状态，让锁判断如何处理</span><br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-comment">// 这里可以灵活选择：抛异常/忽略/记录日志</span><br>                    System.out.println(<span class="hljs-string">&quot;门禁系统：检测到撬锁！&quot;</span>);<br>                    <span class="hljs-comment">// 清除状态（可选，根据需求）</span><br>                    Thread.interrupted();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 解锁（刷脸成功）</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>            owner = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">DoorLock</span> <span class="hljs-variable">door</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoorLock</span>();<br><br>        <span class="hljs-comment">// 路人甲线程（想进门）</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">personA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            door.lock(); <span class="hljs-comment">// 调用lock，内部会park</span><br>            System.out.println(<span class="hljs-string">&quot;路人甲：进门了～&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;路人甲&quot;</span>);<br><br>        personA.start();<br>        <span class="hljs-comment">// 模拟500ms后有人撬锁（中断）</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        personA.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>park()</code>是底层工具，用来实现 “阻塞等待”，而上层的<code>DoorLock</code>需要自主决定如何处理异常情况（比如撬锁）</p><p>如果<code>park()</code>清除了中断状态，<code>DoorLock</code>的<code>lock()</code>方法就无法知道 “线程被中断过”（即 “被撬过”），也就无法执行报警、日志等逻辑 —— 灵活性完全丧失</p><p>保留状态后，上层工具（<code>DoorLock</code>）可以通过<code>isInterrupted()</code>查询到 “被中断过”，再根据需求自定义处理（比如抛异常、重试、忽略），这正是<code>park()</code>作为 <strong>“底层原语”</strong> 的设计目的</p><p>简单说：<code>wait()</code>是给 “直接用它写业务” 的人用的，必须强制处理中断并清状态，避免业务混乱；<code>park()</code>是给 “造工具” 的人用的，保留状态才能让工具更灵活</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过 LockSupport 的 <code>park/unpark</code> 和 <code>wait/notify</code> 的对比，我们可以简单总结：他们都可以实现线程的等待和唤醒。但是区别在于</p><table><thead><tr><th>特性</th><th><code>wait()/notify()</code></th><th><code>LockSupport.park()/unpark()</code></th></tr></thead><tbody><tr><td>同步要求</td><td>必须在<code>synchronized</code>块中调用</td><td>无任何同步要求，可在任意位置调用</td></tr><tr><td>唤醒顺序依赖</td><td>必须先<code>wait</code>后<code>notify</code>，否则失效</td><td>顺序无关，<code>unpark</code>可提前 “预支” 许可</td></tr><tr><td>唤醒目标</td><td><code>notify()</code>随机唤醒一个等待线程</td><td><code>unpark(thread)</code>精确唤醒指定线程</td></tr><tr><td>中断响应</td><td>抛出<code>InterruptedException</code>，清除中断状态</td><td>不抛异常，保留中断状态</td></tr><tr><td>底层机制</td><td>依赖对象监视器（monitor）</td><td>依赖 “许可”（permit）机制</td></tr></tbody></table><p>而对于中断状态的处理，二者的处理逻辑不同</p><table><thead><tr><th>场景</th><th><code>wait()</code>的逻辑（餐厅取餐）</th><th><code>park()</code>的逻辑（门禁锁开发）</th></tr></thead><tbody><tr><td>使用者</td><td>业务开发者（直接处理等待 &#x2F; 唤醒）</td><td>工具类开发者（用它构建更复杂的锁 &#x2F; 同步工具）</td></tr><tr><td>中断的含义</td><td>“停止等待”（必须显式处理，否则业务会出错）</td><td>“异常情况”（需要留给工具类自主决定如何处理）</td></tr><tr><td>状态处理的必要性</td><td>清除状态：避免影响后续的等待逻辑（比如重新等待）</td><td>保留状态：让上层工具能感知异常，实现灵活处理（报警 &#x2F; 忽略等）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gson|忽略指定字段</title>
    <link href="/2025/08/13/Gson-%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5/"/>
    <url>/2025/08/13/Gson-%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><p>直接看代码，项目采用 JPA ORM，在实现一对多关联的时候，需要这样设置PO</p><p>假设一个任务对应多个任务节点</p><p>任务实体TaskConfig：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonIgnoreProperties(value = &#123;&quot;taskPO&quot;&#125;)</span><br><span class="hljs-meta">@OneToMany(mappedBy = &quot;taskPO&quot;, fetch = FetchType.LAZY, cascade = &#123;CascadeType.ALL&#125;, orphanRemoval = true)</span><br><span class="hljs-keyword">private</span> List&lt;TaskNodeConfig&gt; nodeConfigList;<br><br></code></pre></td></tr></table></figure><p>任务节点实体TaskNodeConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ManyToOne(targetEntity = TaskConfig.class, fetch = FetchType.LAZY)</span><br><span class="hljs-meta">@JoinColumn(name = &quot;task_config_code&quot;, referencedColumnName = &quot;code&quot;, foreignKey = @ForeignKey(value = ConstraintMode.NO_CONSTRAINT))</span><br><span class="hljs-keyword">private</span> TaskConfig taskPO;<br></code></pre></td></tr></table></figure><p>上面的<code>@JoinColumn(name = &quot;task_config_code&quot;, referencedColumnName = &quot;code&quot;</code> 用于指定我们任务节点实体表中的<code>task_config_code</code>字段对应任务实体表中的<code>code</code>字段作关联</p><p>这样定义才可以实现关联，但是在序列化<strong>任务实体</strong>对象的时候存在问题：</p><p>任务实体对象有nodeConfigList字段，nodeConfigList字段中每一个元素又都有各自的taskPO字段；taskPO字段中又有nodeConfigList字典，因此如果不在序列化的时候忽略taskPO字段，则会子子孙孙无穷匮也</p><h1 id="忽略字段实现"><a href="#忽略字段实现" class="headerlink" title="忽略字段实现"></a>忽略字段实现</h1><p>GOSN中提供了三种方式来实现字段的忽略：</p><ul><li>transient关键字</li><li>@Expose注解指定哪些字段【要】序列化</li><li>实例化Gson对象时指定策略</li></ul><p>三种方式各有具体的使用场景以及限制，下面展开描述</p><h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p>对于想要忽略的字段使用 transient 关键字进行修饰</p><p>但是在上面的例子中并不适用，因为要忽略的 taskPO 字段是需要给 JPA 作为关联表关联键的，如果设置为 transient 修饰，启动会报 JPA 的错，说 field not found</p><h2 id="Expose"><a href="#Expose" class="headerlink" title="@Expose"></a>@Expose</h2><p>这种方式是忽略的反方向，指定哪些字段要序列化</p><p>但是此处我们只想忽略这一个字段，如果对象中剩下的字段较多，这种方式也不合适</p><p>顺带一提，如果选择使用<code>@Expose</code>的方式，在序列化的时候应该调用像下面这样的GSON实例的toJSONString函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Gson</span> <span class="hljs-variable">gsonExclude</span> <span class="hljs-operator">=</span> getExcludeGsonBuilder().create();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GsonBuilder <span class="hljs-title function_">getExcludeGsonBuilder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonBuilder</span>()<br>            .setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)<br>            .disableInnerClassSerialization()<br>            <span class="hljs-comment">//开启expose功能</span><br>            .excludeFieldsWithoutExposeAnnotation()<br>            .disableHtmlEscaping();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义排除策略"><a href="#自定义排除策略" class="headerlink" title="自定义排除策略"></a>自定义排除策略</h2><p>我们新建一个自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><br><span class="hljs-meta">@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> IgnoreGsonField &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>将注解打在想要忽略的字段上，例如之前的任务节点类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@IgnoreGsonField</span> <span class="hljs-comment">//自定义注解</span><br><span class="hljs-meta">@ManyToOne(targetEntity = TaskConfig.class, fetch = FetchType.LAZY)</span><br><span class="hljs-meta">@JoinColumn(name = &quot;task_config_code&quot;, referencedColumnName = &quot;code&quot;, foreignKey = @ForeignKey(value = ConstraintMode.NO_CONSTRAINT))</span><br><span class="hljs-keyword">private</span> TaskConfig taskPO;<br></code></pre></td></tr></table></figure><p>在实例化GSON对象的时候，实现<code>ExclusionStrategy</code>来指定排除策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Gson</span> <span class="hljs-variable">gsonAnnotationExclude</span> <span class="hljs-operator">=</span> getExcludeAnnotationGsonBuilder().create();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GsonBuilder <span class="hljs-title function_">getExcludeAnnotationGsonBuilder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonBuilder</span>()<br>            .setExclusionStrategies(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExclusionStrategy</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSkipField</span><span class="hljs-params">(FieldAttributes fieldAttributes)</span> &#123;<br>                    <span class="hljs-keyword">return</span> fieldAttributes.getAnnotation(IgnoreGsonField.class) != <span class="hljs-literal">null</span>;<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSkipClass</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>                    <span class="hljs-keyword">return</span> clazz.isAnnotationPresent(IgnoreGsonField.class);<br>                &#125;<br>            &#125;)<br>            .serializeNulls()<br>            .setDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)<br>            .disableInnerClassSerialization()<br>            .disableHtmlEscaping();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果只希望在序列化和反序列化的时候暴露指定字段，使用<code>@Expose</code>并结合<code>GsonBuilder.excludeFieldsWithoutExposeAnnotation()</code>实例化支持Expose注解的GSON实例使用</p><p>如果希望忽略个别字段（如本文场景），可以使用自定义注解，结合<code>GsonBuilder.setExclusionStrategies()</code>实例化排除指定注解修饰字段的GSON实例使用</p>]]></content>
    
    
    <categories>
      
      <category>开发技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GSON</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xbox360|Bad Update Exploit</title>
    <link href="/2025/08/10/xbox360-Bad-Update-Exploit/"/>
    <url>/2025/08/10/xbox360-Bad-Update-Exploit/</url>
    
    <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><p>一直以来xbox360的mod方案都是需要拆机焊接芯片的（例如RGH,JTAG方案），唯一不拆机的方案也有，但是不能运行homebrew软件，只能做到最基础的刻盘玩游戏</p><p>但是随着Bad Update漏洞的发现，现在已经可以做到不拆机的情况下运行那些可以在RGH&#x2F;JTAG上才能运行的自制软件了</p><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><ul><li>任意型号的xbox360</li><li>1GB以上的U盘</li></ul><h1 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h1><p>在 BadUpdate v1.2 以前，漏洞想要触发的几率是比较低的，大概在30%左右，而且每一次都需要几分钟的时间</p><p>但是前几天 BadUpdate 更新了1.2版本，优化了底层实现，现在漏洞的触发概率达到了80%左右</p><p>在第一次引导破解的时候，本人的 xbox360 slim 只花了1分钟左右就进入了</p><p>下面记录触发的流程</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>确保机器断开所有网络，包括有线和无线</p><p>将所有账户的自动登录设置为关闭状态</p><p>新建一个用户，但是不要关联xboxlive账号，将其设置为自动登录</p><p>将U盘插入xbox360，格式化</p><p>格式化后拔出xbox360，关机</p><h2 id="文件准备"><a href="#文件准备" class="headerlink" title="文件准备"></a>文件准备</h2><p>采用 alex-free 打包整合的 360 hack pack</p><p>这里我选择的是 XeUnshackle 版本，因为整合了 DashLaunch 插件</p><p>将材料包中<code>files</code>目录下的所有文件复制到U盘的根目录</p><p>至此，文件准备完毕</p><h2 id="启动漏洞"><a href="#启动漏洞" class="headerlink" title="启动漏洞"></a>启动漏洞</h2><p>将U盘插入xbox360</p><p>xbox360开机（此时自动登入之前创建的新账号）</p><p>进入【游戏】——【我的游戏】——选择 Rock Band Blitz</p><p>此时如果游戏启动让你选择存档存储的装置，务必选择【USB装置】（也就是刚刚插入的U盘）</p><p>按A开始游戏</p><p>此时游戏会显示【Running Expolit】</p><p>等待片刻后（可能是几分钟）漏洞运行成功</p><blockquote><p>注意：如果在等待的时候 Rock Band Blitz 标题界面上的音乐和动画停止了，那么说明本次的引导属于Bad Update 80%成功率当中的那20%，需要重启机器再跑一遍本环节流程</p></blockquote><p>现在会显示 XeUnshackle 的成功信息，可以备份一些系统的信息（例如 CPU key）</p><p>按手柄的 back 退出</p><p>等待几秒后，进入 Aurora Dashboard</p><p>至此homebrew自由</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Bad Update 从最早的 30% 成功率到现在的 80%，可以说已经从图一乐变成了真正的可使用</p><p>虽然比不上脉冲芯片那样暴力方便，但是考虑到硬破的成本以及繁琐程度，Bad Update 是目前 xbox360 所有mod 方案中我最能接受的一种 :)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://consolemods.org/wiki/Xbox_360:Bad_Update">https://consolemods.org/wiki/Xbox_360:Bad_Update</a></p><p><a href="https://alex-free.github.io/360-hack-pack/">https://alex-free.github.io/360-hack-pack/</a></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xbox360</tag>
      
      <tag>XBOX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>202508|技术日志</title>
    <link href="/2025/08/04/202508-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/"/>
    <url>/2025/08/04/202508-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="0804"><a href="#0804" class="headerlink" title="0804"></a>0804</h1><h2 id="Thread-interrupt"><a href="#Thread-interrupt" class="headerlink" title="Thread.interrupt()"></a>Thread.interrupt()</h2><h3 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h3><p>今天有一个需求是将原先单独部署的服务B迁移到现在的服务A中，A服务启动的时候顺带把B服务一起启动了，在服务B的核心启动逻辑中有这么一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    server.start();<br>    Thread.currentThread().join();<br>&#125; <span class="hljs-keyword">catch</span> (DeploymentException | InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    server.stop();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Thread.currentThread().join()</code> 这一行是将当前线程进行阻塞</p><p>因此不能直接串行式地照搬代码，否则会出现A服务启动一半开始启动服务B的时候，服务B确实启动了，然后就一直阻塞住了。</p><p>最佳实践的方式是：另起一个线程来启动服务B并进行阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 另起一个线程</span><br>webSocketThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        webSocketLanguageServer.doStart();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;服务启动失败&quot;</span>, e);<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;groovy-websocket-server-thread&quot;</span>);<br><br>webSocketThread.setDaemon(<span class="hljs-literal">false</span>);<br>webSocketThread.start();<br></code></pre></td></tr></table></figure><p>从系统资源安全性的角度出发，我们应当实现：当服务A停止之前，顺带把服务B先停止了</p><p>这个时候我们就需要用到 <code>Thread.interrupt()</code></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><em>threadA.interrupt()</em> 方法用于向线程<strong>发送中断信号</strong></p><p>从系统设计的角度出发，<strong>一个线程的停止（生命周期），不应该受其他线程的控制</strong>。因此在 Thread 类中 stop, destory 等方法都是被标记为过时的</p><p>也正因此，interrupt 并不保证会立刻终止线程，只是进行通知，通知线程<strong>应该被中断了</strong></p><p>具体到底中断还是继续运行，应该由被通知的线程自己处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Deprecated</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">security</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>     <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;<br>         checkAccess();<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> != Thread.currentThread()) &#123;<br>             security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);<br>         &#125;<br>     &#125;<br>     <span class="hljs-comment">// A zero status value corresponds to &quot;NEW&quot;, it can&#x27;t change to</span><br>     <span class="hljs-comment">// not-NEW because we hold the lock.</span><br>     <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>) &#123;<br>         resume(); <span class="hljs-comment">// Wake up thread if it was suspended; no-op otherwise</span><br>     &#125;<br><br>     <span class="hljs-comment">// The VM can handle all thread states</span><br>     stop0(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDeath</span>());<br> &#125;<br><br><span class="hljs-meta">@Deprecated</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(Throwable obj)</span> &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br> &#125;<br><br> <span class="hljs-meta">@Deprecated</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchMethodError</span>();<br> &#125;<br><br></code></pre></td></tr></table></figure><p>真正的流程是，某个线程（比如 main 线程）调用了 某个线程 A 的 interrupt 方法，此时根据线程 A 所处的状态来决定后续的状态：</p><ul><li>如果线程处于阻塞态，比如调用了 <code>wait()</code>, <code>join()</code>：阻塞的线程会立刻退出阻塞态并抛出 <code>InterruptedException</code></li><li>如果线程只是正常执行：线程只是修改当前 interrupt 的标记，不做任何操作</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>我们之前提到：</p><blockquote><p>具体到底中断还是继续运行，应该由被通知的线程自己处理</p></blockquote><p>这就是使用线程时的最佳实践：</p><ul><li>如果线程执行逻辑有被中断的需求，那么就需要在运行时通过 <code>Thread.interrupted()</code> 检查当前的中断标志，如果已经中断自行跳转逻辑</li><li>在调用阻塞等方法时，尤其需要注意处理 throws 的 <code>InterruptedException</code>，如果涉及到服务资源的，需要关闭资源；或是 catch 异常后结束线程逻辑</li></ul><p>现在我们再看下面这些代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">needInterruptThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>        <span class="hljs-comment">//do something</span><br>    &#125;<br>&#125;, <span class="hljs-string">&quot;needInterruptThread&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//非阻塞启动服务 </span><br>    server.start();<br>    Thread.currentThread().join();<br>&#125; <span class="hljs-keyword">catch</span> (DeploymentException | InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    server.stop();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面就是基于最佳实践编写的代码，其中第二部分在服务非阻塞启动后，阻塞当前线程，很好地处理了 <code>InterruptedException</code>，在 finally 中释放资源</p><p>因此，回归最初导论中的问题：想实现当服务A停止之前，顺带把服务B先停止的操作</p><p>只需要在 A 服务中新增一个 hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (webSocketThread != <span class="hljs-literal">null</span> &amp;&amp; webSocketThread.isAlive()) &#123;<br>        log.info(<span class="hljs-string">&quot;停止 WebSocket 服务...&quot;</span>);<br>        webSocketThread.interrupt(); <span class="hljs-comment">//通知服务线程中断阻塞，停止服务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用 <code>webSocketThread.interrupt()</code> 后，通知了跑着服务的B线程应该进行中断了。而B线程的实现逻辑中又catch了异常，在 finally 中停止了核心服务的资源</p><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><p>经常背八股的同学都知道，创建线程的方式有：</p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li><li>使用ThreadPoolExecutor线程池</li><li>…</li></ul><p>我们来看代码，以实现 Runnable 接口为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintThreadName</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: run&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">PrintThreadName</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintThreadName</span>();<br>    task.run(); <span class="hljs-comment">//main: run</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样调用我们会发现结果实际上还是 <code>main: run</code></p><p>这是因为你实现了 Runnable 接口，但选择直接调用 Runnable 实现类的 run 方法，本质上还是在主线程进行方法调用，和普通的方法调用并无本质区别</p><p>真正想要在另外一个线程打印，<strong>只有一个入口</strong>：调用 thread 对象实例的 <code>start()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">PrintThreadName</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintThreadName</span>();<br>    task.run(); <span class="hljs-comment">//main: run</span><br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">anotherThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;anotherThread&quot;</span>);<br>    anotherThread.start(); <span class="hljs-comment">//anotherThread: run</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程体-amp-线程"><a href="#线程体-amp-线程" class="headerlink" title="线程体 &amp; 线程"></a>线程体 &amp; 线程</h3><p>我们上面说的八股中常见的什么继承 Thread 类等等操作，严格意义上来说是 <strong>创建线程体</strong> 而不是创建线程</p><p>线程体定义了线程执行时具体应该执行的任务，是线程执行任务的承载体，是一个接口（标准）</p><p>所以才需要我们继承 Thread 类重写 run 方法&#x2F; 实现 Runnable&#x2F;Callable 接口，这些都是为了定义线程跑起来的时候应该做什么，本质上并没有创建线程</p><p>唯一创建线程的只有一个入口：调用 thread 对象实例的 <code>start()</code>，<strong>只是我们可以用多种构造线程体的方式，在实例化 thread 对象的时候以多种形式向构造函数传参</strong></p><p>想要让程序片段在另起的线程上跑，不管是 JDK 源码库的实现逻辑（例如使用线程池）还是我们之前提到的实现 Runnable 接口，本质上只有唯一一种，就是先实例化 Thread 类实例，然后调用 <code>start()</code></p><h1 id="0805"><a href="#0805" class="headerlink" title="0805"></a>0805</h1><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><a href="https://blog.csdn.net/2401_82656016/article/details/143273371">参考</a></p><p>前置内容：需要了解原生的 <code>synchronized</code> 以及 <code>Object.wait() / Object.notify()</code> </p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code> 的核心作用是<strong>给代码块或方法加锁</strong>，确保同一时间只有一个线程能执行被锁定的代码。它有两个关键特性：</p><ul><li><strong>互斥性</strong>：同一时间只有一个线程能持有锁（其他线程会阻塞等待）。</li><li><strong>可见性</strong>：线程释放锁时，会将修改后的共享变量同步到主内存；其他线程获取锁时，会从主内存读取最新的变量值。</li></ul><p><code>synchronized</code> 的语法有两种：</p><ul><li>修饰方法（如 <code>synchronized void method()</code>）：锁对象是当前实例（非静态方法）或类对象（静态方法）。</li><li>修饰代码块（如 <code>synchronized(lockObj) &#123; ... &#125;</code>）：锁对象是括号里的 <code>lockObj</code>（必须是一个对象，不能是基本类型）。</li></ul><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait-notify"></a>wait-notify</h3><p><code>Object.wait() / Object.notify()</code> 是 JDK 提供的多线程环境下线程的 <code>等待————同步</code> 机制，用于实现<strong>线程间的协作</strong>（比如一个线程等待某个条件，另一个线程满足条件后唤醒它）</p><p>需要注意的是必须在 <code>synchronized</code> 中定义，不然会抛出 <code>IllegalMonitorStateException</code></p><ul><li><strong><code>wait()</code><strong>：让当前线程</strong>释放锁</strong>并进入<strong>Waiting 状态</strong>（被动等待），直到被其他线程通过 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒。其中释放锁是关键：如果不释放锁，其他线程永远无法获取锁，会导致死锁。</li><li><strong><code>notify()</code><strong>：随机唤醒一个正在等待当前锁的线程（使其从 Waiting 状态退出），但</strong>被唤醒的线程不会立即执行</strong>，而是需要重新竞争获取锁（获取到锁后才会继续执行）。</li></ul><h3 id="测试demo"><a href="#测试demo" class="headerlink" title="测试demo"></a>测试demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLifeStatusTest</span> &#123;<br>     <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">waitLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//Thread.State.NEW</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">newStatusThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//do something</span><br>        &#125;, <span class="hljs-string">&quot;newStatusThread&quot;</span>);<br><br>        <span class="hljs-comment">//Thread.State.RUNNABLE</span><br>        <span class="hljs-comment">//RUNNABLE态，是否执行取决于操作系统是否将CPU时间片分到线程</span><br>        newStatusThread.start();<br><br>        <span class="hljs-comment">//阻塞态，此时不会占用CPU执行权</span><br>        createBlockedThread();<br><br>        <span class="hljs-comment">//等待态</span><br>        createWaitThread();<br><br>        <span class="hljs-comment">//超时等待态</span><br>        createTimedWaitingThread();<br><br>        <span class="hljs-comment">//终止态</span><br>        <span class="hljs-comment">//线程中方法执行完毕或是抛出异常自动进入终止状态</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createBlockedThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">blocked1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(LocalTest::acquire, <span class="hljs-string">&quot;blocked1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">blocked2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(LocalTest::acquire, <span class="hljs-string">&quot;blocked2&quot;</span>);<br>        <span class="hljs-comment">//肯定有一个会进入Thread.State.BLOCKED</span><br>        blocked1.start();<br>        blocked2.start();<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createWaitThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">waitingThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (waitLock) &#123; <span class="hljs-comment">//获取锁</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitLock.wait(); <span class="hljs-comment">// 释放锁并进入Waiting状态（需被notify唤醒）</span><br>                    System.out.println(<span class="hljs-string">&quot;等待线程被唤醒&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;等待线程被中断&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;waitingThread&quot;</span>);<br><br>        waitingThread.start();<br>        <span class="hljs-comment">// 确保线程进入Waiting状态</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">// 主线程唤醒等待线程</span><br>        <span class="hljs-keyword">synchronized</span> (waitLock) &#123;<br>            waitLock.notify(); <span class="hljs-comment">// 唤醒后，waitingThread会先进入Blocked（抢锁），再进入Runnable</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createTimedWaitingThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">timedWaitingThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;timedWaitingThread&quot;</span>);<br><br>        timedWaitingThread.start();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//模拟获取共享资源，持有锁后睡5s让另一个线程BLOCKED</span><br>            Thread.sleep(<span class="hljs-number">5000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说就是：</p><ul><li>线程创建后进入NEW状态</li><li>调用<code>thread.start()</code>后进入RUNNABLE状态，此时还需要等待OS的资源分配，例如CPU执行权。只不过JVM中把有CPU执行权和无CPU执行权统一都叫做RUNNABLE，没有在进行细分，只要在JVM中执行的都叫做RUNNABLE</li><li>线程抢锁但是没有抢到的为BLOCKED状态</li><li>线程抢到了锁，但是通过调用<code>Object.wait() / Thread.join() / LockSupport.park()</code> 来释放锁并主动进入WAITING态等待被唤醒，唤醒后不代表立刻执行，还是需要抢锁，因为可能有多个线程同时竞争</li><li>线程也可以通过调用 <code>Thread.sleep() / Thread.jon(time) / Object.wait(time) / LockSupport.parkNanos() / LockSupport.parkUntil()</code> 进入超时等待，时间到了会退出TIMED_WAITING，超时后自动唤醒，同样需要重新竞争锁才能继续执行</li><li>线程执行完所有逻辑或是抛出异常后自动进入TERMINATED状态</li></ul><h1 id="0806"><a href="#0806" class="headerlink" title="0806"></a>0806</h1><h2 id="pnpm-和-npm-区别"><a href="#pnpm-和-npm-区别" class="headerlink" title="pnpm 和 npm 区别"></a>pnpm 和 npm 区别</h2><p>核心区别在于二者的依赖存储方式不同</p><ul><li>npm 采用 “扁平化 node_modules”，可能导致依赖版本混乱（同一依赖的不同版本可能被提升）。</li><li>pnpm 采用 “内容可寻址存储”，通过硬链接和符号链接管理依赖，相同依赖只存一份，节省磁盘空间，且安装速度更快。</li></ul><h3 id="npm依赖提升"><a href="#npm依赖提升" class="headerlink" title="npm依赖提升"></a>npm依赖提升</h3><p>例如，我们现在的工程引入两个插件：<code>toolA</code>和<code>toolB</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;toolA&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;toolB&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>toolA:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;toolA&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;lodash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.0&quot;</span>  <span class="hljs-comment">// 依赖4.x版本</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>toolB:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;toolB&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;lodash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.10.0&quot;</span>  <span class="hljs-comment">// 依赖3.x版本</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>当执行<code>npm install</code>后，npm 会尝试扁平化依赖：</p><ul><li>由于<code>toolA</code>和<code>toolB</code>依赖<code>lodash</code>的不同版本，npm 会选择其中一个版本提升到顶层（假设是<code>lodash@4.17.0</code>，因为版本更新）；</li><li>另一个版本（<code>lodash@3.10.0</code>）则保留在<code>toolB</code>自己的<code>node_modules</code>中（因为<code>toolB</code>明确依赖 3.x）。</li></ul><p>所以最终的目录结构如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">my-<span class="hljs-keyword">project</span>/<br>├── node_modules/<br>│   ├── toolA/                <span class="hljs-comment"># 依赖lodash@4.x</span><br>│   ├── toolB/                <span class="hljs-comment"># 依赖lodash@3.x</span><br>│   │   └── node_modules/<br>│   │       └── lodash/       <span class="hljs-comment"># 实际安装的3.10.0版本</span><br>│   └── lodash/               <span class="hljs-comment"># 被提升到顶层的4.17.0版本</span><br>└── package.json<br></code></pre></td></tr></table></figure><p>如果toolA和toolB都定义了<code>lodash</code>指定版本，那么都不会有问题</p><p>但是如果tooB忘记定义了，此时，<code>toolB</code>引用<code>lodash</code>时，npm 会默认去找顶层的<code>lodash@4.17.0</code>，但<code>4.x</code>中可能没有toolB依赖的代码版本（比如依赖的方法被删除了），执行的时候就会报错</p><p>因此如果使用 npm 时存在<strong>不同包依赖同一依赖的不同版本</strong>，则会导致：</p><ul><li>若包未正确声明依赖，可能错误引用顶层的 “不兼容版本”；</li><li>依赖提升的不确定性可能导致部分包被迫使用非预期版本，引发兼容性问题。</li></ul><h3 id="pnpm符号连接"><a href="#pnpm符号连接" class="headerlink" title="pnpm符号连接"></a>pnpm符号连接</h3><p>pnpm不采用依赖提升而是采用符号链接可以很好地解决上面的问题，如果采用 pnpm 那么最终的目录结构如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cmake">my-<span class="hljs-keyword">project</span>/<br>├── node_modules/<br>│   ├── toolA -&gt; .pnpm/toolA@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>/node_modules/toolA  <span class="hljs-comment"># 符号链接</span><br>│   ├── toolB -&gt; .pnpm/toolB@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>/node_modules/toolB  <span class="hljs-comment"># 符号链接</span><br>│   └── .pnpm/  <span class="hljs-comment"># pnpm 内部管理的依赖存储区</span><br>│       ├── toolA@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>/<br>│       │   └── node_modules/<br>│       │       ├── toolA/  <span class="hljs-comment"># 实际的 toolA 代码</span><br>│       │       └── lodash -&gt; ../../lodash@<span class="hljs-number">4.17</span>.<span class="hljs-number">0</span>/  <span class="hljs-comment"># 指向 4.x 版本</span><br>│       ├── toolB@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>/<br>│       │   └── node_modules/<br>│       │       ├── toolB/  <span class="hljs-comment"># 实际的 toolB 代码</span><br>│       │       └── lodash -&gt; ../../lodash@<span class="hljs-number">3.10</span>.<span class="hljs-number">0</span>/  <span class="hljs-comment"># 指向 3.x 版本</span><br>│       ├── lodash@<span class="hljs-number">4.17</span>.<span class="hljs-number">0</span>/  <span class="hljs-comment"># 全局存储的 4.x 版本（硬链接）</span><br>│       └── lodash@<span class="hljs-number">3.10</span>.<span class="hljs-number">0</span>/  <span class="hljs-comment"># 全局存储的 3.x 版本（硬链接）</span><br></code></pre></td></tr></table></figure><p>还是上面出现问题的场景，如果 toolB 忘记在依赖中定义 lodash，那么 toolB 中的代码 <code>require(&#39;lodash&#39;)</code> 会直接失败（找不到模块），而不是像 npm 那样 “向上查找并意外引用顶层版本”。这强制开发者必须显式声明依赖，避免隐藏的版本问题。</p><h1 id="0808"><a href="#0808" class="headerlink" title="0808"></a>0808</h1><h2 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h2><p><code>peerDependencies</code> 是 <code>package.json</code> 中的一个字段，用于声明当前包（通常是插件、工具库）与宿主环境（使用该包的项目）中其他依赖的<strong>兼容版本要求</strong>。</p><p>它的核心作用是：</p><ul><li>告诉宿主项目：“我需要你提供这些依赖，且版本必须符合我的要求”</li><li>避免依赖重复安装（例如：React 插件不需要自己安装 React，而是使用宿主项目已有的 React）</li><li>确保兼容性（例如：插件明确要求 React ≥17，避免宿主使用 React 16 导致冲突）</li></ul><h1 id="0811"><a href="#0811" class="headerlink" title="0811"></a>0811</h1><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>是一个用来创建锁和其他同步工具类的<strong>基本线程阻塞原语</strong></p><h3 id="和wait-x2F-notify对比"><a href="#和wait-x2F-notify对比" class="headerlink" title="和wait&#x2F;notify对比"></a>和wait&#x2F;notify对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitNotify</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">waitThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>            lock.wait(); <span class="hljs-comment">//释放锁并进入阻塞态</span><br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>         &#125;<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;waitThread get notified&quot;</span>);<br>   &#125;, <span class="hljs-string">&quot;waitThread&quot;</span>);<br><br>   waitThread.start();<br><br>   <span class="hljs-comment">//确保waitThread先拿到锁</span><br>   Thread.sleep(<span class="hljs-number">500L</span>);<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">notifyThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;notifyThread notify waitThread&quot;</span>);<br>      <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>         lock.notify();<br>      &#125;<br>   &#125;, <span class="hljs-string">&quot;notifyThread&quot;</span>);<br>   notifyThread.start();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>换成 LockSupport</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUnpark</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">parkThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;parkThread blocked by park&quot;</span>);<br><br>      LockSupport.park();<br><br>      System.out.println(<span class="hljs-string">&quot;parkThread notified by unparkThread&quot;</span>);<br>   &#125;, <span class="hljs-string">&quot;parkThread&quot;</span>);<br>   parkThread.start();<br><br>   <span class="hljs-comment">//确保parkThread先拿到锁</span><br>   Thread.sleep(<span class="hljs-number">500L</span>);<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">unparkThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>      System.out.println(<span class="hljs-string">&quot;unparkThread notify parkThread&quot;</span>);<br><br>      LockSupport.unpark(parkThread);<br><br>   &#125;, <span class="hljs-string">&quot;unparkThread&quot;</span>);<br>   unparkThread.start();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现 LockSupport 不像是 wait&#x2F;notify 那样必须要在 synchronized 下才能使用</p><p>此外，LockSupport 相比于  wait&#x2F;notify ，还解决了顺序问题，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unorderedWaitNotify</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">waitThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-comment">//模拟先notify再wait</span><br>      <span class="hljs-keyword">try</span> &#123;<br>         Thread.sleep(<span class="hljs-number">2000L</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>      &#125;<br>      <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>            lock.wait(); <span class="hljs-comment">//释放锁并进入阻塞态</span><br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>         &#125;<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;waitThread get notified&quot;</span>);<br>   &#125;, <span class="hljs-string">&quot;waitThread&quot;</span>);<br>   waitThread.start();<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">notifyThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;notifyThread notify waitThread&quot;</span>);<br>      <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>         lock.notify();<br>      &#125;<br>   &#125;, <span class="hljs-string">&quot;notifyThread&quot;</span>);<br>   notifyThread.start();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码，我们模拟先 notify 再 wait，结果就是 waitThread 永远地阻塞住了，程序无法正常结束</p><p>但是如果换用 LockSupport</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unorderedParkUnpark</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">parkThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-comment">//先unpark再park</span><br>      <span class="hljs-keyword">try</span> &#123;<br>         Thread.sleep(<span class="hljs-number">2000L</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;parkThread blocked by park&quot;</span>);<br><br>      LockSupport.park();<br><br>      System.out.println(<span class="hljs-string">&quot;parkThread notified by unparkThread&quot;</span>);<br>   &#125;, <span class="hljs-string">&quot;parkThread&quot;</span>);<br>   parkThread.start();<br><br><br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">unparkThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>      System.out.println(<span class="hljs-string">&quot;unparkThread notify parkThread&quot;</span>);<br><br>      LockSupport.unpark(parkThread);<br><br>   &#125;, <span class="hljs-string">&quot;unparkThread&quot;</span>);<br>   unparkThread.start();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们先 unpark 再 park，结果可以发现虽然 unparkThread 先执行了 unpark 尝试唤醒，但是此时 parkThread 还在睡，还没 park 操作。但是不影响，2s 后 parkThread 调用 park 后立刻就被唤醒了</p><p>这也是 <code>park/unpark</code> 和 <code>wait/notify</code> 的另一个核心区别：不论调用顺序，只要成对出现，必然可以唤醒线程</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过 LockSupport 的 <code>park/unpark</code> 和 <code>wait/notify</code> 的对比，我们可以简单总结：他们都可以实现线程的等待和唤醒。但是区别在于：</p><ul><li><code>park/unpark</code> 在任何地方都能用，而 <code>wait/notify</code> 只能在 synchronized 下使用</li><li><code>park/unpark</code> 调用顺序无关，只要成对出现必然可以唤醒等待的线程，而 <code>wait/notify</code> 必须按顺序，先 wait 然后 notify，如果先 notify 再 wait 会导致后来 wait 的线程一直无法被唤醒</li></ul><h1 id="0812"><a href="#0812" class="headerlink" title="0812"></a>0812</h1><h2 id="GSON忽略指定字段"><a href="#GSON忽略指定字段" class="headerlink" title="GSON忽略指定字段"></a>GSON忽略指定字段</h2><p><a href="https://trevorlink.github.io/2025/08/13/Gson-%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5/">详见</a></p><h2 id="偶现请求参数丢失"><a href="#偶现请求参数丢失" class="headerlink" title="偶现请求参数丢失"></a>偶现请求参数丢失</h2><p>结合网上相同案例排查，可能是在异步操作前，将RequestContextHolder丢入线程中导致的，详见整理后的博客</p><h1 id="0818"><a href="#0818" class="headerlink" title="0818"></a>0818</h1><h2 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h2><h3 id="如何做到的不可变性"><a href="#如何做到的不可变性" class="headerlink" title="如何做到的不可变性"></a>如何做到的不可变性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>&#125;<br></code></pre></td></tr></table></figure><p>直接看源码，源码中定义了  private 和 final 这两点需要重点关注</p><ul><li><code>private</code>：外部无法直接访问该数组，避免了直接修改，而且<code>String</code>类没有提供任何修改数组内部值的方法</li><li><code>final</code>：数组引用 value 一旦初始化后，无法指向新的数组对象</li></ul><p>如果只有 final 意味着数组本身的元素理论上可被修改，但是在 private 的作用下以及 String 类并未暴露 public 的方法提供修改 value 数组的方式，所以二者共同作用，限制了 String 类不可变</p><p>String 类暴露的任何看似修改字符串的操作，例如 <code>concat</code> <code>toUpperCase</code> 实际上都是创建了新的 String 对象，而不是在原先的对象上进行了修改</p><h3 id="为什么需要不可变"><a href="#为什么需要不可变" class="headerlink" title="为什么需要不可变"></a>为什么需要不可变</h3><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>JVM为了节省内存设计了字符串常量池，相同字面值内容的字符串，都会引用到字符串常量池中相同的那一份（只会存一份）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;foo&quot;</span>; <span class="hljs-comment">//char[3]@509</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;foo&quot;</span>; <span class="hljs-comment">//char[3]@509</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(s1); <span class="hljs-comment">//char[3]@509</span><br></code></pre></td></tr></table></figure><p>若字符串可变，修改 <code>s1</code> 会导致相同字面值的 <code>s2</code> 的值也被意外修改，破坏常量池的设计初衷</p><p><strong>不可变性保证了字符串常量池中的对象可以安全共享</strong></p><h4 id="为了线程安全"><a href="#为了线程安全" class="headerlink" title="为了线程安全"></a>为了线程安全</h4><p>常量因为不可变，天生线程安全，不存在并发问题</p><h4 id="为了哈希表哈希计算可靠"><a href="#为了哈希表哈希计算可靠" class="headerlink" title="为了哈希表哈希计算可靠"></a>为了哈希表哈希计算可靠</h4><p>String 常常被用作 HashMap 的Key，而 HashMap 的高效查询就是依赖其 key 的 hashCode</p><p>以 String 作为 key 保证了 key 不可变，在对象生命周期内的每一次 hash 索引都是准确稳定的</p><h3 id="可变字符串"><a href="#可变字符串" class="headerlink" title="可变字符串"></a>可变字符串</h3><p>就是我们常说的 StringBuffer 和 StringBuilder</p><p>如果是频繁修改拼接字符串，String 的不可变性会导致产生很多临时的新的 String 对象</p><p>而可变字符串本质上会直接修改 value 数组的内容，不会产生临时 String 对象</p><h1 id="0819"><a href="#0819" class="headerlink" title="0819"></a>0819</h1><h2 id="fastjson反序列化误判字段"><a href="#fastjson反序列化误判字段" class="headerlink" title="fastjson反序列化误判字段"></a>fastjson反序列化误判字段</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>     <br>     <span class="hljs-comment">//省略 getter setter</span><br>     <span class="hljs-keyword">private</span> String code;<br>     <br>     <span class="hljs-keyword">private</span> String name;<br>     <br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isIllegal</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-comment">//根据自身属性值判断数据是否非法</span><br>     &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>前端拿到响应的时候，结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>     <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>     <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;bar&quot;</span>,<br>     <span class="hljs-string">&quot;illegal&quot;</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>当 Controller 返回时，Spring MVC 并不会直接将 Java 对象返回给前端，而是需要经过<strong>序列化处理</strong>（将 Java 对象转换为 JSON 字符串），这个过程由 JSON 序列化器（如 FastJSON、Jackson 等）完成。</p><p>序列化器的工作逻辑：<strong>扫描对象中的所有 getter 方法，根据方法名推断属性名，并将方法返回值作为属性值写入 JSON</strong>。</p><p>对于<code>Foo</code>类中的<code>isIllegal()</code>方法：</p><ul><li>序列化器会按照 “<code>isXxx()</code> → 属性名为<code>xxx</code>” 的规则，推断存在一个名为<code>illegal</code>的属性。</li><li>调用<code>isIllegal()</code>方法得到返回值（<code>false</code>），于是在序列化后的 JSON 中添加<code>&quot;illegal&quot;: false</code>字段。</li></ul><p>因此，可以得出最佳实践：返回给前端的响应体以及代码中任何的响应体，在设计方法的时候需要考虑到 Java Bean 的规范，bool 类型的变量，就叫做 xxx， getter 叫做 isXxx；而任何非属性的 getter&#x2F;setter，都不要以 <code>is</code> 开头，否则会导致在序列化的时候出现误判，多出一个属性的情况</p><h1 id="0820"><a href="#0820" class="headerlink" title="0820"></a>0820</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>见博客笔记整理</p><h1 id="0821"><a href="#0821" class="headerlink" title="0821"></a>0821</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>修饰变量时，变量无法被赋值，具体表现为：</p><ul><li>基础数据类型：无法改变值</li><li>引用数据类型：无法修改引用，但是可以修改引用对象的属性值</li></ul><p>修饰方法时，方法无法被重写，例如 <code>Thread.isAlive()</code></p><p>修饰类时，类无法被继承，例如 <code>String</code> 类</p><h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><p>final 修饰类常常用于设计不可变类</p><p>不可变类是指<strong>实例创建后，其内部状态（属性值）不能被修改</strong>的类（如 <code>String</code>、<code>Integer</code>）。其核心是 “状态不可变”，而非 “是否被 final 修饰”</p><p>final class 不一定是 不可变类</p><p>不可变类 也不一定是 final class</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>开发中常见的设计模式：</p><p>单例：Calendar，配置文件映射类</p><p>模板方法：AQS</p><p>策略模式</p><p>观察者模式</p><p>工厂模式</p><p>装饰器模式</p><h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><h3 id="导论-1"><a href="#导论-1" class="headerlink" title="导论"></a>导论</h3><p>这是一个接口，没有定义任何的接口方法，意味着这个接口仅仅是起到了标记的作用</p><p>那么什么时候会需要使用到这个接口呢？这就需要提到序列化和反序列化了</p><p>序列化是指我们将程序中的 Java 对象转换为字节流的这个过程，比如写文件，发请求</p><p>反序列化则相反，是指字节流映射回 Java 实体对象的过程</p><p>很常见的业务场景就是：在将数据导出到文件（例如 Excel 文件）的时候，就是序列化；将本地文件导入到系统，就是对应文件到 JVM 内存的反序列化过程</p><h3 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h3><p>简单粗暴的理解，源码中就是有这个标记的判断，额米有就是会报错</p><p>不管是用成熟的写文件框架（例如 EasyExcel ）还是发请求，本质上都会调用 JDK 的 <code>OutputStream.writeObject0()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断对象是否为字符串类型，如果是，则调用 writeString 方法进行序列化</span><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) &#123;<br>    writeString((String) obj, unshared);<br>&#125;<br><span class="hljs-comment">// 判断对象是否为数组类型，如果是，则调用 writeArray 方法进行序列化</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cl.isArray()) &#123;<br>    writeArray(obj, desc, unshared);<br>&#125;<br><span class="hljs-comment">// 判断对象是否为枚举类型，如果是，则调用 writeEnum 方法进行序列化</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Enum) &#123;<br>    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);<br>&#125;<br><span class="hljs-comment">// 判断对象是否为可序列化类型，如果是，则调用 writeOrdinaryObject 方法进行序列化</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Serializable) &#123;<br>    writeOrdinaryObject(obj, desc, unshared);<br>&#125;<br><span class="hljs-comment">// 如果对象不能被序列化，则抛出 NotSerializableException 异常</span><br><span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">if</span> (extendedDebugInfo) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotSerializableException</span>(<br>             cl.getName() + <span class="hljs-string">&quot;\n&quot;</span> + debugInfoStack.toString());<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotSerializableException</span>(cl.getName());<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此如果有序列化对象的需求，需要在对象定义时实现<code>java.io.Serializable</code>这个接口</p><h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p>在阅读JDK的一些源码的时候也经常会看到，只要是实现了<code>Serializable</code>接口的对象，都会定义一串”意义不明”的随机UID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">4982264981922014374L</span>;<br>     <span class="hljs-comment">//AbstractQueuedSynchronizer 实现了 java.io.Serializabel</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个看似 “意义不明” 的UID实际上在反序列化的过程中起到关键作用</p><p>JVM会在反序列化时，比较字节流中定义的 <code>serialVersionUID</code> 和代码中目前数据结构里的是否相同，如果不同，会抛出<code>InvalidClassException</code>异常</p><p>但是如果我们没有显式定义呢？JVM 会在序列化和反序列化时自动根据对象的数据结构，生成随机值（类似 hashCode）只要对象的结构没有变，这个随机值就不会变。因此如果导出到文件时数据结构和现在导入读取时的结构保证统一，就不会报错</p><p><strong>但是有的时候我们往往需要保证当前的数据结构修改更新时，也能保证程序读取时不出错</strong></p><p>这种情况下，显式定义<code>serialVersionUID</code>就显得很重要了：我们可以修改当前程序的数据结构，保证 serialVersionUID 的值不改动，这样读取时 JVM 字节流比对 serialVersionUID 还是以前的值，保证读取流程不出错</p><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><code>java.io.Serializable</code> 接口是 JVM 在序列化和反序列化时底层执行的重要标识，当我们有序列化和反序列化的业务需求时，需要在程序数据结构上实现这个接口</p><p>对于 <code>java.io.Serializable</code> 的所有实现类，推荐显式定义 serialVersionUID 字段来固定版本号，以增强数据结构的兼容性和版本扩展性，避免反序列化时数据因 Java 映射类的结构变化而导致的反序列化失败</p><h1 id="0822"><a href="#0822" class="headerlink" title="0822"></a>0822</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>已整理成博客</p><h1 id="0825"><a href="#0825" class="headerlink" title="0825"></a>0825</h1><h2 id="Component-和-Bean"><a href="#Component-和-Bean" class="headerlink" title="@Component 和 @Bean"></a>@Component 和 @Bean</h2><p>在Spring的应用中都很常见到这两个注解</p><p>这两个注解的核心作用都是将对象（Bean）纳入 Spring 容器管理</p><p>但它们的<strong>设计初衷、使用场景、底层逻辑</strong>有显著区别</p><p>理解二者的差异，是掌握 Spring 依赖注入（DI）和控制反转（IoC）的关键</p><h3 id="作用对象与作用方式"><a href="#作用对象与作用方式" class="headerlink" title="作用对象与作用方式"></a>作用对象与作用方式</h3><p>@Component：类级别的自动注册</p><p><code>@Component</code> 是 “声明式” 注解，作用是告诉 Spring：<strong>“这个类需要被你管理，请自动创建它的实例并放入容器”</strong></p><p>Spring会在启动的时候使用默认扫描策略或是<code>@ComponentScan</code>定义的策略（如果有）来通过反射扫描所有标注了<code>@Component</code>以及类似衍生注解的类，实例化这些类，并自动注入到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 标注在类上，Spring 自动扫描后创建 userService Bean</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-comment">// 类的业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;获取用户信息&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Spring Boot 启动类（默认扫描当前包及子包下的 @Component 类）</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(Application.class, args);<br>        <span class="hljs-comment">// 从容器中获取 UserService 实例（已自动注册）</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> context.getBean(UserService.class);<br>        userService.getUserInfo(); <span class="hljs-comment">// 输出：获取用户信息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Bean</code> 是方法级别注解，只能做用在方法上</p><p><code>@Bean</code> 是 “编程式” 注解，作用是告诉 Spring：<strong>“这个方法的返回值需要被你管理，请将其作为 Bean 放入容器”</strong>。</p><p><code>@Bean</code> 必须定义在 <strong><code>@Configuration</code> 标注的配置类</strong> 或 <strong><code>@Component</code> 标注的类</strong> 中（推荐前者，因为 <code>@Configuration</code> 会通过 CGLIB 增强，保证 Bean 的单例性），用于手动控制 Bean 的创建逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第三方类（无法修改源码，不能用 @Component 标注）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThirdPartyHttpClient</span> &#123;<br>    <span class="hljs-keyword">private</span> String baseUrl;<br>    <span class="hljs-comment">// 有参构造，初始化逻辑复杂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThirdPartyHttpClient</span><span class="hljs-params">(String baseUrl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.baseUrl = baseUrl;<br>        <span class="hljs-comment">// 可能还有其他复杂初始化（如连接池配置、超时设置）</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRequest</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;向 &quot;</span> + baseUrl + <span class="hljs-string">&quot; 发送请求&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 配置类：用 @Bean 手动注册第三方类的 Bean</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanConfig</span> &#123;<br>    <span class="hljs-comment">// 方法返回值作为 Bean，Bean 名称默认是方法名 &quot;httpClient&quot;</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ThirdPartyHttpClient <span class="hljs-title function_">httpClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 手动控制初始化逻辑：传入参数、配置细节</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdPartyHttpClient</span>(<span class="hljs-string">&quot;https://api.example.com&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试：从容器中获取 @Bean 注册的 Bean</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(Application.class, args);<br>        <span class="hljs-type">ThirdPartyHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> context.getBean(ThirdPartyHttpClient.class);<br>        httpClient.sendRequest(); <span class="hljs-comment">// 输出：向 https://api.example.com 发送请求</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用场景最佳实践"><a href="#使用场景最佳实践" class="headerlink" title="使用场景最佳实践"></a>使用场景最佳实践</h3><p><code>@Component</code> 与 <code>@Bean</code> 二者从设计上的初衷就不同</p><p><strong>@Component：适用于 “自定义类” 的自动注册</strong>，当开发的是<strong>自己项目中的类</strong>（如 <code>UserService</code>、<code>OrderRepository</code>），且这些类的<strong>初始化逻辑简单</strong>（无复杂参数、无需调用第三方 API）时，使用 <code>@Component</code>（或其衍生注解）+ 组件扫描，能让 Spring 自动完成 Bean 注册，减少手动配置代码</p><p>而 <strong>@Bean：适用于 “非自定义类” 或 “复杂初始化” 的手动注册</strong>，常常用在：</p><ol><li><strong>第三方类的 Bean 注册</strong>：因为我们无法修改第三方库的源码（如 <code>RedisTemplate</code>、<code>HttpClient</code>、<code>MyBatis</code> 的 <code>SqlSessionFactory</code>），不能在这些类上标注 <code>@Component</code>，此时必须通过 <code>@Bean</code> 手动创建实例并注册到Spring容器中使用</li><li><strong>复杂初始化逻辑</strong>：即使是自定义类，若初始化需要复杂逻辑（如动态参数、条件判断、调用其他服务获取配置），<code>@Component</code> 无法满足（只能依赖默认构造或 <code>@Autowired</code> 注入），而 <code>@Bean</code> 可在方法内编写任意逻辑。</li></ol><h3 id="补充-自定义类复杂初始化的Bean注入对比"><a href="#补充-自定义类复杂初始化的Bean注入对比" class="headerlink" title="补充: 自定义类复杂初始化的Bean注入对比"></a>补充: 自定义类复杂初始化的Bean注入对比</h3><p>这里针对【如果是自定义类复杂初始化逻辑】的情况，需要使用<code>@Bean</code>的方式，下面是代码案例</p><h4 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h4><p>我们以 <strong>“自定义支付客户端”</strong> 为例：</p><p>假设现在这个自定义支付客户端在初始化的时候需要根据环境（开发 &#x2F; 生产）动态选择支付网关地址、调用配置中心获取密钥、初始化连接池，且需支持 “是否启用沙箱模式” 的条件判断 —— 这些复杂逻辑用 <code>@Component</code> 难以实现，而 <code>@Bean</code> 可优雅应对</p><ol><li><strong>动态参数</strong>：支付网关地址（开发环境 <code>dev-url</code> &#x2F; 生产环境 <code>prod-url</code>）从配置文件读取，而非硬编码</li><li><strong>条件判断</strong>：若配置 <code>pay.sandbox.enable=true</code>，则启用沙箱模式（跳过真实签名校验）；否则启用生产模式（严格校验）</li><li><strong>依赖外部服务</strong>：支付密钥需从 “配置中心服务”动态获取，而非直接写在配置文件</li><li><strong>资源初始化</strong>：初始化支付连接池（设置最大连接数、超时时间），确保客户端性能</li></ol><p>假设我们的配置文件内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 激活的环境（dev/prod）</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br><br><span class="hljs-comment"># 支付客户端配置</span><br><span class="hljs-attr">pay:</span><br>  <span class="hljs-comment"># 网关地址（分环境）</span><br>  <span class="hljs-attr">gateway:</span><br>    <span class="hljs-attr">dev-url:</span> <span class="hljs-string">https://dev-pay-gateway.example.com</span><br>    <span class="hljs-attr">prod-url:</span> <span class="hljs-string">https://prod-pay-gateway.example.com</span><br>  <span class="hljs-comment"># 沙箱模式配置（开发环境启用，生产环境禁用）</span><br>  <span class="hljs-attr">sandbox:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-string">$&#123;spring.profiles.active</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;dev&#x27;</span> <span class="hljs-string">?</span> <span class="hljs-attr">true :</span> <span class="hljs-literal">false</span><span class="hljs-string">&#125;</span><br>  <span class="hljs-comment"># 连接池配置</span><br>  <span class="hljs-attr">connection:</span><br>    <span class="hljs-attr">max:</span> <span class="hljs-number">10</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><h4 id="Bean实现"><a href="#Bean实现" class="headerlink" title="@Bean实现"></a>@Bean实现</h4><h5 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayClient</span> &#123;<br>    <span class="hljs-comment">// 1. 动态参数：支付网关地址（开发/生产环境不同）</span><br>    <span class="hljs-keyword">private</span> String gatewayUrl;<br>    <span class="hljs-comment">// 2. 条件参数：是否启用沙箱模式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> sandboxEnable;<br>    <span class="hljs-comment">// 3. 外部依赖：支付密钥（从配置中心获取）</span><br>    <span class="hljs-keyword">private</span> String apiKey;<br>    <span class="hljs-comment">// 4. 资源初始化：连接池配置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxConnections; <span class="hljs-comment">// 最大连接数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> connectTimeout; <span class="hljs-comment">// 连接超时时间（毫秒）</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务方法：发起支付请求</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doPay</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> &#123;<br>        <span class="hljs-comment">// 根据沙箱模式判断是否跳过签名校验</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> sandboxEnable ? <span class="hljs-string">&quot;sandbox-sign&quot;</span> : generateRealSign(orderId, amount);<br>        <span class="hljs-keyword">return</span> String.format(<br>            <span class="hljs-string">&quot;支付请求已发送 -&gt; 网关：%s，订单号：%s，金额：%s，沙箱模式：%s，签名：%s&quot;</span>,<br>            gatewayUrl, orderId, amount, sandboxEnable, sign<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">// 模拟生产环境的真实签名逻辑</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">generateRealSign</span><span class="hljs-params">(String orderId, BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;real-sign-&quot;</span> + orderId + <span class="hljs-string">&quot;-&quot;</span> + amount + <span class="hljs-string">&quot;-&quot;</span> + apiKey;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="配置服务Service"><a href="#配置服务Service" class="headerlink" title="配置服务Service"></a>配置服务Service</h5><p>这个配置服务同样注入到Spring容器中，我们的支付类在实例化时、注入之前需要调用这个配置服务设置字段值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟外部配置中心服务（非自定义类/第三方服务）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigCenterService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据key从配置中心获取配置值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConfig</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 模拟配置中心返回数据（实际可能是HTTP调用、Nacos/Apollo获取）</span><br>        <span class="hljs-keyword">switch</span> (key) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pay.api.key&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;prod_8a7b6c5d4e3f2a1b&quot;</span>; <span class="hljs-comment">// 生产环境密钥</span><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;未知配置key：&quot;</span> + key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="实例化逻辑"><a href="#实例化逻辑" class="headerlink" title="实例化逻辑"></a>实例化逻辑</h5><p>在配置类中，我们使用 <code>@Bean</code> 实例化我们的自定义支付类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 支付客户端配置类：用<span class="hljs-doctag">@Bean</span>处理复杂初始化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayClientConfig</span> &#123;<br>    <span class="hljs-comment">// 1. 注入外部依赖：配置中心服务（用于获取密钥）</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ConfigCenterService configCenterService;<br><br>    <span class="hljs-comment">// 2. 读取动态参数（从application.yml/properties配置文件）</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.gateway.dev-url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String devGatewayUrl; <span class="hljs-comment">// 开发环境网关</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.gateway.prod-url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String prodGatewayUrl; <span class="hljs-comment">// 生产环境网关</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;spring.profiles.active&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String activeEnv; <span class="hljs-comment">// 当前激活的环境（dev/prod）</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.sandbox.enable:false&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> sandboxEnable; <span class="hljs-comment">// 是否启用沙箱模式（默认false）</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.connection.max:5&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxConnections; <span class="hljs-comment">// 连接池最大连接数（默认5）</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;pay.connection.timeout:3000&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> connectTimeout; <span class="hljs-comment">// 连接超时时间（默认3000ms）</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3. 用<span class="hljs-doctag">@Bean</span>创建PayClient实例：包含所有复杂初始化逻辑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PayClient <span class="hljs-title function_">payClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 步骤1：动态选择支付网关地址（根据当前环境）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">gatewayUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dev&quot;</span>.equals(activeEnv) ? devGatewayUrl : prodGatewayUrl;<br>        System.out.println(<span class="hljs-string">&quot;当前环境：&quot;</span> + activeEnv + <span class="hljs-string">&quot;，选择网关：&quot;</span> + gatewayUrl);<br><br>        <span class="hljs-comment">// 步骤2：调用外部服务（配置中心）获取支付密钥</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">apiKey</span> <span class="hljs-operator">=</span> configCenterService.getConfig(<span class="hljs-string">&quot;pay.api.key&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;从配置中心获取密钥：&quot;</span> + apiKey);<br><br>        <span class="hljs-comment">// 步骤3：条件判断（是否启用沙箱模式）</span><br>        System.out.println(<span class="hljs-string">&quot;沙箱模式启用状态：&quot;</span> + sandboxEnable);<br><br>        <span class="hljs-comment">// 步骤4：初始化PayClient实例（设置所有参数+资源）</span><br>        <span class="hljs-type">PayClient</span> <span class="hljs-variable">payClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PayClient</span>();<br>        payClient.setGatewayUrl(gatewayUrl);<br>        payClient.setSandboxEnable(sandboxEnable);<br>        payClient.setApiKey(apiKey);<br>        payClient.setMaxConnections(maxConnections);<br>        payClient.setConnectTimeout(connectTimeout);<br><br>        <span class="hljs-comment">// 步骤5：额外资源初始化（如连接池预热）</span><br>        initConnectionPool(payClient);<br><br>        <span class="hljs-keyword">return</span> payClient;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 辅助方法：初始化支付连接池（模拟复杂资源初始化）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initConnectionPool</span><span class="hljs-params">(PayClient payClient)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;初始化支付连接池：最大连接数=&quot;</span> + payClient.getMaxConnections() <br>            + <span class="hljs-string">&quot;，超时时间=&quot;</span> + payClient.getConnectTimeout() + <span class="hljs-string">&quot;ms&quot;</span>);<br>        <span class="hljs-comment">// 实际场景：可能初始化HttpClient连接池、数据库连接池等</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Component实现"><a href="#Component实现" class="headerlink" title="@Component实现"></a>@Component实现</h4><p>若强行用 <code>@Component</code> 标注 <code>PayClient</code>，会面临以下不可解决的问题：</p><ol><li><strong>动态参数无法灵活选择</strong>：<br><code>@Component</code> 只能通过 <code>@Value</code> 直接注入单一值（如 <code>@Value(&quot;$&#123;pay.gateway.dev-url&#125;&quot;)</code>），无法根据 <code>activeEnv</code> 的值动态切换 <code>dev-url</code>&#x2F;<code>prod-url</code>。</li><li><strong>条件判断无法嵌入</strong>：<br><code>@Component</code> 无法在初始化时添加 “是否启用沙箱模式” 的逻辑，只能在业务方法中判断，导致客户端实例创建时就携带无效配置（如生产环境仍加载沙箱参数）。</li><li><strong>依赖外部服务获取配置困难</strong>：<br>若用 <code>@Component</code>，为了实现调用配置中心服务，我们需在 <code>PayClient</code> 中 <code>@Autowired</code> 配置中心服务，再通过 <code>@PostConstruct</code> 初始化密钥：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayClient</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ConfigCenterService configCenterService;<br>    <span class="hljs-keyword">private</span> String apiKey;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.apiKey = configCenterService.getConfig(<span class="hljs-string">&quot;pay.api.key&quot;</span>);<br>        <span class="hljs-comment">// 但动态网关、条件判断仍无法实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><code>@Bean</code>方式注入的Bean，本质上是Spring反射扫描并调用我们编写的方法后将方法的返回值作为bean注入的</p><p>相比于 <code>@Component</code>,<code>@Bean</code>更适合：</p><ul><li>第三方包里不会自动注入的类</li><li>自定义的类、但是这个类由于业务关系，初始化的时候依赖比较多</li></ul><p>虽然实现和配置较为复杂（因为还需要编写一个额外的<code>@Configuration</code>的配置类供Spring扫描）但更灵活</p><p>（已整理为笔记）</p><h1 id="0826"><a href="#0826" class="headerlink" title="0826"></a>0826</h1><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>整理为博客</p><h1 id="0829"><a href="#0829" class="headerlink" title="0829"></a>0829</h1><p>复习单例模式，重新手写，最佳实践：静态内部类（写法简单，无并发问题，性能高）</p><h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载 Overload"></a>重载 Overload</h3><p>在一个类中(或者父类和子类之间)，相同方法名，<strong>必须不同</strong>的参数列表（参数个数，参数类型）和<strong>可选不同</strong>的返回值，可选不同的访问修饰符，会构成方法的重载</p><p>所以判断两个方法是否构成重载的关键依据是<strong>：方法名相同，并且参数列表必须不同</strong>（其中包括参数个数或是不同参数类型的顺序，与参数名称无关）</p><p>例如如下的两段构成了重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(String s1, <span class="hljs-type">int</span> num)</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-type">int</span> num, String s1)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>至于二者的访问修饰符、抛出的异常以及返回值无关，相同或者不同都无所谓</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>子类中，对父类（接口）已有的方法进行重新实现</p><p>发生重写时，<strong>方法名称，参数列表、必须完全相同</strong>，返回值可以</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>对比维度</th><th>重载（Overload）</th><th>重写（Override）</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>同一个类中，方法名相同但参数列表不同的多个方法</td><td>子类中，对父类已有的方法进行重新实现（方法名、参数列表、返回值完全相同）</td></tr><tr><td><strong>作用场景</strong></td><td>同一类内，为相似功能提供不同参数的调用方式</td><td>子类对父类的方法进行扩展或修改（多态的核心）</td></tr><tr><td><strong>方法名</strong></td><td>必须相同</td><td>必须与父类方法名完全相同</td></tr><tr><td><strong>参数列表</strong></td><td>必须不同（参数类型、个数、顺序至少有一个不同）</td><td>必须与父类方法的参数列表完全相同（类型、个数、顺序一致）</td></tr><tr><td><strong>返回值类型</strong></td><td>可以不同（与重载无关）</td><td>必须与父类方法的返回值类型相同（或其子类，即 “协变返回”）</td></tr><tr><td><strong>访问修饰符</strong></td><td>无限制（可任意修改）</td><td>子类方法的访问权限不能低于父类（如父类是<code>protected</code>，子类不能是<code>private</code>）</td></tr><tr><td><strong>异常声明</strong></td><td>无限制</td><td>子类方法不能抛出比父类更多、更宽泛的异常（可减少或缩小）</td></tr><tr><td><strong>调用依据</strong></td><td>编译期根据参数列表确定调用哪个方法（静态绑定）</td><td>运行期根据对象实际类型确定调用哪个方法（动态绑定）</td></tr></tbody></table><h1 id="0831"><a href="#0831" class="headerlink" title="0831"></a>0831</h1><h2 id="ArrayList相关时间复杂度"><a href="#ArrayList相关时间复杂度" class="headerlink" title="ArrayList相关时间复杂度"></a>ArrayList相关时间复杂度</h2><p>查询指定位置元素：O(1)</p><p>新增：</p><ul><li>头插：O(n)</li><li>尾插：<ul><li>不需要扩容：O(1)</li><li>需要扩容：此时会需要把原先的内容复制到新的数组，因此是O(n)</li></ul></li><li>指定位置插入：此位置后面的所有元素需要向后移动一格，O(n)</li></ul><p>删除：</p><ul><li>头删：O(n) 所有元素向前移动一格</li><li>尾删：O(1)</li><li>指定位置删除：此位置后的所有元素需要向前移动一格，O(n)</li></ul><h1 id="Warp-up"><a href="#Warp-up" class="headerlink" title="Warp up"></a>Warp up</h1><p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>技术日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>找工作</tag>
      
      <tag>自我提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK8|AbstractQueuedSynchronizer</title>
    <link href="/2025/07/26/JDK8-AbstractQueuedSynchronizer/"/>
    <url>/2025/07/26/JDK8-AbstractQueuedSynchronizer/</url>
    
    <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/308452402">干货：十分钟带你搞懂 Java AQS 核心设计与实现！</a></p><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>在后端编程领域中，并发是经常需要考虑和处理的问题，一个很常见的业务场景是，在某个业务方法中，会出现多个线程同时需要操作某一个共享变量的情况。但是业务上硬性要求这个共享变量必须线程安全，一次只能由一个线程进行更新。</p><p>这种问题本质上可以抽象为 <strong>共享资源的竞争与同步关系</strong></p><p>在这种情况下，我们必须要指定：</p><ul><li>得到执行权的线程应该如何标记这个共享变量使得别的线程不会再次抢夺</li><li>没有得到执行权的线程应该何去何从。</li></ul><h2 id="问题实现思路"><a href="#问题实现思路" class="headerlink" title="问题实现思路"></a>问题实现思路</h2><p>在进一步介绍 AbstractQueuedSynchronizer 之前，我们可以想象针对上述提到的两个问题，尤其是第二个：<code>没有得到执行权的线程应该何去何从</code>。</p><ul><li>自旋等待：这种方式浪费CPU，实际上CPU还是在执行这个线程，只是没有做任何操作</li><li>线程挂起，等到释放锁的时候唤醒：这种情况也不太好，如果同时挂起等待的线程较多，可能存在<strong>惊群</strong>的问题</li></ul><p>为了高效解决这种大家都会遇到的场景，JDK设计了一个抽象的解决共享资源竞争与同步的框架，AbstractQueuedSynchronizer 应愿而生。</p><h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h2><p>AQS是JDK为了解决在多线程环境下，共享资源的竞争和状态同步关系的框架。</p><p>AQS集同步状态管理、线程阻塞、线程释放以及队列管理的同步框架。</p><p>通过后面的分析我们可以了解到：</p><blockquote><p>AQS的核心思想是当多个线程竞争同一个共享资源的时候，未获得执行权的线程会被构造为一个Node节点丢入到一个 FIFO 的队列中。这个队列是一个双向队列，同时记录前驱和后继，在队列中的线程会保持阻塞直到被队列前一个元素唤醒。队列中只有队首节点有资格被唤醒竞争锁。</p></blockquote><h2 id="关注重点"><a href="#关注重点" class="headerlink" title="关注重点"></a>关注重点</h2><p>对于 AQS 我们需要重点关注：</p><ul><li>内部的状态同步如何实现（状态管理）</li><li>核心FIFO队列的设计（队列管理）</li><li>竞争资源失败时线程的生命周期（线程阻塞）</li><li>共享资源的释放（线程释放）</li></ul><h1 id="同步状态管理"><a href="#同步状态管理" class="headerlink" title="同步状态管理"></a>同步状态管理</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The synchronization state.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br>&#125;<br></code></pre></td></tr></table></figure><p>AQS 内部使用一个 volatile 类型的变量来表示状态，这表示这个状态的更新对所有线程都可见。</p><p>AQS 使用这个变量来标识当前锁的占用情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 尝试以独占模式获取。此方法应查询对象的状态是否允许其以独占模式获取，如果允许，则进行获取。</span><br><span class="hljs-comment">   * 此方法总是由执行获取操作的线程调用。如果此方法报告失败，获取方法可能会将线程排队（如果尚未排队）</span><br><span class="hljs-comment">   * 直到由其他线程释放时通知。这可用于实现 Lock.tryLock() 方法。</span><br><span class="hljs-comment">   * 默认实现会抛出 UnsupportedOperationException。</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 尝试将状态设置为反映在独占模式下释放锁的情况</span><br><span class="hljs-comment">* 此方法总是由执行释放的线程调用</span><br><span class="hljs-comment">* 默认实现会抛出 UnsupportedOperationException。</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>   &#125;<br><br></code></pre></td></tr></table></figure><h1 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h1><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><p>AQS的核心设计中，FIFO的队列是实现AQS的关键设计</p><p>它采用了一个双向队列，队列的每一个节点Node定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>     <br>     <span class="hljs-keyword">volatile</span> Node prev;<br>     <br>     <span class="hljs-keyword">volatile</span> Node next;<br>     <br>&#125;<br></code></pre></td></tr></table></figure><p>节点还具有模式，分为SHARED和EXCLUSIVE模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(); <span class="hljs-comment">//队列中节点以SHARED模式等待</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">//队列中节点以EXCLUSIVE模式等待</span><br></code></pre></td></tr></table></figure><p>其中队列中每一个线程所对应的节点还有状态，AQS中统一称作 <code>waitedStatus</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程被取消</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 后续线程在锁释放后可以被唤醒</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">// 当前线程在 condition 队列中</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br><span class="hljs-comment">// 表示下一次共享式同步状态获取将会无条件被传播下去</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>在 AQS 顶部定义中，就维护了这个队列的队尾和队首节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>     <br>    <span class="hljs-comment">//队首指针，懒加载。</span><br>    <span class="hljs-comment">//除了初始化之外，它只能通过 setHead 方法修改</span><br>    <span class="hljs-comment">//注意：如果头部存在，其状态保证不是 CANCELLED。 </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br>    <span class="hljs-comment">//队尾指针，懒加载。</span><br>    <span class="hljs-comment">//仅通过方法 enq 添加新的等待节点来修改队尾指针。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h2><p>在上述我们通过文档知道了队列是懒加载的</p><p>所以其实是在元素入队的时候才实例化队头和队尾指针的，文档也说明了入队函数<code>enq()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//初始化队列，设置一个空Node以唤醒队列后续队首节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h1><p>acquire方法中定义了AQS框架获取锁的完整流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;<br>        selfInterrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会调用<code>tryAcquire()</code>，这个方法是抽象方法，交由子类进一步实现，默认是会抛出异常的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试获取锁，但是不一定保证能获取到，如果获取到了返回 true</p><p>因此通过 acquire 源码，如果没获取到锁，会尝试调用 <code>addWaiter</code>，也就是将线程构造成 AQS 队列中的一个 Node 了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//为当前线程和给定模式创建并排队节点</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>       <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>       <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>       <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>       <span class="hljs-comment">// 如果队尾不为空：新节点的前驱指向原先队尾，原队尾的后继指向当前节点，当前节点成为新的队尾</span><br>       <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>           node.prev = pred;<br>           <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>               pred.next = node;<br>               <span class="hljs-keyword">return</span> node;<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">//入队  </span><br>       enq(node);<br>       <span class="hljs-keyword">return</span> node;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>JDK源码中的CountDownLatch就是基于AQS实现的一个最佳学习案例</p><p>下面我们来结合CountDownLatch进行学习</p><h2 id="导论-1"><a href="#导论-1" class="headerlink" title="导论"></a>导论</h2><p>CountDownLatch 允许一个或多个线程 等待 其他线程完成一系列操作后再继续执行（典型的 “等待 - 通知” 模型）</p><p>在实际业务中，我们常常用他来实现多线程环境下线程的等待机制</p><p>例如：服务启动时，异步初始化关键组件：配置文件读取、数据库连接，缓存初始化</p><p>我们希望这三件事情异步执行，主线程等三个事情执行完毕后再继续</p><h2 id="基础api"><a href="#基础api" class="headerlink" title="基础api"></a>基础api</h2><p>基于上述的需求场景，直接看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitApplicationDemo</span> &#123;<br>    <span class="hljs-comment">// 初始化任务数量：3个（加载配置、连接数据库、预热缓存）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INIT_TASK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 1. 初始化CountDownLatch，计数器为3（需等待3个任务完成）</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">initLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(INIT_TASK_COUNT);<br><br>        <span class="hljs-comment">// 2. 启动初始化线程</span><br>        System.out.println(<span class="hljs-string">&quot;主线程：开始启动初始化任务...&quot;</span>);<br><br>        <span class="hljs-comment">// 任务1：加载配置文件</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;初始化线程1：开始加载配置文件...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟耗时操作</span><br>                System.out.println(<span class="hljs-string">&quot;初始化线程1：配置文件加载完成&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 任务完成，计数器减1</span><br>                initLatch.countDown();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;Init-Config&quot;</span>).start();<br><br>        <span class="hljs-comment">// 任务2：连接数据库</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;初始化线程2：开始连接数据库...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1500</span>); <span class="hljs-comment">// 模拟耗时操作</span><br>                System.out.println(<span class="hljs-string">&quot;初始化线程2：数据库连接成功&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                initLatch.countDown();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;Init-DB&quot;</span>).start();<br><br>        <span class="hljs-comment">// 任务3：预热缓存</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;初始化线程3：开始预热缓存...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">800</span>); <span class="hljs-comment">// 模拟耗时操作</span><br>                System.out.println(<span class="hljs-string">&quot;初始化线程3：缓存预热完成&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                initLatch.countDown();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;Init-Cache&quot;</span>).start();<br><br>        <span class="hljs-comment">// 3. 主线程等待所有初始化任务完成（计数器到0）</span><br>        initLatch.await(); <span class="hljs-comment">// 阻塞在这里，直到所有任务countDown()后计数器为0</span><br><br>        <span class="hljs-comment">// 4. 所有初始化完成，启动应用</span><br>        System.out.println(<span class="hljs-string">&quot;主线程：所有初始化任务完成，应用启动成功！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，CountDownLatch的使用很简单：实例化对象时定义一个状态（计数器）</p><p>某个线程可以通过 <code>countDown()</code> 方法将计数器减 1（每调用一次减 1）</p><p>想要等待的线程通过 <code>await()</code> 方法进行等待，直到计数器减到 0 后被唤醒</p><p>因此在上面的代码中，我们实现逻辑的最终流程如下：</p><ol><li><strong>主线程</strong>启动时创建 <code>CountDownLatch</code>，计数器初始值为 3（对应 3 个初始化任务）</li><li>启动 3 个初始化线程，分别执行加载配置、连接数据库、预热缓存（模拟耗时操作）</li><li>每个初始化线程完成任务后，在 <code>finally</code> 中调用 <code>countDown()</code>，确保无论任务是否异常，计数器都会减 1</li><li>主线程调用 <code>initLatch.await()</code> 后阻塞，等待计数器从 3 减到 0</li><li>当最后一个初始化线程调用 <code>countDown()</code> 后，计数器归 0，主线程被唤醒，继续执行 “应用启动” 逻辑</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatch</span> &#123;<br>    <span class="hljs-comment">// 内部同步器，继承 AQS</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-comment">// 构造方法：初始化 AQS 的 state 为 count</span><br>        Sync(<span class="hljs-type">int</span> count) &#123;<br>            setState(count); <span class="hljs-comment">// state 是 AQS 的核心变量，代表计数器值</span><br>        &#125;<br><br>        <span class="hljs-comment">// 获取当前计数器值</span><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState();<br>        &#125;<br><br>        <span class="hljs-comment">// 共享模式下尝试获取同步状态（对应 await() 方法）</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-comment">// 若 state == 0，说明计数器已归零，可获取到同步状态（返回 1）</span><br>            <span class="hljs-comment">// 否则获取失败（返回 -1）</span><br>            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 共享模式下尝试释放同步状态（对应 countDown() 方法）</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-comment">// 循环 CAS 操作：将 state 减 1</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 计数器已归零，无法再减</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc)) &#123; <span class="hljs-comment">// CAS 保证线程安全</span><br>                    <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>; <span class="hljs-comment">// 若减到 0，返回 true（需要唤醒等待线程）</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br><br>    <span class="hljs-comment">// 构造方法：初始化 sync，传入计数器值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>        <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>    &#125;<br><br>    <span class="hljs-comment">// 核心方法：等待计数器归零</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>); <span class="hljs-comment">// 调用 AQS 的共享模式中断式获取</span><br>    &#125;<br><br>    <span class="hljs-comment">// 核心方法：计数器减 1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>); <span class="hljs-comment">// 调用 AQS 的共享模式释放</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前计数器值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.getCount();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CountDownLatch 的源码短小精悍，核心在于其中的 <code>Sync</code> 类，这个类继承了 AQS 框架，重写了父类暴露的两个核心方法<code>tryAcquireShared</code> 以及 <code>tryReleaseShared</code></p><h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>父类的模板中定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上调用的是CountDownLatch重写的<code>tryReleaseShared</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一段逻辑就是递减state值，<code>compareAndSetState</code>是原子地设置状态，如果成功将状态更新到0，那么就会进入AQS中的<code>doReleaseShared</code>，唤醒同步队列中的等待线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK8|ThreadPoolExecutor</title>
    <link href="/2025/07/25/JDK8-ThreadPoolExecutor/"/>
    <url>/2025/07/25/JDK8-ThreadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<h1 id="创建与使用"><a href="#创建与使用" class="headerlink" title="创建与使用"></a>创建与使用</h1><h2 id="线程池创建核心参数"><a href="#线程池创建核心参数" class="headerlink" title="线程池创建核心参数"></a>线程池创建核心参数</h2><p>一般我们都会使用线程池对象的构造函数来结合不同的场景定义线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>核心参数：</p><ul><li>corePoolSize 核心线程池个数</li><li>maximumPoolSize 任务队列最大长度</li><li>keepAliveTime 非核心线程最长回收时间（单位通过 unit 定义）</li></ul><p>corePoolSize <strong>在默认情况下定义了常驻的线程个数</strong>，maximumPoolSize 为线程池最大长度（也就是任务队列最大长度）一开始队列没有满的时候，只会有 corePoolSize 个线程跑；等到任务队列满了以后，此时会有 maximumPoolSize 个线程跑</p><p>maximumPoolSize - corePoolSize 就是非核心线程的个数，他们是会被回收的，在空闲的时候等待 keepAliveTime (unit) 后会被回收</p><p>剩下的构造函数参数（例如<code>ThreadFactory</code>，<code>BlockingQueue</code> 和<code>RejectedExecutionHandler</code> 我们会在后面的部分详细介绍）</p><h2 id="执行接口"><a href="#执行接口" class="headerlink" title="执行接口"></a>执行接口</h2><p>线程池的执行接口主要有两个：<code>execute</code>  和 <code>submit</code></p><p>通过源码我们可以发现，submit 底层还是调用的 execute </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExecutorService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExecutorService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>        execute(ftask);<br>        <span class="hljs-keyword">return</span> ftask;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>        execute(ftask);<br>        <span class="hljs-keyword">return</span> ftask;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>        execute(ftask);<br>        <span class="hljs-keyword">return</span> ftask;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么他们之间到底有什么区别？</p><p>上面的源码可以发现无论 submit 的实际入参是哪一个，最终都会被包装为 RunnableFuture 的任务，调用 execute 方法。RunnableFuture 是一个接口，组合了 Runnable 以及 Future，表示既可以被线程执行，同时也可以获取任务的结果或异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A &#123;<span class="hljs-doctag">@link</span> Future&#125; that is &#123;<span class="hljs-doctag">@link</span> Runnable&#125;. Successful execution of</span><br><span class="hljs-comment"> * the &#123;<span class="hljs-doctag">@code</span> run&#125; method causes completion of the &#123;<span class="hljs-doctag">@code</span> Future&#125;</span><br><span class="hljs-comment"> * and allows access to its results.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> FutureTask</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Executor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.6</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Doug Lea</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; The result type returned by this Future&#x27;s &#123;<span class="hljs-doctag">@code</span> get&#125; method</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>, Future&lt;V&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets this Future to the result of its computation</span><br><span class="hljs-comment">     * unless it has been cancelled.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们可以知道，execute 会直接执行，而 <code>submit</code> 则是返回一个 Future，供我们统一获取执行的结果。所以如果在任务执行的时候抛出了异常，那么 <strong>execute 方式执行的线程出现异常之后会直接销毁</strong>，但是 submit 方式执行的线程出现异常之后会将异常封装在 Future 中，等到 get Future 的时候才会抛出，因此 <strong>submit 方式执行的线程在异常出现时不会直接销毁</strong></p><h2 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h2><p>线程池通过一个int同时存储线程池的运行状态和工作线程数量</p><p>运行状态有五种，高三位存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 五种运行状态，在 int 的高三位存储</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">//pack操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><p>用一个int同时存储两个状态主要是在后续的操作中会很需要经常同时判断运行状态和工作线程数量的场景，因此从底层性能优化考虑采用位运算的方式进行存储，虽然缺乏一些可读性，但是性能优化拉满了</p><p>有pack就有unpack，下面是单独的unpack方法，用于获取线程执行状态或是工作线程数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br></code></pre></td></tr></table></figure><h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><p>在上面我们知道了无论什么入口都是调用 ThreadPoolExecutor 的 execute 方法（ sumbit 先是封装为 FutureTask 后通过 ThreadPoolExecutor 的父类 <code>AbstractExecutorService</code> 调用 Executor 接口定义的 execute 方法来执行的）</p><p>下面我们更进一步，我们想知道 execute 内部到底做了什么，流程是什么样的</p><p>这就涉及到线程池的任务管理，在实现底层，线程池采用了将 <strong>提交的任务</strong> 与 <strong>任务的实际执行</strong> 分离解耦的思想</p><p>在使用方（也就是开发者），只需要调用 execute 或是 submit 将任务提交，具体如何执行，线程池内部有一套任务管理实现，可以分为四个部分：</p><ul><li>任务调度————execute入口，创建worker，放入队列或是拒绝</li><li>任务缓冲————阻塞队列缓冲任务</li><li>任务申请————worker不断消费阻塞队列任务</li><li>任务拒绝————可配置的拒绝策略</li></ul><h2 id="execute入口任务调度"><a href="#execute入口任务调度" class="headerlink" title="execute入口任务调度"></a>execute入口任务调度</h2><p>在上面我们知道了无论什么入口都是调用 ThreadPoolExecutor 的 execute 方法（ sumbit 先是封装为 FutureTask 后通过 ThreadPoolExecutor 的父类调用 Executor 接口定义的 execute 方法来执行的）</p><p>下面我们来看任务管理的入口，这里就是线程池核心的任务运行机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-comment">// 【1】线程池正在运行，且当前工作线程数 &lt; corePoolSize，尝试创建核心线程执行任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><span class="hljs-comment">// 【2】核心工作线程满了，线程池仍处于运行状态 &amp;&amp; 任务队列没满，将任务丢尽队列</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>    <span class="hljs-comment">// double-check：防止任务入队之后线程池状态变为非RUNNING，或者线程池没有工作线程了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>          <span class="hljs-comment">// 当前没有工作线程了，为了避免任务一直留在队列里没人处理，创建一个非核心线程执行</span><br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><span class="hljs-comment">// 【3】如果不能入队（队列满了），尝试创建非核心线程（最大线程数之内）</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>    <span class="hljs-comment">// 【4】如果线程数已到最大值或线程池非RUNNING，则执行拒绝策略             </span><br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>源码写的比较反直觉，主要是check线程池的RUNNING状态在execute中并未显式指定，而是在 addWorker 中进行了判断（我们后面会提到）</p><p>还有一点是double-check操作，在核心线程满了同时可以入队的情况下，入队后还需要进行一次check，因为此时线程池状态可能发生变化（比如调用了<code>shutdown()</code>）导致此时没有可用线程了，但是队列里还是有任务，因此这种情况下需要创建一个非核心线程执行任务</p><p>在后续也会提到，<code>addWorker()</code> 是关键方法，它不仅创建线程，还会判断线程池状态、线程数上限等</p><h2 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h2><p>execute 函数中的 <code>workQueue.offer()</code> 指的就是将任务提交到任务缓冲队列中</p><p>线程池底层采用阻塞队列来实现任务缓冲，<strong>任务缓冲是线程池实现任务的提交和线程执行任务解耦的关键</strong></p><p>我们在<a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0">之前</a>说实例化线程池的时候也需要指定一个阻塞队列来构造线程池对象，这里就是指定缓冲队列</p><p>不推荐使用JDK自带的Executors直接创建线程池也是因为自带的Executors类创建线程池的时候，默认在阻塞队列这一块给的是Integer.MAX_VALUE 的容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Executors</span> &#123;<br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                      threadFactory);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(Integer.MAX_VALUE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就意味着队列基本上是无限大，容易出现OOM的问题</p><h2 id="getTask任务申请"><a href="#getTask任务申请" class="headerlink" title="getTask任务申请"></a>getTask任务申请</h2><p>在 execute 函数中，会调用 <code>addWorker</code> 尝试创建worker，<code>addWorker</code> 函数的参数有时为 null 有时非空，这代表任务的执行分两种情况：</p><ul><li>一种是直接新建线程worker在构造函数中携带任务（Worker后面会提到），这种情况只会在第一次创建线程的时候才会触发</li><li>更常见的则是线程不断从阻塞队列中获取任务进行执行</li></ul><p>第二种情况的核心逻辑在 <code>getTask</code> 中</p><p>这一部分最重要的点在于：<strong>默认情况下，核心线程是会一直阻塞等待新的任务的</strong>，也就是调用阻塞队列 workQueue.take()；而<strong>非核心线程则是会进行有限时间的超时等待</strong>，是调用 workQueue.poll(keepAliveTime, TimeUnit)，一旦非核心线程超时则会进入idle空闲状态，之后就会被线程池回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// 手动修改配置(令核心线程也具有keepAlive）或是为非核心线程时则会进行超时判断</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="hljs-comment">//有限时间超时获取</span><br>                workQueue.take(); <span class="hljs-comment">//阻塞获取</span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h2><p>针对拒绝策略的讨论，都是假设在任务队列已满、同时这个时候还有新的任务提交进来的时候</p><p>拒绝策略有下面这几种：</p><p>默认采用 AbortPolicy 如果满了直接抛出异常进行拒绝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that throws a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> RejectedExecutionException&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Always throws RejectedExecutionException.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException always</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                             <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                             e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的策略：</p><ul><li>CallerRunsPolicy：不会丢弃任务，而是由执行方法的调用线程(calling thread)直接运行；采用这种方法会影响程序的整体性能，但是如果对任务丢失很敏感的话可以采用这个拒绝策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that runs the rejected task</span><br><span class="hljs-comment"> * directly in the calling thread of the &#123;<span class="hljs-doctag">@code</span> execute&#125; method,</span><br><span class="hljs-comment"> * unless the executor has been shut down, in which case the task</span><br><span class="hljs-comment"> * is discarded.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;<span class="hljs-doctag">@code</span> CallerRunsPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Executes task r in the caller&#x27;s thread, unless the executor</span><br><span class="hljs-comment">     * has been shut down, in which case the task is discarded.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Discard：不抛异常，什么都不做</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that silently discards the</span><br><span class="hljs-comment"> * rejected task.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Does nothing, which has the effect of discarding task r.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>         <span class="hljs-comment">//do nothing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DiscardOldest：丢弃最先入队列的未处理任务来空出位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that discards the oldest unhandled</span><br><span class="hljs-comment"> * request and then retries &#123;<span class="hljs-doctag">@code</span> execute&#125;, unless the executor</span><br><span class="hljs-comment"> * is shut down, in which case the task is discarded.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardOldestPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Obtains and ignores the next task that the executor</span><br><span class="hljs-comment">     * would otherwise execute, if one is immediately available,</span><br><span class="hljs-comment">     * and then retries execution of task r, unless the executor</span><br><span class="hljs-comment">     * is shut down, in which case task r is instead discarded.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            e.getQueue().poll();<br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Worker工作线程"><a href="#Worker工作线程" class="headerlink" title="Worker工作线程"></a>Worker工作线程</h1><p>前面我们说完了线程池内部的任务提交、调度、获取流程，这是一个大模块</p><p>另一个大模块则是线程的执行，<strong>任务的提交和线程的执行互相解耦</strong>，<strong>内部通信则是通过我们实例化线程池时指定的阻塞队列来实现的</strong></p><p>在线程池中，Worker类是执行线程的对象，一个 Worker 就是一个线程</p><p>来看下官方的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">final</span> Thread thread;<span class="hljs-comment">//Worker持有的线程</span><br>    Runnable firstTask;<span class="hljs-comment">//初始化的任务，可以为null</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h2><p>在 execute 函数中我们知道核心的执行逻辑被放在了 addWorker 里，addWorker 会尝试创建 Worker 实例，根据不同的入参，实例创建完的行为也不同</p><p>addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//附带初始任务 实例化Worker</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-comment">//一个Worker就是一个线程，获取Worker线程</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">//执行worker中的run方法，启动Worker</span><br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 worker 实现了 runnable 接口，因此在 addWorker 的时候，实例化 Worker 对象完成后， worker 就通过线程池构造函数中 ThreadFactory 创建好了 thread 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Worker(Runnable firstTask) &#123;<br>    setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>    <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>    <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>后续只要调用 worker.thread.start()，执行的都会是 Worker 重写的 run 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    runWorker(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此经过一系列 CAS 检查后，在 addWorker 实例化完 Worker 对象后，通过调用 <code>w.thread.start()</code> 启动了这个 Worker 线程</p><p>（CAS这里我们后面再关注，先挖一个坑）</p><p>因此我们关注点需要放在 Worker 的 runWorker 方法上</p><h2 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//默认先检查是否有构造Worker实例时携带的初始任务</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//循环从阻塞队列中获取任务</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                     <span class="hljs-comment">//执行任务</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这一步就很明了了，Worker启动后会不断调用 getTask 直到 getTask 返回 null，一旦返回 null 就会被回收</p><p>而在<a href="#getTask%E4%BB%BB%E5%8A%A1%E7%94%B3%E8%AF%B7">之前</a>我们也知道，当默认配置下，核心线程不会进入空闲态，非核心线程在有限阻塞时间获取不到任务后，就会进入空闲态返回 null 值</p><h2 id="Worker回收"><a href="#Worker回收" class="headerlink" title="Worker回收"></a>Worker回收</h2><p>Worker 的回收是基于 JVM 的垃圾回收自动回收的</p><p>在 ThreadPoolExecutor 中有一个 <code>HashSet&lt;Worker&gt;</code> 来记录所有非回收 Worker 的引用防止被GC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Set containing all worker threads in pool. Accessed only when</span><br><span class="hljs-comment"> * holding mainLock.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Worker&gt;();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm|LinkedList</title>
    <link href="/2025/07/18/Algorithm-LinkedList/"/>
    <url>/2025/07/18/Algorithm-LinkedList/</url>
    
    <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>链表的题目，有一个最基本的思想：</p><p>如果感觉针对头或者尾需要特殊处理操作的时候, 可以新建一个 dummy node, 不包含任何实际操作，但是可以让算法执行更流畅更通用</p><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><h2 id="判断环"><a href="#判断环" class="headerlink" title="判断环"></a>判断环</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">141.环形链表</a></p><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。</p><p>为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。</p><p>注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true, 否则，返回 false</p><h3 id="第一思路：存储访问Map"><a href="#第一思路：存储访问Map" class="headerlink" title="第一思路：存储访问Map"></a>第一思路：存储访问Map</h3><p>第一眼想到的是用一个Map存储是否已经访问的状态</p><p>在一次遍历的过程中更新这个Map</p><p>如果存在环，那么一定会再次访问Map中相同的节点，这个时候就可以以此来进行判断了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>   <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>   Map&lt;ListNode, Boolean&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>   <span class="hljs-keyword">while</span> (curr.next != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(visited.get(curr))) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      visited.put(curr, <span class="hljs-literal">true</span>);<br>      curr = curr.next;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进阶思路：快慢指针"><a href="#进阶思路：快慢指针" class="headerlink" title="进阶思路：快慢指针"></a>进阶思路：快慢指针</h3><p>这是经典的Floyd判圈算法，原理很简单：我们手动设定两个指针，一快一慢，如果存在环，那么一定会有某个时刻，快的重新追上慢的</p><p>原理虽然简单，但是带来的效果很强大，他解决了我们第一种情况下O(n)空间复杂度的问题，只实现了常量级（O(2)）的内存，就实现了一样的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 快慢指针Floyd判圈算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head 头结点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 是否有环</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">floydCircleCheck</span><span class="hljs-params">(ListNode head)</span> &#123;<br>   <span class="hljs-comment">//0个节点或者是1个节点都可以认为没有环</span><br>   <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;<br>   <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>      <span class="hljs-comment">//如果没有环，fast一定走到了终点           </span><br>      <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      slow = slow.next;<br>      fast = fast.next.next;<br>   &#125;<br>   <span class="hljs-comment">//有环，快的一定会在某一轮次追上慢的</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206.反转链表</a></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><h3 id="第一思路：双指针"><a href="#第一思路：双指针" class="headerlink" title="第一思路：双指针"></a>第一思路：双指针</h3><p>一次遍历，反转next域，最后返回尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span> <span class="hljs-params">(ListNode head)</span> &#123;<br>   <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> head;<br>   &#125;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> slow.next;<br>   slow.next = <span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> fast.next;<br>      fast.next = slow;<br>      slow = fast;<br>      fast = next;<br>   &#125;<br>   <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意，初始的时候需要设置头节点（也就是反转后的尾节点）<code>next域 = null</code> 以通过 OJ 测试案例</p><h3 id="进阶思路：递归"><a href="#进阶思路：递归" class="headerlink" title="进阶思路：递归"></a>进阶思路：递归</h3><p>虽然双指针的解法空间复杂度更优，递归的是O(n)，但是递归的写法更能体现思维能力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ListNode <span class="hljs-title function_">reverseAllFollow</span><span class="hljs-params">(ListNode head)</span> &#123;<br>   <span class="hljs-comment">//空或是一个元素时无需反转</span><br>   <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> head;<br>   &#125;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverseAllFollow(next);<br>   next.next = head;<br>   <span class="hljs-keyword">return</span> newHead;<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>   <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br>   <span class="hljs-type">ListNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> reverseAllFollow(head);<br>   head.next = <span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">return</span> tail;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>202507|技术日志</title>
    <link href="/2025/07/10/202507-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/"/>
    <url>/2025/07/10/202507-%E6%8A%80%E6%9C%AF%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="0710"><a href="#0710" class="headerlink" title="0710"></a>0710</h1><h2 id="线程池什么时候执行"><a href="#线程池什么时候执行" class="headerlink" title="线程池什么时候执行"></a>线程池什么时候执行</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>当调用 threadPoolExecutor.submit(() -&gt; { … }) 时，<strong>任务就已经被提交到线程池中，并由线程池中的工作线程异步执行</strong>（前提是当前线程池有空闲线程）</p><p>因此在代码中这样的写法是完全符合多线程异步执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Future&lt;?&gt;&gt; futureList= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>( xxx ) &#123;<br>    Future&lt;?&gt; future = threadPoolExecutor.submit(() -&gt; &#123;<br>    <span class="hljs-comment">//do something</span><br>    &#125;);   <br>    futureList.add(future);<br>&#125;<br><span class="hljs-keyword">for</span> (Future&lt;List&lt;RcRiskRuleExecResult&gt;&gt; future : futureList) &#123;<br>    res.addAll(future.get());<br>&#125;<br></code></pre></td></tr></table></figure><p>只是在获取结果的时候遍历等待，但是此时线程可以确定的是已经提交开始执行了</p><p>比如 futureList 中有三个 future，性能的瓶颈只会在最慢获取结果的那一条里</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>使用 CompletableFuture 替换传统派 Future</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;CompletableFuture&lt;List&lt;?&gt;&gt;&gt; futureList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : dispatchedResult.entrySet()) &#123;<br>    ...<br>    CompletableFuture&lt;List&lt;?&gt;&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>         <span class="hljs-comment">//do something</span><br>    &#125;, threadPoolExecutor);<br>    futureList.add(future);<br>&#125;<br><br><span class="hljs-comment">// 合并所有结果</span><br>CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(futureList.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>]));<br>allFutures.join(); <span class="hljs-comment">// 等待全部完成</span><br><br><span class="hljs-comment">// 收集结果</span><br>List&lt;?&gt; res = futureList.stream()<br>        .map(CompletableFuture::join)<br>        .flatMap(List::stream)<br>        .toList();<br></code></pre></td></tr></table></figure><h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><ul><li>ThreadPoolExecutor 线程池</li><li>Future &amp; CompletableFuture</li></ul><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>我们都知道想要实现一个线程一份独立的数据的时候可以使用 ThreadLocal 来管理数据</p><p>ThreadLocal的底层实际上是基于他的静态内部类ThreadLocalMap</p><blockquote><p>JDK文档：</p><p>ThreadLocalMap 是一个专门用于维护 ThreadLocal 值而定制化设计的 HashMap，所有对 ThreadLocalMap 的操作只会发生在 TheadLocal 类内部。为应对 very large and long-lived usages，HashMap 的 entry 使用弱引用作为key (?)</p></blockquote><p>ThreadLocalMap 的 key 是 TheadLocal， value 是 ThreadLocal 存储的数据值</p><h1 id="0711"><a href="#0711" class="headerlink" title="0711"></a>0711</h1><h2 id="线程池核心参数"><a href="#线程池核心参数" class="headerlink" title="线程池核心参数"></a>线程池核心参数</h2><p>一般我们都会使用线程池对象的构造函数来结合不同的场景定义线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>核心参数：</p><ul><li>corePoolSize 核心线程池个数</li><li>maximumPoolSize 任务队列最大长度</li><li>keepAliveTime 非核心线程最长回收时间（单位通过 unit 定义）</li></ul><p>corePoolSize <strong>在默认情况下定义了常驻的线程个数</strong>，maximumPoolSize 为线程池最大长度（也就是任务队列最大长度）一开始队列没有满的时候，只会有 corePoolSize 个线程跑；等到任务队列满了以后，此时会有 maximumPoolSize 个线程跑</p><p>maximumPoolSize - corePoolSize 就是非核心线程的个数，他们是会被回收的，在空闲的时候等待 keepAliveTime (unit) 后会被回收</p><h1 id="0714"><a href="#0714" class="headerlink" title="0714"></a>0714</h1><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>针对拒绝策略的讨论，都是假设在任务队列已满、同时这个时候还有新的任务提交进来的时候</p><p>拒绝策略有下面这几种：</p><p>默认采用 AbortPolicy 如果满了直接抛出异常进行拒绝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that throws a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> RejectedExecutionException&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Always throws RejectedExecutionException.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException always</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                             <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                             e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的策略：</p><ul><li>CallerRunsPolicy：不会丢弃任务，而是由执行方法的调用线程(calling thread)直接运行；采用这种方法会影响程序的整体性能，但是如果对任务丢失很敏感的话可以采用这个拒绝策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that runs the rejected task</span><br><span class="hljs-comment"> * directly in the calling thread of the &#123;<span class="hljs-doctag">@code</span> execute&#125; method,</span><br><span class="hljs-comment"> * unless the executor has been shut down, in which case the task</span><br><span class="hljs-comment"> * is discarded.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;<span class="hljs-doctag">@code</span> CallerRunsPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Executes task r in the caller&#x27;s thread, unless the executor</span><br><span class="hljs-comment">     * has been shut down, in which case the task is discarded.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Discard：不抛异常，什么都不做</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that silently discards the</span><br><span class="hljs-comment"> * rejected task.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Does nothing, which has the effect of discarding task r.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>         <span class="hljs-comment">//do nothing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DiscardOldest：丢弃最先入队列的未处理任务来空出位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that discards the oldest unhandled</span><br><span class="hljs-comment"> * request and then retries &#123;<span class="hljs-doctag">@code</span> execute&#125;, unless the executor</span><br><span class="hljs-comment"> * is shut down, in which case the task is discarded.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardOldestPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Obtains and ignores the next task that the executor</span><br><span class="hljs-comment">     * would otherwise execute, if one is immediately available,</span><br><span class="hljs-comment">     * and then retries execution of task r, unless the executor</span><br><span class="hljs-comment">     * is shut down, in which case task r is instead discarded.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            e.getQueue().poll();<br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h2><p>结合JDK源码进行学习</p><p>一般来说我们都是直接调用 <code>threadPoolExecutor.sumbit(() -&gt; execute())</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExecutorService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExecutorService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>        execute(ftask);<br>        <span class="hljs-keyword">return</span> ftask;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>        execute(ftask);<br>        <span class="hljs-keyword">return</span> ftask;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>        execute(ftask);<br>        <span class="hljs-keyword">return</span> ftask;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现无论 submit 的实际入参是哪一个，最终都会被包装为 RunnableFuture 的任务，调用 execute 方法</p><p>RunnableFuture 是一个接口，组合了 Runnable 以及 Future，表示既可以被线程执行，同时也可以获取任务的结果或异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A &#123;<span class="hljs-doctag">@link</span> Future&#125; that is &#123;<span class="hljs-doctag">@link</span> Runnable&#125;. Successful execution of</span><br><span class="hljs-comment"> * the &#123;<span class="hljs-doctag">@code</span> run&#125; method causes completion of the &#123;<span class="hljs-doctag">@code</span> Future&#125;</span><br><span class="hljs-comment"> * and allows access to its results.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> FutureTask</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> Executor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.6</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Doug Lea</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; The result type returned by this Future&#x27;s &#123;<span class="hljs-doctag">@code</span> get&#125; method</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span>, Future&lt;V&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets this Future to the result of its computation</span><br><span class="hljs-comment">     * unless it has been cancelled.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0722"><a href="#0722" class="headerlink" title="0722"></a>0722</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_43669111/article/details/106321868">CSDN</a></p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团技术团队</a></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>线程池通过一个int同时存储线程池的运行状态和工作线程数量</p><p>运行状态有五种，高三位存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 五种运行状态，在 int 的高三位存储</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">//pack操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><p>用一个int同时存储两个状态主要是在后续的操作中会很需要经常同时判断运行状态和工作线程数量的场景，因此从底层性能优化考虑采用位运算的方式进行存储，虽然缺乏一些可读性，但是性能优化拉满了</p><p>有pack就有unpack，下面是单独的unpack方法，用于获取线程执行状态或是工作线程数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br></code></pre></td></tr></table></figure><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>在上面我们知道了无论什么入口都是调用 ThreadPoolExecutor 的 execute 方法（ sumbit 先是封装为 FutureTask 后通过 ThreadPoolExecutor 的父类调用 Executor 接口定义的 execute 方法来执行的）</p><p>下面我们来看任务管理的入口，这里就是线程池核心的任务运行机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-comment">// 【1】线程池正在运行，且当前工作线程数 &lt; corePoolSize，尝试创建核心线程执行任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><span class="hljs-comment">// 【2】核心工作线程满了，线程池仍处于运行状态 &amp;&amp; 任务队列没满，将任务丢尽队列</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>    <span class="hljs-comment">// double-check：防止任务入队之后线程池状态变为非RUNNING，或者线程池没有工作线程了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>          <span class="hljs-comment">// 当前没有工作线程了，为了避免任务一直留在队列里没人处理，创建一个非核心线程执行</span><br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><span class="hljs-comment">// 【3】如果不能入队（队列满了），尝试创建非核心线程（最大线程数之内）</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>    <span class="hljs-comment">// 【4】如果线程数已到最大值或线程池非RUNNING，则执行拒绝策略             </span><br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>源码写的比较反直觉，主要是check线程池的RUNNING状态在execute中并未显式指定，而是在 addWorker 中进行了判断（我们后面会提到）</p><p>还有一点是double-check操作，在核心线程满了同时可以入队的情况下，入队后还需要进行一次check，因为此时线程池状态可能发生变化（比如调用了<code>shutdown()</code>）导致此时没有可用线程了，但是队列里还是有任务，因此这种情况下需要创建一个非核心线程执行任务</p><p>在后续也会提到，<code>addWorker()</code> 是关键方法，它不仅创建线程，还会判断线程池状态、线程数上限等。</p><h2 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h2><p>线程池底层采用阻塞队列来实现任务缓冲，<strong>任务缓冲是线程池实现任务的提交和线程执行任务解耦的关键</strong></p><p>我们在实例化线程池的时候也需要指定一个阻塞队列来构造线程池对象，这里就是指定缓冲队列</p><p>不推荐使用JDK自带的Executors直接创建线程池也是因为自带的Executors类创建线程池的时候，默认在阻塞队列这一块给的是Integer.MAX_VALUE 的容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Executors</span> &#123;<br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                      threadFactory);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedBlockingQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(Integer.MAX_VALUE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就意味着队列基本上是无限大，容易出现OOM的问题</p><p>算法：刷了一题<a href="https://leetcode.cn/problems/valid-parentheses/">20.有效的括号</a></p><p>核心实现思路很简单，一次遍历string，遇到左括号的，push，遇到右括号的，pop，比较是否是一对，不是一对说明不是有效的括号。在遍历完成后，栈一定是空的，才说明是有效的括号</p><h1 id="0723"><a href="#0723" class="headerlink" title="0723"></a>0723</h1><p>算法：手写二分查找，基本功 <a href="https://leetcode.cn/problems/binary-search/submissions/646249707/">704.二分查找</a></p><h2 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h2><p>我们都知道任务的执行分两种情况：</p><ul><li>一种是直接新建线程worker在构造函数中携带任务（Worker后面会提到），这种情况只会在第一次创建线程的时候才会触发</li><li>更常见的则是线程不断从阻塞队列中获取任务进行执行</li></ul><p>第二种情况的核心逻辑在 <code>getTask</code> 中</p><p>这一部分最重要的点在于：<strong>默认情况下，核心线程是会一直阻塞等待新的任务的</strong>，也就是调用阻塞队列 workQueue.take()；而<strong>非核心线程则是会进行有限时间的超时等待</strong>，是调用 workQueue.poll(keepAliveTime, TimeUnit)，一旦非核心线程超时则会进入idle空闲状态，之后就会被线程池回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// 手动修改配置(令核心线程也具有keepAlive）或是为非核心线程时则会进行超时判断</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="hljs-comment">//有限时间超时获取</span><br>                workQueue.take(); <span class="hljs-comment">//阻塞获取</span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0724"><a href="#0724" class="headerlink" title="0724"></a>0724</h1><h2 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h2><p>前面我们说完了线程池内部的任务提交、调度、获取流程，这是一个大模块</p><p>另一个大模块则是线程的执行，<strong>任务的提交和线程的执行互相解耦</strong>，<strong>内部通信则是通过我们实例化线程池时指定的阻塞队列来实现的</strong></p><p>在线程池中，Worker类是执行线程的对象</p><p>来看下官方的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">final</span> Thread thread;<span class="hljs-comment">//Worker持有的线程</span><br>    Runnable firstTask;<span class="hljs-comment">//初始化的任务，可以为null</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Worker 类主要负责维护执行任务的线程的中断控制状态，以及其他一些次要的记账工作。</p><p>这个类通过机会性地扩展 AbstractQueuedSynchronizer 来简化围绕每个任务执行的锁的获取和释放，从而防止打算唤醒等待任务的 Worker 线程的中断，反而中断正在运行的任务。</p><p>我们实现了一个简单的非重入互斥锁，而不是使用 ReentrantLock，因为我们不希望 Worker 任务在调用如 setCorePoolSize 之类的池控制方法时能够重新获取锁。</p><p>此外，为了在线程实际开始运行任务之前抑制中断，我们将锁状态初始化为负值，并在启动时清除它（在 runWorker 中）。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>找工作</tag>
      
      <tag>自我提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript|...扩展运算符</title>
    <link href="/2025/07/02/JavaScript-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2025/07/02/JavaScript-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>问题引入</p><p>最近在项目代码中经常会看到 <code>...</code> 的操作符，不管是在 React 还是 Vue 的写法中都很通用</p><p>快速总结： <code>...</code> 是 JS 中的扩展操作符，可以对变量操作，可以用在函数签名中，也可以用于组件props传递</p><ul><li>对变量操作，可以将数组&#x2F;对象变量进行展开</li><li>用在函数签名中，可以用于将函数签名中所有的参数都收集到指定的数组里（类似JDK8提供的可变形参）</li><li>用在组件props传递，可以定制更通用化的组件</li></ul><p>下面展开进行描述：</p><p>对变量操作：</p><p>  对对象进行操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userInfo = &#123;<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>     <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;bar&quot;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> userExt = &#123;<br>     <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>     <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;foo&quot;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> user = &#123;...userInfo, ...userExt&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user) <span class="hljs-comment">// 同时包含&#123;name,code,age,address&#125; 这些字段</span><br></code></pre></td></tr></table></figure><p>当然可能也会出现覆盖的情况，具体以最后一次定义的值为准</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userInfo = &#123;<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>     <span class="hljs-attr">code</span>: <span class="hljs-string">&quot;bar&quot;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> userFront = &#123;<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;userFront&quot;</span><br>     ...userInfo<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user) <span class="hljs-comment">// 最终的name = &quot;foo&quot;</span><br><br><br><span class="hljs-keyword">const</span> userBack = &#123;<br>     ...userInfo,<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;userBack&quot;</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userBack) <span class="hljs-comment">//最终的name = &quot;userBack&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3|Todo List in Action</title>
    <link href="/2025/06/21/Vue3-Todo-List-in-Action/"/>
    <url>/2025/06/21/Vue3-Todo-List-in-Action/</url>
    
    <content type="html"><![CDATA[<h1 id="computed-追踪依赖"><a href="#computed-追踪依赖" class="headerlink" title="computed 追踪依赖"></a>computed 追踪依赖</h1><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>现在有一个需求，需要展示状态中存储的任务总数，状态中存储的任务列表是一个数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> &#123; nanoid &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nanoid&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123; <span class="hljs-title class_">Task</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/types/task&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTaskStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;task&#x27;</span>, &#123;<br>    <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>        <span class="hljs-attr">tasks</span>: [] <span class="hljs-keyword">as</span> <span class="hljs-title class_">Task</span>[]<br>    &#125;),<br>    <span class="hljs-attr">actions</span>: &#123;<br>        <span class="hljs-title function_">addTask</span>(<span class="hljs-params">title: <span class="hljs-built_in">string</span>, description = <span class="hljs-string">&#x27;&#x27;</span></span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>.<span class="hljs-title function_">push</span>(&#123;<br>                <span class="hljs-attr">id</span>: <span class="hljs-title function_">nanoid</span>(),<br>                title,<br>                description,<br>                <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>,<br>                <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>()<br>            &#125;)<br>        &#125;,<br>        <span class="hljs-title function_">toggleTask</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) &#123;<br>            <span class="hljs-keyword">const</span> task = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">id</span> === id)<br>            <span class="hljs-keyword">if</span> (task) task.<span class="hljs-property">completed</span> = !task.<span class="hljs-property">completed</span><br>        &#125;,<br>        <span class="hljs-title function_">deleteTask</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">id</span> !== id)<br>        &#125;,<br>        <span class="hljs-title function_">removeCompletedTasks</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">completed</span> === <span class="hljs-literal">false</span>)<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">persist</span>: <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h2><p>在展示的时候，很自然的写出了这样的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;padding: 2rem&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Taskmate<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">n-space</span> <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;start&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">n-button-group</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">n-button</span> <span class="hljs-attr">round</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;tertiary&quot;</span>&gt;</span><br>          &#123;&#123; totalTaskCount &gt; 0 ? &quot;今日任务总数：&quot; + totalTaskCount : &#x27;当前尚无任务&#x27;&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">n-button</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">n-button-group</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">n-space</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;useTaskStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/taskStore&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> taskStore = <span class="hljs-title function_">useTaskStore</span>()</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> totalTaskCount = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">totalTaskCount.<span class="hljs-property">value</span> = taskStore?.<span class="hljs-property">tasks</span>?.<span class="hljs-property">length</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是后续测试发现，如果修改了 pinia 中的数组长度，界面上展示的个数并不会发生改变，这主要是因为这种方式本质上只是一个快照</p><p><code>totalTaskCount.value = taskStore.tasks.length</code> 是一段<strong>同步代码</strong>，只会在组件初始化的时候时执行一次；</p><p><strong><code>taskStore.tasks</code> 虽然是响应式的，但你只把它的值赋值了一次</strong>，而不是建立一个依赖关系；</p><p>所以后续 <code>tasks</code> 增减变化了，<code>totalTaskCount.value</code> 也不会自动变化。</p><p>所以上述装模做样的定义了一个 <code>totalTaskCount</code> 本质上只是拍了一个快照，等价于：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> snapshot = store.<span class="hljs-property">value</span>.<span class="hljs-property">length</span><br></code></pre></td></tr></table></figure><h2 id="每次渲染时调用"><a href="#每次渲染时调用" class="headerlink" title="每次渲染时调用"></a>每次渲染时调用</h2><p>后续我换成了这样的方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;padding: 2rem&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Taskmate<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">n-space</span> <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;start&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">n-button-group</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">n-button</span> <span class="hljs-attr">round</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;tertiary&quot;</span>&gt;</span><br>          &#123;&#123; getTotalTaskCount() &gt; 0 ? &quot;今日任务总数：&quot; + getTotalTaskCount() : &#x27;当前尚无任务&#x27;&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">n-button</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">n-button-group</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">n-space</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;useTaskStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/taskStore&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> taskStore = <span class="hljs-title function_">useTaskStore</span>()</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTotalTaskCount</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> taskStore?.<span class="hljs-property">tasks</span>?.<span class="hljs-property">length</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样的方式可以解决问题</p><p>本质上其实是<strong>每次渲染都会调用 <code>getTotalTaskCount()</code><strong>，而 <code>taskStore.tasks</code> 是响应式数据，</strong>模板中的函数调用是可以自动响应依赖更新的</strong>。（在 Vue 3 中，模板本质是会被编译为 <code>render()</code> 函数，而 <strong><code>render()</code> 函数内部任何访问到的响应式数据，Vue 都会自动追踪它的依赖</strong>。）</p><p>因此一旦任务变化：</p><ul><li><code>taskStore.tasks</code> 变化被 Vue 侦测到；</li><li>触发响应式更新机制；</li><li>重新调用 <code>render</code>；</li><li>所以按钮上的任务数量就能更新。</li></ul><h2 id="computed最佳实践"><a href="#computed最佳实践" class="headerlink" title="computed最佳实践"></a>computed最佳实践</h2><p>其实最佳实践思路是利用 Vue3 组合式 API 的 computed 函数来实现追踪依赖</p><p>我们现在是希望某个变量能够追踪 taskStore.task 这个响应式状态的，因此可以这么定义</p><p><code>const totalTaskCount = computed(() =&gt; taskStore.tasks.length)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;padding: 2rem&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Taskmate<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">n-space</span> <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;start&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">n-button-group</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">n-button</span> <span class="hljs-attr">round</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;tertiary&quot;</span>&gt;</span><br>          &#123;&#123; totalTaskCount &gt; 0 ? &quot;今日任务总数：&quot; + totalTaskCount : &#x27;当前尚无任务&#x27;&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">n-button</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">n-button-group</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">n-space</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;useTaskStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/taskStore&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> taskStore = <span class="hljs-title function_">useTaskStore</span>()</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> totalTaskCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> taskStore.<span class="hljs-property">tasks</span>.<span class="hljs-property">length</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过这样的写法，当任务变化，<code>totalTaskCount</code> 会自动更新</p><h1 id="循环渲染组件"><a href="#循环渲染组件" class="headerlink" title="循环渲染组件"></a>循环渲染组件</h1><p>在我们首页需要遍历 taskStore 中数组渲染所有任务的时候，这个需求可以很完美的使用 <code>v-for</code> 进行解决</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">n-space</span> <span class="hljs-attr">vertical</span> <span class="hljs-attr">:size</span>=<span class="hljs-string">&quot;16&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin: 1rem 0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">TaskItem</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;task in filteredData&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;task.id&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:task</span>=<span class="hljs-string">&quot;task&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">edit</span>=<span class="hljs-string">&quot;openEdit&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">delete</span>=<span class="hljs-string">&quot;deleteTask&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">n-space</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里 <code>v-for</code> 是用于遍历数组或对象，渲染多个组件</p><p><code>:key</code> 是性能优化和组件 diff 的关键，必须是唯一值（如 <code>task.id</code>）。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript|Generic</title>
    <link href="/2025/06/16/Typescript-Generic/"/>
    <url>/2025/06/16/Typescript-Generic/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>带有类型约束的语言需要泛型(Generic)来实现更加通用、符合标准、可复用的逻辑</p><p>在不使用泛型的时候吗，我们确实是可以用 any 作为函数的入参类型约束，但是这个就和 Object 作为入参以及返回值一样，没有类型限制时，外部在调用这段函数时，无法明确确定入参类型，也无法明确确定返回值类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">identity</span> <span class="hljs-params">(Object arg)</span> &#123;<br>     <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identity</span> (<span class="hljs-attr">arg</span>: <span class="hljs-built_in">any</span>) &#123;<br>     <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以尝试为这个<code>identity</code>函数引入一个Type变量，这个Type变量和常规变量不同，<strong>只作用在类型上而不是js中通常的值上</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> identity&lt;<span class="hljs-title class_">Type</span>&gt; (<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> &#123;<br>     <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对这个函数的签名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> identity&lt;<span class="hljs-title class_">Type</span>&gt; (<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> <br><span class="hljs-comment">//             定义类型变量   入参类型  返回值类型</span><br></code></pre></td></tr></table></figure><p>在函数的签名处定义了作用于类型的Type变量，由于此处只有一个类型变量Type，因此这段函数就是将入参类型和返回值类型都和Type变量类型绑定上</p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>在调用泛型函数时，有两种方式：</p><ul><li>显式声明类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> foo = identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;foo&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>隐式类型推断(更常见)</li></ul><p>编译器根据我们传入的参数类型自动为我们设置 类型变量 <code>Type</code> 的值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> foo = <span class="hljs-title function_">identity</span>(<span class="hljs-string">&quot;foo&quot;</span>)<br></code></pre></td></tr></table></figure><p>这种一般IDE都会在隐式推断计算后（IDE侧）自动将类型标注出来</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>我们可以将这样的泛型函数理解为：</p><p>这个函数不仅接受一个参数arg，<strong>还接受一个类型参数Type</strong></p><p>我们在传入参数的时候会自动将变量类型 和 Type 进行绑定</p><p>我们在函数中可以使用绑定好的类型参数Type，更大程度上提供了灵活性</p><h1 id="泛型函数类型变量"><a href="#泛型函数类型变量" class="headerlink" title="泛型函数类型变量"></a>泛型函数类型变量</h1><h2 id="非泛型函数类型变量"><a href="#非泛型函数类型变量" class="headerlink" title="非泛型函数类型变量"></a>非泛型函数类型变量</h2><p>在了解泛型函数类型的变量定义之前，我们需要对非泛型的函数类型的变量有一定的了解</p><p>例如有这么一个函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们想要将这个函数作为一种类型赋值给一个新的变量，这种没有任何泛型出现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">addFuncVar</span>: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = add;<br></code></pre></td></tr></table></figure><p>这段表达式比较复杂，需要这么理解：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">addFuncVar</span>: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><br><span class="hljs-comment">//变量名       : 类型定义，只不过这个类型是一个函数类型（非泛型）</span><br></code></pre></td></tr></table></figure><p><code>(x: number, y: number) =&gt; number</code> 在 ts 中表示一种函数类型，接收两个 number 作为入参，返回一个 number</p><p>简单来说，非泛型函数类型变量的定义格式就是：</p><p><code>let 函数名: (参数类型列表) =&gt; 返回值类型 = 实际函数;</code></p><h2 id="泛型函数类型变量-1"><a href="#泛型函数类型变量-1" class="headerlink" title="泛型函数类型变量"></a>泛型函数类型变量</h2><p>知道了非泛型的，带泛型的和非泛型的很相似</p><p>例如有这么一个函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> identity&lt;<span class="hljs-title class_">Type</span>&gt;(<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>带有泛型类型的这个函数类型就应该定义为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">genericFuncVar</span>: &lt;<span class="hljs-title class_">Type</span>&gt;<span class="hljs-function">(<span class="hljs-params">arg: Type</span>) =&gt;</span> <span class="hljs-title class_">Type</span> = identity;<br></code></pre></td></tr></table></figure><p>当然这个 <strong>类型变量Type</strong> 名称是随意的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">myIdentity</span>: &lt;<span class="hljs-title class_">Input</span>&gt;<span class="hljs-function">(<span class="hljs-params">arg: Input</span>) =&gt;</span> <span class="hljs-title class_">Input</span> = identity;<br></code></pre></td></tr></table></figure><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><h3 id="定义带泛型函数接口"><a href="#定义带泛型函数接口" class="headerlink" title="定义带泛型函数接口"></a>定义带泛型函数接口</h3><p>上面的代码<code>&lt;Input&gt;(arg: Input) =&gt; Input</code> 就定义了一个函数类型，我们可以将其抽取到一个接口中，这种就是函数接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IdentityFn</span> &#123;<br>     &lt;<span class="hljs-title class_">Input</span>&gt;(<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Input</span>): <span class="hljs-title class_">Input</span> <span class="hljs-comment">//注意最后返回值要用冒号而不是箭头</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后续我们可以直接引用这个函数接口来替代 带有泛型的函数的类型变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">interfaceIdentity</span>: <span class="hljs-title class_">IdentityFn</span> = identity;<br></code></pre></td></tr></table></figure><h3 id="将泛型参数提升至函数接口侧"><a href="#将泛型参数提升至函数接口侧" class="headerlink" title="将泛型参数提升至函数接口侧"></a>将泛型参数提升至函数接口侧</h3><p>在更多的情况下，我们可能会将泛型的声明定义在接口侧</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IdentityFnWithGeneric</span>&lt;<span class="hljs-title class_">Type</span>&gt; &#123;<br>  (<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">interfaceIdentityWithGeneric</span>: <span class="hljs-title class_">IdentityFnWithGeneric</span>&lt;<span class="hljs-built_in">string</span>&gt; = identity;<br></code></pre></td></tr></table></figure><h3 id="两种写法总结对比"><a href="#两种写法总结对比" class="headerlink" title="两种写法总结对比"></a>两种写法总结对比</h3><p><strong>两种写法，区别在于泛型参数究竟是放在函数侧，还是函数接口侧</strong></p><p>直接举个例子更容易理解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> identity&lt;<span class="hljs-title class_">Type</span>&gt;(<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> &#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IdentityFn</span> &#123;<br>  &lt;<span class="hljs-title class_">Input</span>&gt;(<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Input</span>): <span class="hljs-title class_">Input</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">interfaceIdentity</span>: <span class="hljs-title class_">IdentityFn</span> = identity;<br><br><span class="hljs-title function_">interfaceIdentity</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//123可以，泛型会作用于函数</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IdentityFnWithGeneric</span>&lt;<span class="hljs-title class_">Type</span>&gt; &#123;<br>  (<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">interfaceIdentityWithGeneric</span>: <span class="hljs-title class_">IdentityFnWithGeneric</span>&lt;<span class="hljs-built_in">string</span>&gt; = identity;<br><br><span class="hljs-title function_">interfaceIdentityWithGeneric</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// 123 错了，必须传入string类型</span><br></code></pre></td></tr></table></figure><p>在上述代码中，一旦我们定义了 <code>let interfaceIdentityWithGeneric: IdentityFnWithGeneric&lt;string&gt; = identity;</code> 则表示这个新的函数类型变量，在调用的时候只能传入 string 类型的参数，返回的也只会是 string 类型，接口内部所有成员都能共享这个类型参数。</p><p>通过这种方式，可以让使用者在使用接口时明确地指定类型，更加直观</p><table><thead><tr><th>用法场景</th><th>泛型在函数上 <code>&lt;T&gt;(arg: T) =&gt; T</code></th><th>泛型在接口上 <code>interface Foo&lt;T&gt;</code></th></tr></thead><tbody><tr><td>每次调用可能使用不同类型</td><td>✅ 推荐使用</td><td>❌ 不适合</td></tr><tr><td>希望使用时一次性指定固定类型</td><td>❌ 不够清晰</td><td>✅ 推荐使用</td></tr><tr><td>接口内有多个成员都要用这个类型</td><td>❌ 不方便</td><td>✅ 类型统一，语义清晰</td></tr></tbody></table><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p>ts中的class更偏oop一些，但是通过泛型类我们可以更好地理解上面的内容中将泛型提升至接口侧带来的便利性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericNumber</span>&lt;<span class="hljs-title class_">NumberType</span>&gt; &#123;<br>  <span class="hljs-attr">zeroValue</span>: <span class="hljs-title class_">NumberType</span>;<br>  <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">x: NumberType, y: NumberType</span>) =&gt;</span> <span class="hljs-title class_">NumberType</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> genericNumber = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericNumber</span>&lt;<span class="hljs-built_in">number</span>&gt;();<br>genericNumber.<span class="hljs-property">zeroValue</span> = <span class="hljs-number">0</span>;<br>genericNumber.<span class="hljs-property">add</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;<br><br><span class="hljs-keyword">let</span> genericString = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericNumber</span>&lt;<span class="hljs-built_in">string</span>&gt;();<br>genericString.<span class="hljs-property">zeroValue</span> = <span class="hljs-string">&quot;&quot;</span>;<br>genericString.<span class="hljs-property">add</span> = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x.<span class="hljs-title function_">concat</span>(y);<br><br>genericString.<span class="hljs-title function_">add</span>(genericString.<span class="hljs-property">zeroValue</span>, <span class="hljs-string">&quot;test&quot;</span>);<br></code></pre></td></tr></table></figure><p>将类型参数放在类本身上，可以确保类的所有属性都使用相同的类型</p><h1 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h1><p>这一部分其实和别的编程语言也差不太多，我们很多时候希望类型参数绑定的类型并不是表示任何类型，而是有一定的约束</p><p>例如我们希望在函数内部对类型参数的变量调用指定的length字段</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lengthwise</span> &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> logLength&lt;<span class="hljs-title class_">Type</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lengthwise</span>&gt;(<span class="hljs-attr">arg</span>: <span class="hljs-title class_">Type</span>): <span class="hljs-title class_">Type</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>); <span class="hljs-comment">//确保一定会有 length 属性</span><br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果此时我们在外部调用的时候传入了一个不符合约束的类型变量，同样也会报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">logLength</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//TS2345: Argument of type number is not assignable to parameter of type Lengthwise</span><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">logLength</span>(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;); <span class="hljs-comment">//√</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天地創造|第一章 旅行</title>
    <link href="/2025/06/09/%E5%A4%A9%E5%9C%B0%E5%89%B5%E9%80%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%97%85%E8%A1%8C/"/>
    <url>/2025/06/09/%E5%A4%A9%E5%9C%B0%E5%89%B5%E9%80%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%97%85%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>起床後，先去見長老，他就在你左邊的房間，然後去上方的紡織小屋道歉，之後回家用罐子砸開藍色的門進去，一直走到底你會看到一個盒子，打開它放出精靈尤米，瞭解盒子使用方法後與趕來的艾璐交談，艾璐被凍住後再回去與長老交談，得知要救出村人需通過村外五座試煉塔的考驗。（此時可去長老的房間拿到寶箱裡的50 Gems和不可思議球根，以後受傷了也可以來這兒請長老療傷或者乾脆回房睡一覺）　　</p><h1 id="試煉塔1"><a href="#試煉塔1" class="headerlink" title="試煉塔1"></a>試煉塔1</h1><p>寶物 - 不可思議球根，水晶石×3<br>　　<br>村子的左下方就是第一座試煉塔，裡面的敵人不難對付，正好用來熟悉遊戲操作，但你要確定你已經裝備好了武器和防具（水晶之矛可是好東西啊，它能自動回復體力，遺憾的是只在地底世界有效）。<br>第一層：把三個敵人幹掉就會打開通往第二層的道路。<br>第二層：右方有水晶石，幹掉某個敵人後會出現一個靈魂，交談後就會打開<br>通往第三層的道路。<br>第三層：左上方有水晶石，左下方的寶箱裡有不可思議球根，從左下方的窗口出去。<br>第四層：左方有水晶石。<br>第五層：守衛會放出四個紅色的呼波，極易對付。</p><p>歐亞大陸復甦後會直接返回到大地圖，試煉塔2就在左上方。　　</p><h1 id="試煉塔2"><a href="#試煉塔2" class="headerlink" title="試煉塔2"></a>試煉塔2</h1><p>寶物 - 不可思議球根，水晶石×3，30 Gems<br>　　<br>第一層：左下方有水晶石，右下方的寶箱內有30 Gems，推動頭上鑲有紅色寶石的石像即可打開暗門（該層共有兩座這樣的石像，也就是有兩道暗門）。<br>第二層：右下方有水晶石，左下方的寶箱內有不可思議球根，由第一層的兩道暗門上來分別按下兩個紅色按鈕就可打開通往第三層的道路。<br>第三層：共有四個紅色按鈕需要按下，不過左右各有一排石像擋住了去路，幸好左邊這排由左數起的第一座石像以及右邊那排由左數起的第二座石像都可以推動。<br>第四層：左上方有水晶石。將左邊那座頭上鑲有紅色寶石的石像向左推和右邊那座頭上鑲有紅色寶石的石像向右推即可，而推錯方向的話就會出現一群呼波。<br>第五層：用罐子砸中央那個被水圍住的紅色按鈕。</p><p>南美大陸復甦，右上方就是試煉塔3。　　</p><h1 id="試煉塔3"><a href="#試煉塔3" class="headerlink" title="試煉塔3"></a>試煉塔3</h1><p>寶物 - 不可思議球根，水晶石×2，不眠咒符<br>　　<br>塔裡首次出現了守護者，注意不要被他催眠了，否則會回到入口，而且只有滑動攻擊或旋轉攻擊對他有效。<br>第一層：上方的寶箱裡有不可思議球根（雖然看起來好像有牆擋著，其實可以直接穿過去），另外，從右上方的樓梯可以下到地下一層，那兒有水晶石。<br>第二層：按動下方的四個按鈕使對應的踏板成斜線排列就可以過去了。<br>第三層：一直向上走直到切換畫面。在這個畫面左下方的寶箱裡有不眠咒符，可以防止被守護者催眠，右下方則有水晶石，按下上方的兩個紅色按鈕會出現一群呼波，進門後擊敗高級卡多特即可。</p><p>非洲大陸復甦，右方就是試煉塔4。　　</p><h1 id="試煉塔4"><a href="#試煉塔4" class="headerlink" title="試煉塔4"></a>試煉塔4</h1><p>寶物 - 魔法球根，生命之源，44 Gems，水晶織線，水晶石×3<br>　　<br>第一層：由上方跳下<br>地下一層：這兒有四個洞口可以跳，正確道路是從右下方的洞口跳入。<br>a.從其它三個洞口跳下<br>地下二層：由上方的樓梯上去。<br>地下一層：左下方的寶箱裡有44 Gems，右下方有水晶石，由上方的樓梯上去。<br>第一層：由樓梯上去。<br>第二層：左上方的寶箱裡有魔法球根、生命之源，下方有水晶石。<br>b.從右下方的洞口跳下<br>地下二層：由上方的樓梯上去。<br>地下一層：由樓梯上去。<br>第一層：由樓梯上去。<br>第二層：由樓梯上去。<br>第三層：左上方的寶箱裡有水晶織線，右方有水晶石。</p><p>北美大陸復甦，右下方就是試煉塔5。<br>　　<br>不過在去試煉塔5之前應該先回水晶小村，裝備水晶織線後去紡織小屋和艾璐交談，之後去睡一覺（現實中的你可別去睡啊），半夜再去艾璐那兒一次，第二天再去就能得到艾璐的披風，現在可以去試煉塔5了。　　</p><h1 id="試煉塔5"><a href="#試煉塔5" class="headerlink" title="試煉塔5"></a>試煉塔5</h1><p>寶物 - 無<br>　　<br>裝備艾璐的披風後進入，一直上到第五層，走上方的門會落到塔底，所以應該從右邊進入，之後你將面對第一個真正的首領：幽冥衛士。先破壞它的兩隻手臂，再攻擊它的軀體就能獲勝。<br>澳洲大陸復甦，回到水晶小村。<br>不過在回水晶小村之前，還有兩個隱藏地點最好也去一趟：<br>試煉塔3的上方有個隱藏入口可復甦慕大陸；試煉塔4的下方有個隱藏入口可復甦波利尼西亞群島。<br>回到水晶小村與長老交談，之後去出村去右邊的大地裂縫再次與長老交談，回村與艾璐告別，最後再與長老交談一次即可跳下洞口。</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SFC</tag>
      
      <tag>JRPG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3&amp;React|如何理解组合式API和选项式API</title>
    <link href="/2025/06/05/Vue3-React-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BB%84%E5%90%88%E5%BC%8FAPI%E5%92%8C%E9%80%89%E9%A1%B9%E5%BC%8FAPI/"/>
    <url>/2025/06/05/Vue3-React-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BB%84%E5%90%88%E5%BC%8FAPI%E5%92%8C%E9%80%89%E9%A1%B9%E5%BC%8FAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="选项式API"><a href="#选项式API" class="headerlink" title="选项式API"></a>选项式API</h1><p>早在 Vue2 阶段，都是使用的选项式API的风格，之前学习的也是这样的风格。</p><p>在 xxx.vue 文件中，js部分内容大体结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    double() &#123;<br>      return this.count * 2<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    increment() &#123;<br>      this.count++<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>组件会被分为几大部分：data, methods, computed 等核心部分，每个部分约定了会什么样的操作（数据定义、计算逻辑、方法调用等）</p><p>这种方式有利有弊，好处在于结构清晰简单，但是问题在于逻辑相对分散，不利于组件复用</p><h1 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h1><p>React 一直以来都采用的是组合式API的风格，通过定义”函数”并返回JSX（TSX）的方式来定义组件，在JSX（TSX）中通过Hooks组合对应逻辑</p><p>Vue3 开始也引入了组合式API的风格，和React很像，我们直接通过代码来进行学习</p><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>下面以封装一个 <strong>获取鼠标在屏幕的二维坐标位置</strong> 组件为例，展示 React 和 Vue3 中组合式API的实现风格</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ul><li>useState定义状态</li><li>函数组件内部编写更新鼠标位置逻辑</li><li>组件首次渲染时绑定鼠标更新事件</li><li>暴露组件状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs react">import &#123; useState, useEffect &#125; from &#x27;react&#x27;<br><br>export function useMouse() &#123;<br>  const [x, setX] = useState(0)<br>  const [y, setY] = useState(0)<br><br>  useEffect(() =&gt; &#123;<br>    const update = e =&gt; &#123;<br>      setX(e.pageX)<br>      setY(e.pageY)<br>    &#125;<br>    window.addEventListener(&#x27;mousemove&#x27;, update)<br>    return () =&gt; window.removeEventListener(&#x27;mousemove&#x27;, update)<br>  &#125;, [])<br><br>  return &#123; x, y &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs react">import &#123; useMouse &#125; from &#x27;./useMouse&#x27;<br><br>function MouseTracker() &#123;<br>  const &#123; x, y &#125; = useMouse()<br><br>  return &lt;p&gt;Mouse at &#123;x&#125;, &#123;y&#125;&lt;/p&gt;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><ul><li>定义状态</li><li>函数组件中编写更新逻辑</li><li>组件首次渲染时绑定鼠标更新事件</li><li>暴露组件状态</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMouse</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">event</span>) &#123;<br>    x.<span class="hljs-property">value</span> = event.<span class="hljs-property">pageX</span><br>    y.<span class="hljs-property">value</span> = event.<span class="hljs-property">pageY</span><br>  &#125;<br><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update))<br>  <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update))<br><br>  <span class="hljs-keyword">return</span> &#123; x, y &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; useMouse &#125; from &#x27;./useMouse.js&#x27;<br><br>const &#123; x, y &#125; = useMouse()<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;p&gt;Mouse at &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;&lt;/p&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上述代码逻辑我们可以发现：</p><ul><li>React和Vue3的组合式API风格为组件的封装和复用性提供了便利，是重点关注和学习的部分</li><li>Vue2的选项式API实现较为简单，结构清晰但是缺乏复用性</li><li>选项式和组合式没有哪一种更好，对于初学者而言建议学习选项式，但是在实际开发生产用的更多的还是组合式API风格</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript|Basic</title>
    <link href="/2025/05/15/Typescript-Basic/"/>
    <url>/2025/05/15/Typescript-Basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><blockquote><p>TypeScript 的目标是作为 JavaScript 程序的静态类型检查器————换句话说，是一种在代码运行之前运行的工具（静态），并确保程序的类型是正确的（已检查类型）</p></blockquote><p>来看这么一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 访问 message 的 toLowerCase 方法并调用它</span><br>message.<span class="hljs-title function_">toLowerCase</span>();<br><span class="hljs-comment">// 调用 message 函数</span><br><span class="hljs-title function_">message</span>();<br></code></pre></td></tr></table></figure><p>假设 <code>message</code> 是这样定义的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br></code></pre></td></tr></table></figure><p>那么第一行代码可以正常执行，但是第二行就会在运行时报错：<code>TypeError: message is not a function</code></p><p>我们希望不要等到JS运行的时候计算出异常，当然对于JS中的原始数据类型，我们可以使用<code>typeof</code>来得到对应的数据类型，但是函数就不行，看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">flip</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果传入fn函数的入参不是并不支持<code>flip()</code>，那么在调用fn的时候内部也会出现异常，这种方式目前我们并没有一种合理的解决方式</p><p>因此实际上我们希望能在编写代码的时候就能分清楚代码会做什么事情，我们希望引入<code>类型</code>的概念，这里说的<strong>类型</strong>其实就是描述了什么值可以安全传递给 <code>fn</code>，什么值会引起报错</p><p>这个时候我们就可以引入Typescript，他是一个在JS实际运行之前的静态类型检查工具。开发者编写符合ts规范的代码，通过<code>tsc</code>编译得到最终不包含类型的js文件</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>前置需要node，我们可以全局安装<code>typescript</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -g typescript<br></code></pre></td></tr></table></figure><p>但是更推荐在项目中独立安装（可能需要借助 npx 或者类似的工具才能便捷地运行 tsc 指令）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i --save-dev typescript<br></code></pre></td></tr></table></figure><h1 id="类型注解-amp-TSC"><a href="#类型注解-amp-TSC" class="headerlink" title="类型注解&amp;TSC"></a>类型注解&amp;TSC</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greeter</span>(<span class="hljs-params">person</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + person;<br>&#125;<br> <br><span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;Jane User&quot;</span>;<br> <br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">textContent</span> = <span class="hljs-title function_">greeter</span>(user);<br></code></pre></td></tr></table></figure><p>使用TS重写上述JS代码引入类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greeter</span>(<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + person;<br>&#125;<br> <br><span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;Jane User&quot;</span>;<br> <br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">textContent</span> = <span class="hljs-title function_">greeter</span>(user);<br></code></pre></td></tr></table></figure><p>这个时候我们可以通过<code>tsc</code>编译上述ts代码，最终会生成一个js代码，可以发现编译生成的js和原先的js内容一致</p><p>上述greeter函数的入参，我们引入了类型，在TS官方中称其为<code>Type annotations</code></p><p>我们可以修改 user的数据类型，将其改为数字&#x2F;对象&#x2F;数组，在IDE中或者是编译的时候都会给出错误信息，表示类型错误</p><h2 id="对JS迁移的兼容"><a href="#对JS迁移的兼容" class="headerlink" title="对JS迁移的兼容"></a>对JS迁移的兼容</h2><p>我们通过tsc编译写好的ts代码后，如果编译出现错误，实际上可能代码还是可以运行的，报错的时候仍然会产出js文件</p><p>这是因为，例如我们现在正把JS代码迁移到TS代码，并因为历史的原因，在ts的检查约束下产生了很多类型检查错误</p><p>这个时候难道就因为迁移到TS的原因，需要把所有的类型错误都修改吗？毕竟原先代码还是可以跑的、</p><p>因此TS的设计规则就是并不会对实际程序执行产生阻碍（默认配置下），只是起到运行前类型约束的效果</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>TSC编译后生成的JS代码往往可能不是最新ES规范的JS代码，例如字符串模板<code>$&#123;&#125;</code>这样的会被降级重写成字符串拼接的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">`Hello <span class="hljs-subst">$&#123;person&#125;</span>, today is <span class="hljs-subst">$&#123;date.toDateString()&#125;</span>!`</span>;<br><br><span class="hljs-string">&quot;Hello &quot;</span> + person + <span class="hljs-string">&quot;, today is &quot;</span> + date.<span class="hljs-title function_">toDateString</span>() + <span class="hljs-string">&quot;!&quot;</span>;<br></code></pre></td></tr></table></figure><p>在默认情况下，TypeScript 会转化为 ES3 代码，这是一个非常旧的 ECMAScript 版本</p><p>我们可以通过编译器参数<code>--target es2015</code>来指定生成高版本的JS</p><h1 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greeter</span>(<span class="hljs-params">person: Person</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&quot; &quot;</span> + person.<span class="hljs-property">lastName</span>;<br>&#125;<br> <br><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;User&quot;</span> &#125;;<br> <br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">textContent</span> = <span class="hljs-title function_">greeter</span>(user);<br></code></pre></td></tr></table></figure><p>我们使用一个接口来描述具有 firstName 和 lastName 字段的对象</p><p>在 TypeScript 中，如果两个类型的内部结构兼容，则它们是兼容的，因此上述代码中的 user 对象兼容 Person interface，可以作为 greeter 的入参，不需要显式 <code>implements</code></p><h2 id="和Class的区别"><a href="#和Class的区别" class="headerlink" title="和Class的区别"></a>和Class的区别</h2><p>还有一个是<code>class</code>比较容易和这个混淆，简单来说<code>interface</code>主要是定义类型结构，用于类型约束。<code>class</code>更侧重oop，</p><p>前端领域，函数式和组合式 API 更常见（例如 React Hooks、Vue Composition API）</p><p>所以在实际开发中我们一般都是写<code>interface</code>居多</p><p>一般我们都是用interface定义业务对象的数据结构，这个结构可能来自 API 响应</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts">&lt;!-- <span class="hljs-title class_">UserCard</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; defineProps &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 用 interface 定义 props 类型</span></span></span><br><span class="language-javascript"><span class="language-xml">interface <span class="hljs-title class_">User</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">id</span>: number</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: string</span></span><br><span class="language-javascript"><span class="language-xml">  avatarUrl?: string</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 明确标注 props 的结构</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> props = defineProps&lt;&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span></span></span><br><span class="language-javascript"><span class="language-xml">  showAvatar?: boolean</span></span><br><span class="language-javascript"><span class="language-xml">&#125;&gt;()</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;user-card&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showAvatar &amp;&amp; user.avatarUrl&quot;</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;user.avatarUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;avatar&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>请求用户信息，封装用户对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApiResponse</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">data</span>: T<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUser</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ApiResponse</span>&lt;<span class="hljs-title class_">User</span>&gt;&gt; &#123;<br>  <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>登录接口参数约束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoginPayload</span> &#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">payload: LoginPayload</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h1><p>不同的用户会因为不同的原因选择使用 TypeScript 的类型检查器</p><p>1）在 TypeScript 默认提供的开发体验下，类型是可选的，推断会使用最松散的类型，对于潜在的 <code>null/undefined</code> 类型的值也不会进行检查</p><p>2）Typescript 还提供了不同细粒度的检查限制约束</p><p>对于1）如果正在迁移现有的 JavaScript 项目，第一种配置方式是最佳实践</p><p>对于2）需要额外的配置项，我们可以在项目的 <code>tsconfig.json</code> 中设置 <code>strict: true</code> 一次性开启所有严格校验，也可以单独配置；单独配置下需要注意这两个配置项</p><ul><li>noImplicitAny：不允许最宽泛的类型推断，类型都用any &#x3D; 没用ts，启用 <a href="https://www.typescriptlang.org/tsconfig#noImplicitAny">noImplicitAny</a> 配置项，在遇到被隐式推断为 <code>any</code> 类型的变量时就会抛出一个错误。</li><li>strictNullChecks：防止null或者undefined错误</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3|Vue3 Tutorial</title>
    <link href="/2025/04/17/Vue3-Vue3-Tutorial/"/>
    <url>/2025/04/17/Vue3-Vue3-Tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="基础渲染"><a href="#基础渲染" class="headerlink" title="基础渲染"></a>基础渲染</h1><h2 id="响应式ref"><a href="#响应式ref" class="headerlink" title="响应式ref"></a>响应式ref</h2><p>能在改变时触发更新的状态被称作是<strong>响应式</strong>的。我们可以使用 Vue 的 <code>reactive()</code> API 来或者是 <code>ref()</code> API 声明响应式状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">value</span>) <span class="hljs-comment">// &quot;Hello World!&quot;</span><br>message.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;Changed&#x27;</span><br></code></pre></td></tr></table></figure><p>之后在渲染部分，我们使用<strong>双花括号</strong>来将 js 中的逻辑设置到页面上进行展示渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-comment">// 组件逻辑</span></span><br><span class="language-javascript">     <span class="hljs-comment">// 此处声明一些响应式状态</span></span><br><span class="language-javascript">     <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)</span><br><span class="language-javascript">     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">value</span>) <span class="hljs-comment">// &quot;Hello World!&quot;</span></span><br><span class="language-javascript">     message.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;Changed&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意我们在模板中访问的 <code>message</code> ref 时不需要使用 <code>.value</code>：它会被自动解包，让使用更简单。</p></blockquote><p>我们可以简单地理解，想要在JS变量修改的同时也在页面上立即看到变化，我们就需要通过<code>ref()</code>来响应式声明一些组件状态（也可以理解为变量）</p><p>（感觉像是 React 的 useState() </p><h2 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h2><p>在 Vue 中，双大括号只能用于文本插值</p><p>为了给 HTML 的属性绑定一个动态值，需要使用 <code>v-bind</code> 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例如上面的代码，就是将HTML中的id属性，与js变量dynamicId进行绑定</p><p>上面的语法我们可以简写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由此我们可以进行发散，属于HTML元素的任何其他的属性也类似：</p><ul><li><code>:id</code></li><li><code>:class</code></li><li><code>:name</code></li></ul><p>例如下面的代码我们就将一个动态的class与标题进行绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> titleClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;title&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;titleClass&quot;</span>&gt;</span>Make me red<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.title</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们先是声明了一个组件状态 titleClass &#x3D; title，之后通过 v-bind 将 h1 的 class 属性动态地与这个状态绑定</p><p>最终 vue 响应式渲染的结果就是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Make me red<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>这也是很常用的一种语法，例如点击按钮时执行某些逻辑，在Vue中我们用<code>v-on</code>指令监听DOM事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同样地，也可以进行简写，我们使用<code>@</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  count.<span class="hljs-property">value</span>++</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Count is: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> text = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onInput</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">  text.<span class="hljs-property">value</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;onInput&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Type here&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个组件的效果就是在输入框里输入文字，下面的段落会同步更新显示内容</p><p>实际上这里就是将 v-bind 和 v-on 组合使用：</p><ul><li>@input接收原生DOM事件，输入框中最终输入的值，会被作为 onInput 函数的入参</li><li>之后我们在 onInput 中更新 text 的值</li></ul><p>上面的逻辑可以使用 v-model 来等价进行替换</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> text = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Type here&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>使用 v-if</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> awesome = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toggle</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  awesome.<span class="hljs-property">value</span> = !awesome.<span class="hljs-property">value</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggle&quot;</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>Oh no 😢<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="遍历数组列表渲染"><a href="#遍历数组列表渲染" class="headerlink" title="遍历数组列表渲染"></a>遍历数组列表渲染</h2><p>使用 v-for 指令来遍历数组列表进行渲染，这里我们以无序数组为例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setop</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">ref</span>([</span><br><span class="language-javascript">       &#123; <span class="hljs-attr">id</span>: id++, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn HTML&#x27;</span> &#125;,</span><br><span class="language-javascript">       &#123; <span class="hljs-attr">id</span>: id++, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn JavaScript&#x27;</span> &#125;,</span><br><span class="language-javascript">       &#123; <span class="hljs-attr">id</span>: id++, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn Vue&#x27;</span> &#125;</span><br><span class="language-javascript">     ])</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;todo.id&quot;</span>&gt;</span><br>         &#123;&#123; todo.text &#125;&#125;<br>       <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里就表示遍历 todos 数组的每一个元素，每一个元素通过局部变量 todo 来访问</p><p>我们还给每个 todo 对象设置了唯一的 <code>id</code>，并且将它作为特殊的 key 属性绑定到每个 <code>&lt;li&gt;</code> </p><p><code>key</code> 使得 Vue 能够精确地移动每个 <code>&lt;li&gt;</code>，以匹配对应的对象在数组中的位置。</p><p>现在我们通过 vue 的基础指令实现了一个 todo </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 给每个 todo 对象一个唯一的 id</span></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> newTodo = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">ref</span>([</span><br><span class="language-javascript">  &#123; <span class="hljs-attr">id</span>: id++, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn HTML&#x27;</span> &#125;,</span><br><span class="language-javascript">  &#123; <span class="hljs-attr">id</span>: id++, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn JavaScript&#x27;</span> &#125;,</span><br><span class="language-javascript">  &#123; <span class="hljs-attr">id</span>: id++, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn Vue&#x27;</span> &#125;</span><br><span class="language-javascript">])</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTodo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-comment">// 数组新增对象</span></span><br><span class="language-javascript">todos.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">id</span>: id++,</span><br><span class="language-javascript">    <span class="hljs-attr">text</span>: newTodo.<span class="hljs-property">value</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">     newTodo.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeTodo</span>(<span class="hljs-params">todo</span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-comment">//用id进行过滤</span></span><br><span class="language-javascript">  todos.<span class="hljs-property">value</span> = todos.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">ogTodo</span> =&gt;</span> ogTodo.<span class="hljs-property">id</span> !== todo.<span class="hljs-property">id</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;addTodo&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;newTodo&quot;</span> <span class="hljs-attr">required</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;new todo&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Add Todo<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;todo.id&quot;</span>&gt;</span><br>      &#123;&#123; todo.text &#125;&#125;<br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;removeTodo(todo)&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="基于状态计算"><a href="#基于状态计算" class="headerlink" title="基于状态计算"></a>基于状态计算</h2><p>我们在<a href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93">上一步</a>的基础上，给每一个列表元素加了一个字段，并将其通过 v-model 与 vue 状态进行绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     <span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">ref</span>([</span><br><span class="language-javascript">       &#123; <span class="hljs-attr">id</span>: id++, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn HTML&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,</span><br><span class="language-javascript">       &#123; <span class="hljs-attr">id</span>: id++, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn JavaScript&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,</span><br><span class="language-javascript">       &#123; <span class="hljs-attr">id</span>: id++, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Learn Vue&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;</span><br><span class="language-javascript">     ])</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;todo.done&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在我们想要实现隐藏所有 <code>done=true</code> 的元素，也就是<strong>基于状态渲染不同的列表项</strong></p><p>我们可以使用 <code>compute()</code> API，在其中计算真正需要遍历的列表，传给 v-for 进行遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> filteredTodos = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 展示全部</span><br>  <span class="hljs-keyword">if</span>(!hideCompleted.<span class="hljs-property">value</span>)&#123;<br>    <span class="hljs-keyword">return</span> todos.<span class="hljs-property">value</span><br>  &#125;<br>  <span class="hljs-comment">// 隐藏已完成</span><br>  <span class="hljs-keyword">return</span> todos.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">done</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>之后传给 v-for</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- &lt;li v-for=&quot;todo in todos&quot;&gt;</span><br><span class="hljs-addition">+ &lt;li v-for=&quot;todo in filteredTodos&quot;&gt;</span><br></code></pre></td></tr></table></figure><h1 id="生命周期和模板引用"><a href="#生命周期和模板引用" class="headerlink" title="生命周期和模板引用"></a>生命周期和模板引用</h1><p>上述的操作都是vue完成了DOM更新，有的时候我们可能需要手动操作DOM进行更新，这个时候就需要进行模板引用</p><p>我们通过在模板中DOM新增 <code>ref</code>这个属性来实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;pElementRef&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应的我们需要在 script 中声明这个引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pElementRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure><p>这里使用 null 和 React 中的 useRef 差不多，都是在组件初始化的时候 DOM 还未生成，所以要用 null</p><p>说到初始化生命周期，<strong>vue暴露了一些生命周期的钩子，开发者可以直接可以注册一些逻辑 用于组件的指定生命周期</strong></p><p>下面就是在组件初始化的时候修改段落的文本内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> pElementRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">  pElementRef.<span class="hljs-property">value</span>.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;mounted!&#x27;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;pElementRef&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="状态监听器"><a href="#状态监听器" class="headerlink" title="状态监听器"></a>状态监听器</h1><p>由于我们上面实现的效果都是响应式的，有的时候我们希望自定义一些逻辑，当状态变化时执行这些逻辑，我们可以用<code>watch()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-title function_">watch</span>(count, <span class="hljs-function">(<span class="hljs-params">newCount</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`new count is: <span class="hljs-subst">$&#123;newCount&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>watch()</code> 可以直接侦听一个 ref(也就是组件状态)，并且只要 <code>count</code> 的值改变就会触发回调</p><p>下面的逻辑就是当点击按钮触发组件状态 todoId 变更的时候，我们重新调用 fetchData() 逻辑，请求新的数据用于展示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> todoId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> todoData = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  todoData.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<br>    <span class="hljs-string">`https://jsonplaceholder.typicode.com/todos/<span class="hljs-subst">$&#123;todoId.value&#125;</span>`</span><br>  )<br>  todoData.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>()<br>&#125;<br>  <br><span class="hljs-title function_">watch</span>(todoId, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">fetchData</span>();<br>&#125;)<br><br><span class="hljs-title function_">fetchData</span>()<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Todo id: &#123;&#123; todoId &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;todoId++&quot;</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;!todoData&quot;</span>&gt;</span>Fetch next todo<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!todoData&quot;</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">v-else</span>&gt;</span>&#123;&#123; todoData &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="多组件开发"><a href="#多组件开发" class="headerlink" title="多组件开发"></a>多组件开发</h1><h2 id="引入子组件渲染"><a href="#引入子组件渲染" class="headerlink" title="引入子组件渲染"></a>引入子组件渲染</h2><p>这部分逻辑和 React 差不多</p><h2 id="向子组件传递数据"><a href="#向子组件传递数据" class="headerlink" title="向子组件传递数据"></a>向子组件传递数据</h2><p>父子组件数据流向通过 props 进行传递</p><p>这部分声明使用逻辑和 React 略有不同，但也有一些相似之处</p><p>首先我们在子组件中通过 <code>defineProps()</code> 编译时宏定义需要接收的 props</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">msg</span>: <span class="hljs-title class_">String</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>一旦声明，<code>msg</code> prop 就可以在子组件的模板中使用。它也可以通过 <code>defineProps()</code> 所返回的对象在 JS 中访问</p><p>之后我们可以类似地像 React 那样传递 props 到子组件中。但是实际上是通过 v-ind 语法（类似 HTML 的属性）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComp</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComp.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> greeting = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello from parent&#x27;</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ChildComp</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;greeting&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="向父组件传播事件"><a href="#向父组件传播事件" class="headerlink" title="向父组件传播事件"></a>向父组件传播事件</h2><p>很常见的一个场景就是在子组件中执行了某项操作，父组件需要修改对应的状态</p><p>这个时候我们可以通过 <code>emit()</code> API 来实现</p><p>在子组件中通过 <code>emit()</code> 定义<strong>需要暴露的事件</strong>。<code>emit()</code> 的第一个参数是事件的名称。后面的所有参数都将传递给事件监听器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-comment">// 声明触发的事件</span><br><span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;response&#x27;</span>])<br><br><span class="hljs-comment">// 带参数触发</span><br><span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;response&#x27;</span>, <span class="hljs-string">&#x27;hello from child&#x27;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在父组件上，通过 v-on 监听子组件暴露的事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">ChildComp</span> @response=<span class="hljs-string">&quot;(msg) =&gt; childMsg = msg&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h2 id="向子组件传递模板片段"><a href="#向子组件传递模板片段" class="headerlink" title="向子组件传递模板片段"></a>向子组件传递模板片段</h2><p>在引入子组件的时候如果不通过单标签闭合的方式而是用双标签的形式，就会开启slot</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComp</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 下面的所有的template片段都会传递到子组件 --&gt;</span><br>  This is some slot content!<br><span class="hljs-tag">&lt;/<span class="hljs-name">ChildComp</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在子组件中，可以使用 <code>&lt;slot&gt;</code> 元素作为插槽出口 (slot outlet) 渲染父组件中的插槽内容 (slot content)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在子组件的模板中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>子组件的slot如果也是双标签的话，可以在里面设置兜底内容（父组件没有传递任何slot内容时展示）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>Fallback content<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nextjs|App Router</title>
    <link href="/2025/03/28/Nextjs-App-Router/"/>
    <url>/2025/03/28/Nextjs-App-Router/</url>
    
    <content type="html"><![CDATA[<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>按照官方文档提供的最佳实践项目，其目录结构如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npx create-next-app@latest nextjs-dashboard --example <span class="hljs-string">&quot;https://github.com/vercel/next-learn/tree/main/dashboard/starter-example&quot;</span> --use-pnpm<br></code></pre></td></tr></table></figure><ul><li>**<code>/app</code>**：包含应用程序的所有路由、组件和具体实现逻辑，这是项目核心代码</li><li>**<code>/app/lib</code>**：包含应用程序中使用的函数，例如可重用的实用程序函数和数据获取函数</li><li>**<code>/app/ui</code>**：包含应用程序的所有 UI 组件，例如卡片、表格和表单。为了节省时间，我们已为您预先设计了这些组件的样式</li><li>**<code>/public</code>**：包含应用程序的所有静态资产，例如图像</li><li><strong>配置文件</strong>：您还会注意到配置文件，例如位于根目录的<code>next.config.ts</code>文件。大多数此类文件都是在使用<code>create-next-app</code>命令后自动生成和预先配置的，无需在此次开发中修改它们</li></ul><h2 id="Mock数据"><a href="#Mock数据" class="headerlink" title="Mock数据"></a>Mock数据</h2><p>写真前端的时候需要数据，常见的数据占位方式有两种：</p><ul><li>以JS对象的方式写死在代码中</li><li>使用Mock API等第三方服务</li></ul><p>本次我们就使用JS对象的方式进行预定义，具体存放在<code>/app/lib/placeholder-data.ts</code>这个文件中，每一个对象对应数据库的一张表</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p><code>/app/lib/definitions.ts</code>文件手动定义将从数据库返回的数据的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Invoice</span> = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">customer_id</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">amount</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">date</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// In TypeScript, this is called a string union type.</span><br>  <span class="hljs-comment">// It means that the &quot;status&quot; property can only be one of the two strings: &#x27;pending&#x27; or &#x27;paid&#x27;.</span><br>  <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;pending&#x27;</span> | <span class="hljs-string">&#x27;paid&#x27;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样就保证了不会意外地将错误的数据格式传递给组件或数据库，例如针对amount字段不会是String而是number进行传递</p><h1 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h1>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Nextjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nextjs|React and Nextjs</title>
    <link href="/2025/03/28/Nextjs-React-and-Nextjs/"/>
    <url>/2025/03/28/Nextjs-React-and-Nextjs/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-React-和-Nextjs"><a href="#什么是-React-和-Nextjs" class="headerlink" title="什么是 React 和 Nextjs"></a>什么是 React 和 Nextjs</h1><p>在构建现代应用程序时，我们需要考虑一些事。如：</p><ul><li><strong>用户界面</strong> - 用户将如何使用您的应用程序并与之交互。</li><li><strong>路由</strong> - 用户如何在应用程序的不同部分之间导航。</li><li><strong>数据获取</strong> - 数据所在的位置以及如何获取数据。</li><li><strong>渲染</strong> - 渲染静态或动态内容的时间和位置。</li><li><strong>集成</strong> - 使用的第三方服务（用于 CMS、身份验证、支付等）以及如何进行对接。</li><li><strong>基础设施</strong> - 部署、存储和运行应用程序代码（Serverless、CDN等）的地方。</li><li><strong>性能</strong> - 如何为最终用户优化应用程序。</li><li><strong>可扩展性</strong> - 应用程序如何随着团队、数据和流量的增长而适应。</li><li><strong>开发人员体验</strong> - 团队在构建和维护应用程序方面的经验。</li></ul><p>对于应用程序的每个部分，我们需要决定是自己实现解决方案还是使用现成的其他工具，例如包、库和框架。</p><h2 id="简单概括React"><a href="#简单概括React" class="headerlink" title="简单概括React"></a>简单概括React</h2><p>React本身实际上是一个JS库，用于构建UI界面的JS库</p><p>React本身只提供了核心的API，对于如何使用等其他方面并未进行约束，这种方式有好有坏，好处是生态很好，基于React开发的框架和轮子很多。但是坏处就是有点像毛坯房，只提供了构建的基础，还需要额外约定配置路由等</p><p>也正因此，Nextjs就是基于React的、可以为开发者提供快速开发全栈应用程序的<strong>框架</strong></p><h2 id="Nextjs"><a href="#Nextjs" class="headerlink" title="Nextjs"></a>Nextjs</h2><p>框架是指 Next.js 处理 React 所需的工具和配置，并为应用程序提供额外的结构、功能和优化。</p><h1 id="用户界面UI渲染"><a href="#用户界面UI渲染" class="headerlink" title="用户界面UI渲染"></a>用户界面UI渲染</h1><h2 id="HTML和DOM"><a href="#HTML和DOM" class="headerlink" title="HTML和DOM"></a>HTML和DOM</h2><p>当用户访问网页时，服务器会向浏览器返回一个 HTML 文件</p><p>然后，浏览器读取 HTML 并构建文档对象模型 （DOM）</p><p>DOM 是 HTML 元素的对象表示形式。它充当代码和用户界面之间的桥梁，并具有具有父子关系的树状结构</p><p>我们可以通过原生的JS来监听用户事件并通过选择、添加、更新和删除用户界面中的特定元素来操作 DOM</p><p>DOM 操作不仅允许定位特定元素，还可以更改其样式和内容</p><p>至于DOM和HTML的区别，可以简单理解为，HTML可以直接看源代码，但是DOM是渲染JS解析后的完整内容</p><p>例如如下的html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// Select the div element with &#x27;app&#x27; id</span></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> app = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>);</span><br><span class="language-javascript"> </span><br><span class="language-javascript">      <span class="hljs-comment">// Create a new H1 element</span></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> header = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);</span><br><span class="language-javascript"> </span><br><span class="language-javascript">      <span class="hljs-comment">// Create a new text node for the H1 element</span></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;Develop. Preview. Ship.&#x27;</span>;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> headerContent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(text);</span><br><span class="language-javascript"> </span><br><span class="language-javascript">      <span class="hljs-comment">// Append the text to the H1 element</span></span><br><span class="language-javascript">      header.<span class="hljs-title function_">appendChild</span>(headerContent);</span><br><span class="language-javascript"> </span><br><span class="language-javascript">      <span class="hljs-comment">// Place the H1 element inside the div</span></span><br><span class="language-javascript">      app.<span class="hljs-title function_">appendChild</span>(header);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>直接在开发者工具中看到的HTML内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是DOM内容如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Develop, Preview, Ship.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>HTML 表示初始页面内容，而 DOM 表示编写的 JavaScript 代码更改的更新页面内容</p><h2 id="命令式编程和声明式编程"><a href="#命令式编程和声明式编程" class="headerlink" title="命令式编程和声明式编程"></a>命令式编程和声明式编程</h2><p>原生JS虽然很强，但是太冗长了，业务规模增长，维护性也越来越差</p><p>此外上述JS原生写法实际上是一种命令式编程。所有的代码内容都是正在编写<strong>有关如何</strong>更新用户界面的步骤</p><p>但是，在构建用户界面时，通常首选<strong>声明式编程</strong>，因为它可以加快开发过程。如果开发人员能够声明他们想要显示的内容（在本例中是带有一些文本的标签），而不是必须编写 DOM 方法，这将很有帮助。</p><p>换句话说，<strong>命令式编程</strong>就像给厨师分步指导如何制作披萨。<strong>声明式编程</strong>就像订购披萨，而不关心制作披萨所需的步骤。</p><p>React就是一个声明式JS库，作为开发人员，我们告诉 React 希望用户界面发生什么，React 将为我们找出如何更新 DOM 的步骤</p><h1 id="使用组件构建UI"><a href="#使用组件构建UI" class="headerlink" title="使用组件构建UI"></a>使用组件构建UI</h1><p>React 三大核心概念：</p><ul><li>组件</li><li>Props</li><li>state</li></ul><h2 id="使用props"><a href="#使用props" class="headerlink" title="使用props"></a>使用props</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HomePage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;React&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props); <span class="hljs-comment">// 实际上这里不做任何处理的接收 props，默认是一个对象 &#123;title: React&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这也是为什么我们一般都在子组件的入参中加上一对花括号，因为这本质上是在对象解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params">&#123; title &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="运行Nextjs"><a href="#运行Nextjs" class="headerlink" title="运行Nextjs"></a>运行Nextjs</h1><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><p>首先单个页面只能是组件，算不算框架</p><p>我们需要安装依赖</p><ul><li>新建工程目录</li><li>新建package.json，内容写一个空对象即可</li><li>npm install react@latest react-dom@latest next@latest</li></ul><p>运行后应该会自动安装依赖，<code>package.json</code>文件内容应该如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;next&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^15.2.4&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^19.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react-dom&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^19.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="修改页面路由"><a href="#修改页面路由" class="headerlink" title="修改页面路由"></a>修改页面路由</h2><p>将这个demo 放置在 <code>/app</code> 下，命名为<code>page.jsx</code>，所以应该是 <code>/app/page.jsx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params">&#123;title&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title ? title : &#x27;Default title&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HomePage</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> names = [<span class="hljs-string">&#x27;Ada Lovelace&#x27;</span>, <span class="hljs-string">&#x27;Grace Hopper&#x27;</span>, <span class="hljs-string">&#x27;Margaret Hamilton&#x27;</span>];<br><br>    <span class="hljs-keyword">const</span> [likes, setLikes] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">setLikes</span>(likes + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Develop. Preview. Ship.&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">                &#123;names.map((name) =&gt; (</span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                ))&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>Like (&#123;likes&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">HomePage</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>将“next dev”脚本添加到 package.json 文件中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next dev&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;next&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^15.2.4&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^19.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;react-dom&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^19.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>运行 npm run dev</p><p>不出意外的报错了：</p><blockquote><p>Error:   × You’re importing a component that needs <code>useState</code>. This React hook only works in a client component. To fix, mark the file (or its parent) with the <code>&quot;use client&quot;</code> directive.</p></blockquote><p>这是因为 Next.js 使用了 React 服务器组件，这是一项允许 React 在服务器上渲染的新功能</p><p>而服务器组件不支持<code>useState</code>，因此您要改用客户端组件</p><p>这个问题后面会进行修复</p><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>观察到在 app 目录下，自动生成了一个文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> metadata = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Next.js&#x27;</span>,<br>  <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;Generated by Next.js&#x27;</span>,<br>&#125;;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>这是应用程序的主要布局</p><p>我们可以使用它来添加所有页面共享的 UI 元素（例如导航、页脚等）</p><h1 id="服务端组件和客户端组件"><a href="#服务端组件和客户端组件" class="headerlink" title="服务端组件和客户端组件"></a>服务端组件和客户端组件</h1><p>要了解服务器和客户端组件的工作原理，熟悉两个基础 Web 概念会很有帮助：</p><ul><li>应用程序代码可以在其中执行的环境分为两种：服务器和客户端。</li><li>分隔服务器和客户端代码的网络边界。</li></ul><p>客户端和服务端有各自的功能和约束：</p><ul><li>通过将渲染和数据提取移至服务器，您可以减少发送到客户端的代码量，从而提高应用程序的性能</li><li>但是，要使 UI 具有交互性，您需要在客户端上更新 DOM</li></ul><h2 id="使用客户端组件"><a href="#使用客户端组件" class="headerlink" title="使用客户端组件"></a>使用客户端组件</h2><p>Next.js 默认使用服务器组件——这是为了提高应用程序的性能</p><p>回顾浏览器中的错误，Next.js 警告是，我们正在尝试在服务器组件中使用<code>useState</code></p><p>我们可以通过将交互式“赞”按钮移至客户端组件来解决此问题。</p><p>新建一个文件标识点赞的组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;use client&#x27;</span><br><br><span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">LikeButton</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> [likes, setLikes] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">setLikes</span>(likes + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>Like (&#123;likes&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>要创建客户端组件，在文件顶部添加 React指令 <code>&#39;use client&#39;</code>。这告诉 React 在客户端上呈现组件</p><p>默认组件（服务端组件）也需要同步修改，删除 <code>useState</code> 引用，原先声明点赞按钮的地方调整为引入客户端组件即可</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Nextjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch|部署指南</title>
    <link href="/2025/03/07/ElasticSearch-%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/"/>
    <url>/2025/03/07/ElasticSearch-%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h1><h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p>ES默认不允许root身份进行运行，需要先创建对应的用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">adduser elasticsearch<br>passwd elasticsearch<br></code></pre></td></tr></table></figure><p>解压，修改权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> -R elasticsearch-xxx /usr/local/<br><span class="hljs-built_in">chown</span> -R elasticsearch:elasticsearch /usr/local/elasticsearch-xxx/<br></code></pre></td></tr></table></figure><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># ======================== Elasticsearch Configuration =========================</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> Elasticsearch comes with reasonable defaults for most settings.</span><br><span class="hljs-comment">#       Before you set out to tweak and tune the configuration, make sure you</span><br><span class="hljs-comment">#       understand what are you trying to accomplish and the consequences.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The primary way of configuring a node is via this file. This template lists</span><br><span class="hljs-comment"># the most important settings you may want to configure for a production cluster.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Please consult the documentation for further information on configuration options:</span><br><span class="hljs-comment"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ---------------------------------- Cluster -----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Use a descriptive name for your cluster:</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">test-cluster</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ------------------------------------ Node ------------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Use a descriptive name for the node:</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">node.name:</span> <span class="hljs-string">test-node</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Add custom attributes to the node:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#node.attr.rack: r1</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ----------------------------------- Paths ------------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Path to directory where to store the data (separate multiple locations by comma):</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#path.data: /path/to/data</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Path to log files:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#path.logs: /path/to/logs</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ----------------------------------- Memory -----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Lock the memory on startup:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#bootstrap.memory_lock: true</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Make sure that the heap size is set to about half the memory available</span><br><span class="hljs-comment"># on the system and that the owner of the process is allowed to use this</span><br><span class="hljs-comment"># limit.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Elasticsearch performs poorly when the system is swapping the memory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ---------------------------------- Network -----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default Elasticsearch is only accessible on localhost. Set a different</span><br><span class="hljs-comment"># address here to expose this node on the network:</span><br><span class="hljs-comment"># 当前机器的ip绑定</span><br><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default Elasticsearch listens for HTTP traffic on the first free port it</span><br><span class="hljs-comment"># finds starting at 9200. Set a specific HTTP port here:</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">http.port:</span> <span class="hljs-number">9200</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For more information, consult the network module documentation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># --------------------------------- Discovery ----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Pass an initial list of hosts to perform discovery when this node is started:</span><br><span class="hljs-comment"># The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Bootstrap the cluster using an initial set of master-eligible nodes:</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">cluster.initial_master_nodes:</span> [<span class="hljs-string">&quot;test-node&quot;</span>]<br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For more information, consult the discovery and cluster formation module documentation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ---------------------------------- Various -----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Require explicit names when deleting indices:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#action.destructive_requires_name: true</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ---------------------------------- Security ----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#                                 *** WARNING ***</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Elasticsearch security features are not enabled by default.</span><br><span class="hljs-comment"># These features are free, but require configuration changes to enable them.</span><br><span class="hljs-comment"># This means that users don’t have to provide credentials and can get full access</span><br><span class="hljs-comment"># to the cluster. Network connections are also not encrypted.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To protect your data, we strongly encourage you to enable the Elasticsearch security features.</span><br><span class="hljs-comment"># Refer to the following documentation for instructions.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># https://www.elastic.co/guide/en/elasticsearch/reference/7.16/configuring-stack-security.html</span><br></code></pre></td></tr></table></figure><h2 id="修改系统配置"><a href="#修改系统配置" class="headerlink" title="修改系统配置"></a>修改系统配置</h2><p>这里主要是为了调整系统对用户资源的限制，特别是文件描述符（nofile）和进程数（nproc）。这样做主要是为了确保ES能够高效运行，并避免由于默认的资源限制导致运行出现相关问题</p><h3 id="修改-x2F-etc-x2F-security-x2F-limits-conf"><a href="#修改-x2F-etc-x2F-security-x2F-limits-conf" class="headerlink" title="修改 &#x2F;etc&#x2F;security&#x2F;limits.conf"></a>修改 &#x2F;etc&#x2F;security&#x2F;limits.conf</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">* soft nofile <span class="hljs-number">65536</span><br>* hard nofile <span class="hljs-number">65536</span><br>* soft nproc <span class="hljs-number">4096</span><br>* hard nproc <span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure><p>之后退出用户重进方可生效</p><h3 id="修改-x2F-etc-x2F-sysctl-conf"><a href="#修改-x2F-etc-x2F-sysctl-conf" class="headerlink" title="修改&#x2F;etc&#x2F;sysctl.conf"></a>修改&#x2F;etc&#x2F;sysctl.conf</h3><p>在文件的最后一行新增内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vm.max_map_count=655360<br></code></pre></td></tr></table></figure><p>之后刷新一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sysctl -p<br></code></pre></td></tr></table></figure><h2 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">su elasticsearch<br><br><span class="hljs-comment"># 进入 bin 目录</span><br><br><span class="hljs-comment"># 后台启动</span><br>sh elasticsearch  -d<br></code></pre></td></tr></table></figure><h2 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h2><p>访问9200端口如果服务正常应该返回JSON基本参数</p><h2 id="设置用户密码"><a href="#设置用户密码" class="headerlink" title="设置用户密码"></a>设置用户密码</h2><p>ES建议设置用户密码进行访问，如果需要设置用户名密码，需要先 kill 相关进程，之后修改对应配置进行重启</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>首先确保配置文件开启安全认证</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">xpack.security.enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="设置内置用户密码"><a href="#设置内置用户密码" class="headerlink" title="设置内置用户密码"></a>设置内置用户密码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#先停原先进程</span><br><span class="hljs-built_in">kill</span> -9 PID<br><span class="hljs-comment">#启动ES</span><br>sh bin/elasticsearch<br><span class="hljs-comment">#交互设置密码</span><br>sh bin/elasticsearch-setup-passwords interactive<br><span class="hljs-comment">#后台运行</span><br>sh bin/elasticsearch -d<br></code></pre></td></tr></table></figure><p>设置密码后后续所有的API请求都需要传入用户名和密码</p><h1 id="索引结构迁移"><a href="#索引结构迁移" class="headerlink" title="索引结构迁移"></a>索引结构迁移</h1><p>对于某个环境中已有的索引结构，我们希望获取结构定义，然后将其同步到新的环境中</p><h2 id="查询源ES结构"><a href="#查询源ES结构" class="headerlink" title="查询源ES结构"></a>查询源ES结构</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl -u <span class="hljs-string">&quot;username:password&quot;</span> -X GET <span class="hljs-string">&quot;http://ip:9200/index_name/_settings?pretty&quot;</span><br>curl -u <span class="hljs-string">&quot;username:password&quot;</span> -X GET <span class="hljs-string">&quot;http://ip:9200/index_name/_mapping?pretty&quot;</span><br></code></pre></td></tr></table></figure><p>通过API获取源ES的mapping结构（重要），settings根据环境可能存在差异</p><h2 id="同步到新环境"><a href="#同步到新环境" class="headerlink" title="同步到新环境"></a>同步到新环境</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl -u <span class="hljs-string">&quot;username:password&quot;</span> -X PUT <span class="hljs-string">&quot;http://target-es-host:9200/index_name&quot;</span> -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="hljs-string">&#x27;</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;settings&quot;: &#123; /* 从原始索引获取的设置 */ &#125;,</span><br><span class="hljs-string">  &quot;mappings&quot;: &#123; /* 从原始索引获取的映射 */ &#125;</span><br><span class="hljs-string">&#125;&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React|useEffect</title>
    <link href="/2025/03/04/React-useEffect/"/>
    <url>/2025/03/04/React-useEffect/</url>
    
    <content type="html"><![CDATA[<h1 id="声明Effect"><a href="#声明Effect" class="headerlink" title="声明Effect"></a>声明Effect</h1><p>来看一个简单的案例，我们希望实现一个播放视频的组件，通过页面上的按钮点击来控制播放暂停</p><p>video的DOM元素本身并没有这样的功能，只提供了pause和play的函数</p><p>因此我们会进行如下的初步的设计</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">VideoPlayer</span>(<span class="hljs-params">&#123; src, isPlaying &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">if</span> (isPlaying) &#123;<br>    ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">play</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">pause</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;src&#125;</span> <span class="hljs-attr">loop</span> <span class="hljs-attr">playsInline</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的组件中使用到了<code>useRef</code>钩子，这里简单认为我们通过它来获取DOM元素的引用，对video DOM进行操作</p><p>但是上述的实现并不正确</p><ul><li>首先在组件的元素渲染逻辑部分，不应当直接操作DOM</li><li>其次在初次渲染的时候，ref因为还没有走到生成<code>&lt;video&gt;</code>的部分，因此保留了null的默认值。React 在返回 JSX 之前不知道要创建什么样的 DOM，所以没有 DOM 节点可以调用 <code>play()</code> 或 <code>pause()</code> 方法</li></ul><p>这个时候我们可以使用<code>useEffect</code>钩子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">VideoPlayer</span>(<span class="hljs-params">&#123; src, isPlaying &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (isPlaying) &#123;<br>      ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">play</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">pause</span>();<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;src&#125;</span> <span class="hljs-attr">loop</span> <span class="hljs-attr">playsInline</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时组件的渲染顺序为：</p><ul><li>React 会更新页面，确保 <code>&lt;video&gt;</code> 标签带着正确的 props 出现在 DOM 中</li><li>React 将运行 Effect，Effect 将根据 <code>isPlaying</code> 的值调用 <code>play()</code> 或 <code>pause()</code></li></ul><h2 id="Effect的触发时机"><a href="#Effect的触发时机" class="headerlink" title="Effect的触发时机"></a>Effect的触发时机</h2><p>默认情况下，Effect会在组件被渲染后运行</p><p>而我们如果更新组件的state，会触发组件再次进行渲染</p><p>因此下列的代码是死循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//组件每次渲染结束后执行</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">//更新state，再次触发组件渲染   </span><br>  <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="设置Effect依赖项"><a href="#设置Effect依赖项" class="headerlink" title="设置Effect依赖项"></a>设置Effect依赖项</h1><p><a href="#Effect%E7%9A%84%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA">上面</a>提到了，上述声明的Effect默认是在每一次组件渲染后都会被执行</p><p>但是有的时候我们Effect并不希望在每一次渲染后就执行：</p><ul><li>服务器连接，不能多建立，只希望组件第一次渲染的时候才建立</li><li>组件中其他修改state的行为不应该重新导致Effect执行</li></ul><p>来看下面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">VideoPlayer</span>(<span class="hljs-params">&#123; src, isPlaying &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (isPlaying) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用 video.play()&#x27;</span>);<br>      ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">play</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用 video.pause()&#x27;</span>);<br>      ref.<span class="hljs-property">current</span>.<span class="hljs-title function_">pause</span>();<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;src&#125;</span> <span class="hljs-attr">loop</span> <span class="hljs-attr">playsInline</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [isPlaying, setIsPlaying] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">const</span> [text, setText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;text&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setText(e.target.value)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setIsPlaying(!isPlaying)&#125;&gt;</span><br><span class="language-xml">        &#123;isPlaying ? &#x27;暂停&#x27; : &#x27;播放&#x27;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">VideoPlayer</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">isPlaying</span>=<span class="hljs-string">&#123;isPlaying&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>我们多加了一个<code>  const [text, setText] = useState(&#39;&#39;);</code></p><p>这就导致我们每次修改文本框的内容，都会触发一次setText，导致state更新，导致组件重新渲染，最终导致Effect被运行</p><p>这时候我们可以通过指定Effect的依赖项来解决这一问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs react">//只要组件渲染就都会调用<br>useEffect(() =&gt; &#123;<br>     //do something<br>&#125;);<br><br>//只有组件第一次渲染（也叫挂载）的时候才会调用<br>useEffect(() =&gt; &#123;<br>     //do something<br>&#125;, []);<br><br>//只要a或者b发生了变化的时候就会调用<br>useEffect(() =&gt; &#123;<br>     //do something<br>&#125;, [a,b]);<br></code></pre></td></tr></table></figure><h1 id="cleanup函数"><a href="#cleanup函数" class="headerlink" title="cleanup函数"></a>cleanup函数</h1><p><a href="#%E8%AE%BE%E7%BD%AEEffect%E4%BE%9D%E8%B5%96%E9%A1%B9">上面</a>我们提到了，建立连接的场景可能也会需要为Effect设置依赖项。假如我们正在编写一个 <code>ChatRoom</code> 组件，该组件在显示时需要连接到聊天服务器。现在为你提供了 <code>createConnection()</code> API，该 API 返回一个包含 <code>connect()</code> 与 <code>disconnection()</code> 方法的对象。如何确保组件在显示时始终保持连接？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> connection = <span class="hljs-title function_">createConnection</span>();<br>  connection.<span class="hljs-title function_">connect</span>();<br>&#125;, [])<br></code></pre></td></tr></table></figure><p>这样虽然实现了只会在组件第一次渲染也就是挂载的时候建立连接，但是存在关键问题，如果切换页面，组件再次第一次渲染的时候，就会创建第二个连接</p><p>我们需要在 useEffect 中实现类似 <code>finally</code> 块的效果，在组件卸载（被移除）时最后一次调用，或者在每次 Effect 重新运行的时候调用</p><p>这个时候我们就需要使用 useEffect 提供的 cleanUp 函数，写法就是进行一个 return </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> connection = <span class="hljs-title function_">createConnection</span>();<br>  connection.<span class="hljs-title function_">connect</span>();<br>  <span class="hljs-comment">//cleanup   </span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> connection.<span class="hljs-title function_">disconnection</span>();<br>&#125;, [])<br></code></pre></td></tr></table></figure><blockquote><p>值得注意的是，在开发模式下，默认React会针对所有的Effect在第一次渲染后再调用一次渲染，目的就是为了<strong>及时发现在Effect主函数体中申请了资源但是没有cleanUp的bug</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript|解构赋值</title>
    <link href="/2025/03/03/JavaScript-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <url>/2025/03/03/JavaScript-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>JS中最常使用的数据类型是对象以及数组</p><p>但是有的时候我们实际上并不需要一个对象中所有的字段，或者说数组中所有的数据</p><p>因此ES6中引入了解构赋值这一操作来<strong>将对象或者数组拆解结构并赋值到新的多个变量上</strong></p><h1 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h1><h2 id="基本声明"><a href="#基本声明" class="headerlink" title="基本声明"></a>基本声明</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [firstName, surName] = <span class="hljs-string">&#x27;John Smith&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [firstName, surName] = [<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Smith&#x27;</span>];<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Smith&#x27;</span>];<br><span class="hljs-keyword">let</span> firstName = arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> surName = arr[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>以上三种形式效果等价，前两种就是数组的解构赋值</p><h2 id="忽略元素"><a href="#忽略元素" class="headerlink" title="忽略元素"></a>忽略元素</h2><p>可以在等号左边通过逗号来忽略元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a,,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-title function_">alert</span>(c); <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><h2 id="等号右侧适用于任何可迭代的数组"><a href="#等号右侧适用于任何可迭代的数组" class="headerlink" title="等号右侧适用于任何可迭代的数组"></a>等号右侧适用于任何可迭代的数组</h2><p>数组解构可以解构通用的数组，但并不局限，也可以解构任何可迭代的数组，例如字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a,b,c] = <span class="hljs-string">&quot;123&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="等号左侧适用于任何可赋值的元素"><a href="#等号左侧适用于任何可赋值的元素" class="headerlink" title="等号左侧适用于任何可赋值的元素"></a>等号左侧适用于任何可赋值的元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br>[user.<span class="hljs-property">firstName</span>, user.<span class="hljs-property">surName</span>] = <span class="hljs-string">&#x27;John Smith&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="获取数组剩下的元素"><a href="#获取数组剩下的元素" class="headerlink" title="获取数组剩下的元素"></a>获取数组剩下的元素</h2><p>通常我们想要的数据远比对象&#x2F;数组本身提供的少，我们可以通过<code>...</code>的方式来收集剩余的项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [name1, name2, ...rest] = [<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>, <span class="hljs-string">&quot;Consul&quot;</span>, <span class="hljs-string">&quot;of the Roman Republic&quot;</span>];<br><span class="hljs-comment">// rest 是包含从第三项开始的其余数组项的数组</span><br><span class="hljs-title function_">alert</span>(rest[<span class="hljs-number">0</span>]); <span class="hljs-comment">// Consul</span><br><span class="hljs-title function_">alert</span>(rest[<span class="hljs-number">1</span>]); <span class="hljs-comment">// of the Roman Republic</span><br><span class="hljs-title function_">alert</span>(rest.<span class="hljs-property">length</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>一般是左边更短右边更长</p><p>如果左边更长的话不会报错，只是未被按顺序赋值到的元素都是<code>undefined</code></p><p>我们可以通过在解构赋值的表达式中定义等号来声明默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [foo, bar = <span class="hljs-string">&#x27;default bar&#x27;</span>] = [<span class="hljs-string">&quot;foo&quot;</span>];<br></code></pre></td></tr></table></figure><h1 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h1><p>对象解构的方式比较直接，就是将需要的对象key单独声明在左边列表即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> options = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">200</span><br>&#125;<br><br><span class="hljs-keyword">let</span> &#123;title, width, height&#125; = options;<br></code></pre></td></tr></table></figure><p>在左侧被赋值的变量上起别名也是可以的，通过冒号声明，冒号的语法是<strong>“从对象中什么属性的值：赋值给哪个变量”</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">title</span>:t, <span class="hljs-attr">width</span>:w, <span class="hljs-attr">height</span>:h&#125; = options;<br></code></pre></td></tr></table></figure><p>类似数组解构，如果可能缺失的值，也可以通过等号进行默认值填充</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">title</span>:t, <span class="hljs-attr">width</span>:w, <span class="hljs-attr">height</span>:h, number = <span class="hljs-number">10</span>&#125; = options;<br></code></pre></td></tr></table></figure><p>同样也支持<code>...</code>将剩余的数据收集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;title, ...rest&#125; = options;<br></code></pre></td></tr></table></figure><h2 id="对象解构时使用已有变量的问题"><a href="#对象解构时使用已有变量的问题" class="headerlink" title="对象解构时使用已有变量的问题"></a>对象解构时使用已有变量的问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> title, width, height;<br><br><span class="hljs-comment">// 这一行发生了错误</span><br>&#123;title, width, height&#125; = &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>&#125;;<br></code></pre></td></tr></table></figure><p>由于对象解构采用的是<code>&#123;&#125;</code>，因此上述的声明会被js误认为是一段代码块</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>     title<span class="hljs-punctuation">,</span><br>     width<span class="hljs-punctuation">,</span><br>     height     <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>显然这种声明是非法的</p><p>为了不让js误判代码块，让他知道我们这是对象解构复用已有变量，需要多包上一层小括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">(&#123;title, width, height&#125; = &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>&#125;);<br></code></pre></td></tr></table></figure><h1 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h1><p>本质上可以看作是对象解构和数组解构的综合运用</p><p>只要让等式左边和右边数据类型对应上即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> options = &#123;<br>  <span class="hljs-attr">size</span>: &#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">200</span><br>  &#125;,<br>  <span class="hljs-attr">items</span>: [<span class="hljs-string">&quot;Cake&quot;</span>, <span class="hljs-string">&quot;Donut&quot;</span>],<br>  <span class="hljs-attr">extra</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123;<br>  <span class="hljs-attr">size</span>: &#123; <span class="hljs-comment">// 把 size 赋值到这里</span><br>    width,<br>    height<br>  &#125;,<br>  <span class="hljs-attr">items</span>: [item1, item2], <span class="hljs-comment">// 把 items 赋值到这里</span><br>  title = <span class="hljs-string">&quot;Menu&quot;</span> <span class="hljs-comment">// 在对象中不存在（使用默认值）</span><br>&#125; = options;<br><br><span class="hljs-title function_">alert</span>(title);  <span class="hljs-comment">// Menu</span><br><span class="hljs-title function_">alert</span>(width);  <span class="hljs-comment">// 100</span><br><span class="hljs-title function_">alert</span>(height); <span class="hljs-comment">// 200</span><br><span class="hljs-title function_">alert</span>(item1);  <span class="hljs-comment">// Cake</span><br><span class="hljs-title function_">alert</span>(item2);  <span class="hljs-comment">// Donut</span><br></code></pre></td></tr></table></figure><h1 id="函数入参解构赋值"><a href="#函数入参解构赋值" class="headerlink" title="函数入参解构赋值"></a>函数入参解构赋值</h1><p>有的时候我们的函数入参可能不需要那么多，大部分参数是可选的，也就是不需要手动传入</p><p>换成别的语言可能会这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showMenu</span>(<span class="hljs-params">title = <span class="hljs-string">&quot;Untitled&quot;</span>, width = <span class="hljs-number">200</span>, height = <span class="hljs-number">100</span>, items = []</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">showMenu</span>(<span class="hljs-string">&quot;My Menu&quot;</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, [<span class="hljs-string">&quot;Item1&quot;</span>, <span class="hljs-string">&quot;Item2&quot;</span>])<br></code></pre></td></tr></table></figure><p>这种方式可行，但是代码有点差</p><p>我们可以<strong>使用对象作为函数入参，函数签名处使用解构赋值，拆分对象属性，自动定义变量以及默认值，在函数体内直接单独挑出来使用</strong>，可以完美解决上述问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> params = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Menu&#x27;</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>,<br>  &#125;;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">showMenu</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">    title = <span class="hljs-string">&#x27;Untitled&#x27;</span>,</span><br><span class="hljs-params">    width = <span class="hljs-number">200</span>,</span><br><span class="hljs-params">    height = <span class="hljs-number">100</span>,</span><br><span class="hljs-params">    items = [],</span><br><span class="hljs-params">  &#125;</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;title&#125;</span> <span class="hljs-subst">$&#123;width&#125;</span> <span class="hljs-subst">$&#123;height&#125;</span>`</span>); <span class="hljs-comment">// My Menu 200 100</span><br>  &#125;<br><br>  <span class="hljs-title function_">showMenu</span>(params);<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，由于items没有被指定，因此就是使用的默认值空数组，剩下的都将根据真实值传递而非使用默认值</p><p>但是这样还有一个问题，就是如果我们都直接打算使用默认值，不能不定义，一定要手动传入一个空对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">showMenu</span>(&#123;&#125;);<br></code></pre></td></tr></table></figure><p>为了避免这种冗余的声明，我们可以在函数参数声明的地方定义默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">let</span> params = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Menu&#x27;</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>,<br>  &#125;;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">showMenu</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">    title = <span class="hljs-string">&#x27;Untitled&#x27;</span>,</span><br><span class="hljs-params">    width = <span class="hljs-number">200</span>,</span><br><span class="hljs-params">    height = <span class="hljs-number">100</span>,</span><br><span class="hljs-params">    items = [],</span><br><span class="hljs-params">  &#125; = &#123;&#125;</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;title&#125;</span> <span class="hljs-subst">$&#123;width&#125;</span> <span class="hljs-subst">$&#123;height&#125;</span>`</span>); <span class="hljs-comment">// My Menu 200 100</span><br>  &#125;<br><br>  <span class="hljs-title function_">showMenu</span>(params);<br>  <span class="hljs-comment">//全部使用默认值</span><br>  <span class="hljs-title function_">showMenu</span>();   <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript|async/await</title>
    <link href="/2025/02/25/JavaScript-async-await/"/>
    <url>/2025/02/25/JavaScript-async-await/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Promise等价"><a href="#Promise等价" class="headerlink" title="Promise等价"></a>Promise等价</h2><p>async 关键字声明的函数本质上就是隐式返回了一个Promise，并将结果值作为 resolve 的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newPromiseEquivalent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Future-get"><a href="#Future-get" class="headerlink" title="Future.get"></a>Future.get</h2><p>在 async 声明的函数中定义 await，等价于我们针对Promise的异步操作声明后，同步阻塞调用了一次get(<strong>类似Java语言中Future的get()</strong>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sleepAndWaitOneSec</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> pro = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;sleep done&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> pro; <span class="hljs-comment">//同步阻塞</span><br>  <span class="hljs-title function_">alert</span>(res);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们可以简单理解为，<code>await</code> 是获取Promise结果的一个等同于<code>then</code> 处理程序的一个简洁形式</p><p>例如原先<a href="https://trevorlink.github.io/2025/02/21/JavaScript-Promise/#%E5%BC%82%E6%AD%A5%E8%A1%8C%E4%B8%BA%E5%BA%94%E5%BD%93%E5%A7%8B%E7%BB%88%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAPromise">展示图片案例</a>的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showImage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;./foo.json&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://avatars.githubusercontent.com/<span class="hljs-subst">$&#123;user.name&#125;</span>`</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function">(<span class="hljs-params">githubUser</span>) =&gt;</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>);<br>          img.<span class="hljs-property">src</span> = githubUser.<span class="hljs-property">avatar_url</span>;<br>          img.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;promise-avatar-example&#x27;</span>;<br>          <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(img);<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            img.<span class="hljs-title function_">remove</span>();<br>            <span class="hljs-title function_">resolve</span>(githubUser);<br>          &#125;, <span class="hljs-number">3000</span>);<br>        &#125;),<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>可以重构为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">showImageAsync</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//当远程服务器返回 header（是在全部响应加载完成前）时，该 promise 使用一个 response 对象来进行 resolve</span><br>  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;./foo.json&quot;</span>);<br>  <span class="hljs-comment">//当全部文字内容从远程服务器下载完成后，它会返回一个 promise</span><br>  <span class="hljs-keyword">let</span> user = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br><br>  <span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`http://avatars.githubusercontent.com/<span class="hljs-subst">$&#123;user.name&#125;</span>`</span>);<br>  <span class="hljs-keyword">let</span> githubUser = <span class="hljs-keyword">await</span> resp.<span class="hljs-title function_">json</span>();<br><br>  <span class="hljs-keyword">let</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>);<br>  img.<span class="hljs-property">src</span> = githubUser.<span class="hljs-property">avatar_url</span>;<br>  img.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;promise-avatar-example&#x27;</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(img);<br><br>  <span class="hljs-comment">//同步阻塞</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>()<br>    &#125;, <span class="hljs-number">3000</span>)<br>  &#125;);<br>  <span class="hljs-comment">//时间到了之后删除</span><br>  img.<span class="hljs-title function_">remove</span>();<br>  <span class="hljs-comment">//异步函数应当始终返回Promise</span><br>  <span class="hljs-keyword">return</span> githubUser;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>如果 await 的 promise 出现了异常，我们可以使用 catch 块来进行捕获</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">errorPromise</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;no-such-url&#x27;</span>);<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-title function_">alert</span>(err);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>需要注意区分这种的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Fatal error&#x27;</span>)).<span class="hljs-title function_">catch</span>(alert)<br></code></pre></td></tr></table></figure><p>写法不同但是效果相同，一般我们在使用<code>async/await</code>的时候都基本不会再去使用<code>.then()</code>或者是<code>.catch()</code>，一般都是直接变量接收，然后配合catch块来进行使用</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了 <code>async/await</code> 之后，我们就几乎不需要使用 <code>promise.then/catch</code>，但是不要忘了它们是基于 promise 的，因为有些时候（例如在最外层作用域）我们不得不使用这些方法</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript|Promise</title>
    <link href="/2025/02/21/JavaScript-Promise/"/>
    <url>/2025/02/21/JavaScript-Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h1><h2 id="基于回调的异步风格"><a href="#基于回调的异步风格" class="headerlink" title="基于回调的异步风格"></a>基于回调的异步风格</h2><p>一个简单的demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src, callback</span>) &#123;<br>     <span class="hljs-comment">//创建脚本</span><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br><span class="hljs-comment">//设置js标签的src属性</span><br>     script.<span class="hljs-property">src</span> = src;<br>     <span class="hljs-comment">//设置回调函数</span><br>     script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(script);<br>     <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script)<br>&#125;<br></code></pre></td></tr></table></figure><p>之后函数调用方，将函数的回调方式作为参数传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js&#x27;</span>, <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> &#123;<br>     <span class="hljs-title function_">alert</span>(<span class="hljs-string">`脚本：<span class="hljs-subst">$&#123;script.src&#125;</span>加载完成`</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的demo就是采用JS实现的基于回调的异步编程风格</p><p>异步执行某项功能的函数应该提供一个 <code>callback</code> 参数用于在相应事件完成时调用</p><h2 id="Error优先回调风格"><a href="#Error优先回调风格" class="headerlink" title="Error优先回调风格"></a>Error优先回调风格</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src, callback</span>) &#123;<br>     <span class="hljs-comment">//创建脚本</span><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br><span class="hljs-comment">//设置js标签的src属性</span><br>     script.<span class="hljs-property">src</span> = src;<br>     <span class="hljs-comment">//设置回调函数</span><br>     script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, script);<br>     <span class="hljs-comment">//设置错误的回调</span><br>     script.<span class="hljs-property">onError</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Script load error for script <span class="hljs-subst">$&#123;src&#125;</span>`</span>));<br>     <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script)<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在调用方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./foo.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, script</span>) &#123;<br>     <span class="hljs-keyword">if</span>(err)&#123;<br>          <span class="hljs-comment">//Error对应处理逻辑</span><br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">alert</span>(<span class="hljs-string">`脚本：<span class="hljs-subst">$&#123;script.src&#125;</span>加载完成`</span>)<br>     &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的方式则是Error优先的回调风格</p><h1 id="Promise基础介绍"><a href="#Promise基础介绍" class="headerlink" title="Promise基础介绍"></a>Promise基础介绍</h1><h2 id="引入Promise"><a href="#引入Promise" class="headerlink" title="引入Promise"></a>引入Promise</h2><p>现在对于上述加载某个脚本的代码，我想要实现加载完某个脚本之后，再按顺序加载第二个脚本，那么在调用方，对应的代码就会变成如下的样子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./foo.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, script</span>) &#123;<br>     <span class="hljs-keyword">if</span> (error) &#123;<br>         <span class="hljs-title function_">handleError</span>(error);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./bar.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, scirpt</span>) &#123;<br>               <span class="hljs-comment">//...</span><br>          &#125;);<br>      &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>所以如果有这样的需求，原先的代码编写方式将会很臃肿而且可读性依托</p><p>JS 提供了 promise 的方式来进行优化</p><h2 id="声明promise"><a href="#声明promise" class="headerlink" title="声明promise"></a>声明promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>     <span class="hljs-comment">//executor</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>这里的 resolve 和 reject 是 JS 自带的函数，不需要关注，直接当接口使用</p><p><code>resolve/reject</code> 只需要一个参数（或不包含任何参数），并且将忽略额外的参数。</p><h2 id="promise对象属性"><a href="#promise对象属性" class="headerlink" title="promise对象属性"></a>promise对象属性</h2><p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 对象具有以下内部属性：</p><ul><li><code>state</code> —— 最初是 <code>&quot;pending&quot;</code>，然后在 <code>resolve</code> 被调用时变为 <code>&quot;fulfilled&quot;</code>，或者在 <code>reject</code> 被调用时变为 <code>&quot;rejected&quot;</code>。</li><li><code>result</code> —— 最初是 <code>undefined</code>，然后在 <code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li></ul><p>因此，executor 应该执行一项工作（通常是需要花费一些时间的事儿），然后调用 <code>resolve</code> 或 <code>reject</code> 来改变对应的 promise 对象的状态。</p><h1 id="Promise核心组成"><a href="#Promise核心组成" class="headerlink" title="Promise核心组成"></a>Promise核心组成</h1><h2 id="executor生产者定义"><a href="#executor生产者定义" class="headerlink" title="executor生产者定义"></a>executor生产者定义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//do something</span><br>  <span class="hljs-title function_">foo</span>();<br>  <span class="hljs-title function_">bar</span>();<br>  <span class="hljs-comment">//End with resolve()/reject()</span><br>  <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Failed&#x27;</span>));<br>&#125;);<br></code></pre></td></tr></table></figure><p>如上代码，如果在 exector 中执行出了问题，executor 应该调用 <code>reject</code>。这可以使用任何类型的参数来完成（就像 <code>resolve</code> 一样）。但建议使用 <code>Error</code> 对象（或继承自 <code>Error</code> 的对象），因为可以给 catch 在下游进行捕获（下面会介绍）</p><p>并且从生产——消费的模型角度来看，我们定义的promise和executor其实是定义了一个生产者，promise作为”消息队列”进行连接</p><h2 id="处理程序"><a href="#处理程序" class="headerlink" title="处理程序"></a>处理程序</h2><h3 id="then、catch"><a href="#then、catch" class="headerlink" title="then、catch"></a>then、catch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//do something</span><br>  <span class="hljs-title function_">foo</span>();<br>  <span class="hljs-title function_">bar</span>();<br>  <span class="hljs-comment">//End with resolve()/reject()</span><br>  <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Failed&#x27;</span>));<br>&#125;);<br><br>promise.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(result);<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(error);<br>  &#125;,<br>);<br></code></pre></td></tr></table></figure><p>then中定义了当resolve和reject的时候分别需要做什么</p><p>例如如下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;done&quot;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<br><span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">alert</span>(result), <span class="hljs-comment">//显示done</span><br><span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">altet</span>(error)  <span class="hljs-comment">//不会运行</span><br>);<br></code></pre></td></tr></table></figure><p>如果我们只对成功的情况感兴趣，可以只调用<code>then()</code>的时候只传入一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;done&quot;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(alert);<br></code></pre></td></tr></table></figure><p>如果只对失败的情况感兴趣，可以直接调用<code>catch</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()), <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-comment">//只关注失败的情况，等价于 promise.then(null, alert)</span><br>promise.<span class="hljs-title function_">catch</span>(alert);<br></code></pre></td></tr></table></figure><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>finally(f) 类似于 <code>then(f,f)</code>，表示同时将函数f运用到resolve和reject场景下</p><p>但是需要注意的是他的核心功能是设置一个处理程序在前面的操作完成之后，执行对应的<strong>不包含任何非异常返回值的操作</strong></p><p>常见的场景有：</p><ul><li>停止加载指示器</li><li>关闭不再需要的连接</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">bar</span>();<br>&#125;)<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> stop loading indicator)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> show result, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> show error);<br></code></pre></td></tr></table></figure><p>可以看到，使用finally的时候：</p><ul><li>不接受参数，这就意味着finally不会得到前一个Promise处理程序的结果，反倒是会将结果或 error “传递” 给下一个合适的处理程序</li><li>也不会返回任何内容，除了在处理这一步的的时候出现Error</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br>    &#125;, <span class="hljs-number">2000</span>,<br>  );<br>&#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Promise finally ready&#x27;</span>))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">alert</span>(result));<br></code></pre></td></tr></table></figure><h1 id="Promise-amp-异步回调对比"><a href="#Promise-amp-异步回调对比" class="headerlink" title="Promise&amp;异步回调对比"></a>Promise&amp;异步回调对比</h1><p>回到之前加载脚本的例子</p><ul><li>使用朴素异步回调方式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src, callback</span>) &#123;<br>     <span class="hljs-comment">//创建脚本</span><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br><span class="hljs-comment">//设置js标签的src属性</span><br>     script.<span class="hljs-property">src</span> = src;<br>     <span class="hljs-comment">//设置回调函数</span><br>     script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, script);<br>     <span class="hljs-comment">//设置错误的回调</span><br>     script.<span class="hljs-property">onError</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Script load error for script <span class="hljs-subst">$&#123;src&#125;</span>`</span>));<br>     <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script)<br>&#125;<br><br><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./foo.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, script</span>) &#123;<br>     <span class="hljs-keyword">if</span>(err)&#123;<br>          <span class="hljs-comment">//Error对应处理逻辑</span><br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">alert</span>(<span class="hljs-string">`脚本：<span class="hljs-subst">$&#123;script.src&#125;</span>加载完成`</span>)<br>     &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们发现，在调用loadscript的时候，需要指定callback，也就是在调用之前，我们必须知道应该如何处理结果，对应上面的匿名函数<code>function(err, script)</code></p><ul><li>使用Promise方式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    script.<span class="hljs-property">src</span> = src;<br><br>    script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Script loaded successfully&#x27;</span>);<br>    script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Script <span class="hljs-subst">$&#123;src&#125;</span> loaded error`</span>));<br><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script)<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">let</span> promise = <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js&quot;</span>);<br>promise.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">alert</span>(result),<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">alert</span>(error)<br>);<br><br></code></pre></td></tr></table></figure><p>我们可以按照自然方式进行编码，运行<code>loadscript</code>之后，通过then来进行处理，也就是<strong>将异步任务发布，和任务消费进行解耦</strong></p><p>我们可以根据需要，在 promise 上多次调用 <code>.then</code>。每次调用，我们都会在“订阅列表”中添加一个新的“粉丝”，一个新的订阅函数。</p><h1 id="Promise链"><a href="#Promise链" class="headerlink" title="Promise链"></a>Promise链</h1><h2 id="处理程序链式调用"><a href="#处理程序链式调用" class="headerlink" title="处理程序链式调用"></a>处理程序链式调用</h2><p>通过上述的语法不难发现，<code>catch finally then</code> 都是支持链式调用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">//1</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>  &#125;);<br></code></pre></td></tr></table></figure><p>这样之所以是可行的，是因为每个对 <code>.then</code> 的调用都会<strong>返回了一个新的 promise</strong>，因此我们可以在其之上调用下一个 <code>.then</code></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250225093955717.png"></p><p>下面这种不是promise链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);<br>&#125;);<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>&#125;);<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>&#125;);<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">// 1</span><br>  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250225093926052.png"></p><h2 id="在处理程序中返回”Promise”"><a href="#在处理程序中返回”Promise”" class="headerlink" title="在处理程序中返回”Promise”"></a>在处理程序中返回”Promise”</h2><p>上面我们的处理程序只是简单计算返回结果</p><p>我们也可以在处理程序中再次返回promise，这种方式下，后续所有的其他处理程序都会阻塞等待，直到返回的promise状态为settled后再执行对应逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">//1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(result * <span class="hljs-number">2</span>);<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(result * <span class="hljs-number">2</span>);<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(result); <span class="hljs-comment">//4</span><br>  &#125;);<br></code></pre></td></tr></table></figure><blockquote><p>其实从严格角度来说，then中返回的不是Promise对象，而是<code>thenable</code>对象，这个对象也具有<code>.then</code>处理程序，它会被当做一个 promise 来对待</p></blockquote><p>下面是一种高级用法，自定义Thenable对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thenable</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">num</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = num;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>); <span class="hljs-comment">// 1, 构造器入参</span><br>    <span class="hljs-title function_">alert</span>(resolve); <span class="hljs-comment">// function() &#123;native code&#125;</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> * <span class="hljs-number">2</span>), <span class="hljs-number">1000</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thenable</span>(result); <span class="hljs-comment">//自动调用对象的then方法</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(alert);<br></code></pre></td></tr></table></figure><p>当Promise的第一个then运行的时候，<code>return new Thenable</code> 会自动调用对象的 <code>then</code> 方法(类似Promise的executor)</p><h2 id="实现按顺序加载脚本"><a href="#实现按顺序加载脚本" class="headerlink" title="实现按顺序加载脚本"></a>实现按顺序加载脚本</h2><p>所以回到我们最初的问题，我们想要实现按顺序来加载脚本，同时不希望出现error金字塔这种史山代码，就可以使用Promise链来进行简化</p><p>这里综合使用了Promise链以及处理程序中返回thenable的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">src</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    script.<span class="hljs-property">src</span> = src;<br><br>    script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Script loaded successfully&#x27;</span>);<br>    script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Script <span class="hljs-subst">$&#123;src&#125;</span> loaded error`</span>));<br><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script)<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./script1&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./script2&#x27;</span>))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./script3&#x27;</span>))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;All scripts are loaded!&#x27;</span>);<br>    <span class="hljs-comment">//可以使用三个脚本中定义的函数了，因为此时已经按顺序加载</span><br>    <span class="hljs-comment">//foo()</span><br>    <span class="hljs-comment">//bar()</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>在前端编程中，promise 通常被用于网络请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://bing.com&quot;</span>);<br></code></pre></td></tr></table></figure><p>fetch函数向指定 <code>url</code> 发出网络请求并返回一个 promise，当远程服务器返回 header（是在 <strong>全部响应加载完成前</strong>）时，该 promise 使用一个 <code>response</code> 对象来进行 resolve（也就是说fetch promise resolve的是一个response对象）</p><p>然后我们还可以调用response对象的<code>text()</code>来获取所有的响应内容，这个时候也会返回一个promise， 以刚刚下载完成的这个文本作为 result 进行 resolve；或者调用response对象的<code>json()</code>来将结果转为JSON对象作为promise resolve的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;./foo.json&#x27;</span>) <span class="hljs-comment">//&#123;&quot;name&quot;: &quot;foo&quot;, &quot;isAdmin&quot;: true&#125;</span><br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>));<br></code></pre></td></tr></table></figure><h2 id="异步行为应当始终返回一个Promise"><a href="#异步行为应当始终返回一个Promise" class="headerlink" title="异步行为应当始终返回一个Promise"></a>异步行为应当始终返回一个Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showImage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;./foo.json&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://avatars.githubusercontent.com/<span class="hljs-subst">$&#123;user.name&#125;</span>`</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">githubUser</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>);<br>      img.<span class="hljs-property">src</span> = githubUser.<span class="hljs-property">avatar_url</span>;<br>      img.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;promise-avatar-example&#x27;</span>;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(img);<br>      <span class="hljs-comment">//promise走到这里就结束了</span><br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> img.<span class="hljs-title function_">remove</span>(), <span class="hljs-number">3000</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的实现确实是没什么大问题，但是如果我们还想再下游继续消费处理（例如显示一个用于编辑该用户或者其他内容的表单）则没有办法，如果需要实现，还需要调用<code>then</code></p><p>所以一个合理的最佳实践是：为了保证Promise链的可扩展，异步行为应当始终返回一个Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showImage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;./foo.json&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://avatars.githubusercontent.com/<span class="hljs-subst">$&#123;user.name&#125;</span>`</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function">(<span class="hljs-params">githubUser</span>) =&gt;</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>);<br>          img.<span class="hljs-property">src</span> = githubUser.<span class="hljs-property">avatar_url</span>;<br>          img.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;promise-avatar-example&#x27;</span>;<br>          <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(img);<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            img.<span class="hljs-title function_">remove</span>();<br>            <span class="hljs-title function_">resolve</span>(githubUser);<br>          &#125;, <span class="hljs-number">3000</span>);<br>        &#125;),<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebStorm|导入模块报黄无法跳转</title>
    <link href="/2025/02/21/WebStorm-%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E6%8A%A5%E9%BB%84%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC/"/>
    <url>/2025/02/21/WebStorm-%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E6%8A%A5%E9%BB%84%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目成功build后，所有js中声明导入的语句，只要是工程内的本地组件都有黄色警告，点击对应内容无法跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@components/foo&#x27;</span>;<br><span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@components/bar&#x27;</span>;<br></code></pre></td></tr></table></figure><p>原因在于工程框架使用了别名的方式，这里使用的是umi，umi 底层整合了 webpack ,所以项目中也会用到别名路径</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在src同级目录下创建<code>webstorm.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">context</span>: path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;./&#x27;</span>),<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.jsx&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>],<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-comment">//结合项目具体情况进行配置   </span><br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/&#x27;</span>),<br>      <span class="hljs-string">&#x27;@components&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/components/&#x27;</span>),<br>      <span class="hljs-string">&#x27;@utils&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/utils/&#x27;</span>),<br>      <span class="hljs-string">&#x27;@assets&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/assets/&#x27;</span>),<br>      <span class="hljs-string">&#x27;@apis&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/apis/&#x27;</span>),<br>      <span class="hljs-string">&#x27;@pages&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;src/pages/&#x27;</span>),<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>之后通过 Webstorm 的 [Setting] - [Languages &amp; Frameworks] - [Webpack] 中选择手动引用 <code>webstorm.config.js</code> </p><p>刷新即可看到原先的警告消失，同时点击文件也可以跳转到对应的组件内容</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebStorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node|前端工程NPM私服配置</title>
    <link href="/2025/02/21/Node-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8BNPM%E7%A7%81%E6%9C%8D%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/02/21/Node-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8BNPM%E7%A7%81%E6%9C%8D%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>原先公司的前端项目一直都是用公共的镜像源，最近突然换成了oss私服</p><p>因此初始化<code>npm install</code>的时候就会报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm error code E401<br>npm error Unable to authenticate, need: BASIC realm=<span class="hljs-string">&quot;Sonatype Nexus Repository Manager&quot;</span><br></code></pre></td></tr></table></figure><p>工程中已经有人帮我们创建好了<code>npmrc</code>这个文件，这里简单说一下文件的作用：本质上是npm配置文件，在你的用户目录下也存在一份<code>npmrc</code>文件，只不过<strong>用户目录下的是全局的，而工程文件中的是只作用于当前工程的</strong></p><p>工程中的文件内容指定了私服的地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">registry=https://example.oss.com<br></code></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>首先需要向公司层面申请oss账号</p><p>拿到了账号后，在当前目录下执行<code>npm login</code></p><p>会让你输入用户名和密码</p><p>输入完成后，可以进入到<code>%USERPROFILE%</code>目录下，找到<code>.npmrc</code>这个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">registry=https://registry.npm.taobao.org/<br>sass_binary_site=https://npm.taobao.org/mirrors/node-sass<br>strict-ssl=false<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里就是刚刚登录操作后，系统自动创建的token</span><br>//example.oss.com:_authToken=NpmToken.xxx<br></code></pre></td></tr></table></figure><p>之后我们就可以在工程目录下执行<code>npm install</code></p><p>初次拉取依赖的时间可能很长，我这里用了24分钟</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript|ES6模块化</title>
    <link href="/2025/02/19/JavaScript-ES6%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2025/02/19/JavaScript-ES6%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>JS中的模块其实就是多个代码的组织形式，是JS在ES6开始正式从语言级别层面支持模块的语法</p><p>一个模块就是一个文件，一个脚本就是一个模块</p><ul><li><code>export</code> 关键字标记了可以从当前模块外部访问的变量和函数。</li><li><code>import</code> 关键字允许从其他模块导入功能。</li></ul><h1 id="模块核心功能"><a href="#模块核心功能" class="headerlink" title="模块核心功能"></a>模块核心功能</h1><h2 id="严格模式运行"><a href="#严格模式运行" class="headerlink" title="严格模式运行"></a>严格模式运行</h2><p>模块始终在严格模式下运行，对于一个未声明的变量进行赋值将会报错，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;module&quot;</span>&gt;<br>  a = <span class="hljs-number">5</span>; <span class="hljs-comment">// error</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="模块级作用域"><a href="#模块级作用域" class="headerlink" title="模块级作用域"></a>模块级作用域</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;John&quot;</span><br><span class="hljs-keyword">import</span> &#123;user&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = user;<br>&lt;!doctype html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;hello.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>需要注意的是：在浏览器中，对于 HTML 页面，每个 <code>&lt;script type=&quot;module&quot;&gt;</code> 都存在独立的顶级作用域，下面这种就会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;module&quot;</span>&gt;<br>  <span class="hljs-comment">// 变量仅在这个 module script 内可见</span><br>  <span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;John&quot;</span>;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// Error: user is not defined</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="模块代码只在第一次导入时被解析执行"><a href="#模块代码只在第一次导入时被解析执行" class="headerlink" title="模块代码只在第一次导入时被解析执行"></a>模块代码只在第一次导入时被解析执行</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> admin = &#123;<br>  name : <span class="hljs-string">&quot;1&quot;</span><br>&#125;;<br><span class="hljs-comment">// 📁 1.js</span><br><span class="hljs-keyword">import</span> &#123; admin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin.js&#x27;</span>;<br>admin.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>;<br><br><span class="hljs-comment">// 📁 2.js</span><br><span class="hljs-keyword">import</span> &#123; admin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin.js&#x27;</span>;<br><span class="hljs-title function_">alert</span>(admin.<span class="hljs-property">name</span>); <span class="hljs-comment">// Pete</span><br><br><span class="hljs-comment">// 1.js 和 2.js 引用的是同一个 admin 对象</span><br><span class="hljs-comment">// 在 1.js 中对对象做的更改，在 2.js 中也是可见的</span><br></code></pre></td></tr></table></figure><p>该admin.js模块只执行了一次。生成导出admin对象，然后这些导出在1和2的导入之间共享，因此如果更改了 <code>admin</code> 对象，在其他导入中也会看到。</p><p>可以简单的理解为多次导入后，导入的对象具有同一个引用</p><p>我们可以借助这种机制来实现比较经典的场景：</p><ol><li>模块导出一些配置方法，例如一个配置对象。</li><li>在第一次导入时，我们对其进行初始化，写入其属性。可以在应用顶级脚本中进行此操作。</li><li>进一步地导入使用模块。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> config = &#123;&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>($&#123;config.<span class="hljs-property">user</span>&#125;);<br>&#125;<br><span class="hljs-keyword">import</span> &#123;config&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin.js&#x27;</span>;<br>config.<span class="hljs-property">user</span> = <span class="hljs-string">&quot;Pete&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;sayHi&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin.js&#x27;</span>;<br><br><span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">//Pete</span><br></code></pre></td></tr></table></figure><h1 id="导出高阶用法"><a href="#导出高阶用法" class="headerlink" title="导出高阶用法"></a>导出高阶用法</h1><h2 id="在声明前导出"><a href="#在声明前导出" class="headerlink" title="在声明前导出"></a>在声明前导出</h2><p>我们可以在声明一个变量、函数、类之前进行导出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> months = [<span class="hljs-string">&#x27;Jan&#x27;</span>,<span class="hljs-string">&#x27;Feb&#x27;</span>];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MODULES_NUM</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alter</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>值得一提的是，上面声明函数之前export进行导出，本质上还是声明了一个函数，而不是一个<strong>函数表达式，因此不需要末尾打分号。只有函数表达式，末尾才需要打分号</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alter</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>具体函数表达式可以参考<a href="https://zh.javascript.info/function-expressions">函数表达式</a></p><h2 id="导出和声明分开"><a href="#导出和声明分开" class="headerlink" title="导出和声明分开"></a>导出和声明分开</h2><p>我们可以先声明，之后再导出，项目代码中比较常见</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alter</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayBye</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;sayHi, sayBye&#125;;<br></code></pre></td></tr></table></figure><h2 id="不要使用-import"><a href="#不要使用-import" class="headerlink" title="不要使用 import *"></a>不要使用 import *</h2><p>明确列出我们需要导入的内容，便于构建工具优化检测</p><h2 id="为导出和导入起别名"><a href="#为导出和导入起别名" class="headerlink" title="为导出和导入起别名"></a>为导出和导入起别名</h2><p>我们也可以使用 <code>as</code> 让导入具有不同的名字。</p><p>例如，简洁起见，我们将 <code>sayHi</code> 导入到局部变量 <code>hi</code>，将 <code>sayBye</code> 导入到 <code>bye</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 📁 main.js</span><br><span class="hljs-keyword">import</span> &#123;sayHi <span class="hljs-keyword">as</span> hi, sayBye <span class="hljs-keyword">as</span> bye&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;<br><br><span class="hljs-title function_">hi</span>(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Hello, John!</span><br><span class="hljs-title function_">bye</span>(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Bye, John!</span><br></code></pre></td></tr></table></figure><p>导出也具有类似的语法。</p><p>我们将函数导出为 <code>hi</code> 和 <code>bye</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 📁 say.js</span><br>...<br><span class="hljs-keyword">export</span> &#123;sayHi <span class="hljs-keyword">as</span> hi, sayBye <span class="hljs-keyword">as</span> bye&#125;;<br></code></pre></td></tr></table></figure><p>现在 <code>hi</code> 和 <code>bye</code> 是在外面使用时的正式名称：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 📁 main.js</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> say <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;<br><br>say.<span class="hljs-title function_">hi</span>(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Hello, John!</span><br>say.<span class="hljs-title function_">bye</span>(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Bye, John!</span><br></code></pre></td></tr></table></figure><h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><p>为了专注一个模块只做一件事，js提供了<code>export default</code>的语法</p><p>每个文件应该只有一个 <code>export default</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 📁 user.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 📁 main.js</span><br><span class="hljs-comment">//导入的导出文件中包含default时，不需要&#123;User&#125;进行指定</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">命名的导出</th><th align="left">默认的导出</th></tr></thead><tbody><tr><td align="left"><code>export class User &#123;...&#125;</code></td><td align="left"><code>export default class User &#123;...&#125;</code></td></tr><tr><td align="left"><code>import &#123;User&#125; from ...</code></td><td align="left"><code>import User from ...</code></td></tr></tbody></table><p>一般情况下，我们约定一个模块要么是命名的导出，要么就是默认的导出，一般不会进行混用</p><h2 id="重新导出"><a href="#重新导出" class="headerlink" title="重新导出"></a>重新导出</h2><p>在包的源码中比较常见，主要的目的是为了将源码中所有的导出内容，统一在<code>index.js</code>中进行声明供外部引用</p><p>语法结构是 <code>export ... from ...</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span><br><span class="hljs-keyword">export</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar.js&#x27;</span><br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./foo.js&#x27;</span><br><span class="hljs-keyword">export</span> &#123;foo&#125;;<br><br><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar.js&#x27;</span><br><span class="hljs-keyword">export</span> &#123;bar&#125;;<br></code></pre></td></tr></table></figure><p>(我们假设foo在foo.js中是默认的导出，即<code>export default foo</code>)</p><h3 id="默认导出特殊处理"><a href="#默认导出特殊处理" class="headerlink" title="默认导出特殊处理"></a>默认导出特殊处理</h3><p>上面也看到了，对于默认的导出需要一个 <code>default as foo</code> 的处理，</p><p>假设我们现在有一个脚本默认导出了一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 📁 user.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在新的文件中：<code>export User from &#39;./user.js&#39;</code>是语法错误</p><p>我们必须明确写出 <code>export &#123;default as User&#125;</code> 正如上面的处理那样</p><p>因此可以看到，在重新导出时，默认导出需要特殊处理，因此很多开发者也不喜欢默认导出，统一使用命名导出的方式</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Umi|QuickStart</title>
    <link href="/2025/02/17/Umi-QuickStart/"/>
    <url>/2025/02/17/Umi-QuickStart/</url>
    
    <content type="html"><![CDATA[<h1 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h1><p>首先需要node环境，确认本地是否安装了node</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">node -v<br></code></pre></td></tr></table></figure><p>之后可以通过node安装Umi官方推荐的<code>pnpm</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g pnpm@latest-10<br></code></pre></td></tr></table></figure><p>之后使用下面的命令快速启动一个本地项目</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pnpm</span> dlx create-umi<span class="hljs-variable">@latest</span><br></code></pre></td></tr></table></figure><p>可以看到目录下都有这些内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">  quick-start-app  master  <span class="hljs-built_in">ls</span><br><br>        Directory: C:\Users\28459\Desktop\front-end\quick-start-app<br><br><br>Mode                LastWriteTime         Length Name<br>----                -------------         ------ ----<br>d----         2025/2/17     13:58                node_modules<br>d----         2025/2/17     13:58                src<br>-a---         2025/2/17     13:58            124 .gitignore<br>-a---         2025/2/17     13:58             42 .npmrc<br>-a---         2025/2/17     13:58            190 .umirc.ts<br>-a---         2025/2/17     13:58            389 package.json<br>-a---         2025/2/17     13:58         327128 pnpm-lock.yaml<br>-a---         2025/2/17     13:58             44 tsconfig.json<br>-a---         2025/2/17     13:57             22 typings.d.ts<br></code></pre></td></tr></table></figure><p>通过<code> pnpm dev</code>进行调试，通过<code>pnpm umi g</code>来调用工具自动生成前端页面</p><p>主要的关键目录结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── package.json<br>├── pnpm-lock.yaml<br>├── src<br>│   ├── assets<br>│   │   └── yay.jpg<br>│   ├── layouts<br>│   │   ├── index.less<br>│   │   └── index.tsx<br>│   └── pages<br>│       ├── docs.tsx<br>│       └── index.tsx<br>├── tsconfig.json<br>└── typings.d.ts<br></code></pre></td></tr></table></figure><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>算上最佳实践的工程项目，下面简单说一下目录结构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── config<br>│   └── config.ts<br>├── dist<br>├── mock<br>│   └── app.ts｜tsx<br>├── src<br>│   ├── .umi<br>│   ├── .umi-production<br>│   ├── layouts<br>│   │   ├── BasicLayout.tsx<br>│   │   ├── index.less<br>│   ├── models<br>│   │   ├── global.ts<br>│   │   └── index.ts<br>│   ├── pages<br>│   │   ├── index.less<br>│   │   └── index.tsx<br>│   ├── utils // 推荐目录<br>│   │   └── index.ts<br>│   ├── services // 推荐目录<br>│   │   └── api.ts<br>│   ├── app.(ts|tsx)<br>│   ├── global.ts<br>│   ├── global.(css|less|sass|scss)<br>│   ├── overrides.(css|less|sass|scss)<br>│   ├── favicon.(ico|gif|png|jpg|jpeg|svg|avif|webp)<br>│   └── loading.(tsx|jsx)<br>├── node_modules<br>│   └── .cache<br>│       ├── bundler-webpack<br>│       ├── mfsu<br>│       └── mfsu-deps<br>├── .<span class="hljs-built_in">env</span><br>├── plugin.ts <br>├── .umirc.ts // 与 config/config.js 文件 2 选一<br>├── package.json<br>├── tsconfig.json<br>└── typings.d.ts<br></code></pre></td></tr></table></figure><p>config 主要存放前端配置文件定义，通过 <code>export default defineConfig(&#123;&#125;)</code>的方式汇总所有的配置并交给umi框架管理</p><p>dist不用多说了，打包后的目录，直接丢到ng上进行转发即可</p><p>mock目录存放umi mock服务的数据源，此目录下所有 <code>.ts</code> &#x2F; <code>.js</code> 文件会被 mock 服务加载，从而提供模拟数据</p><p>src存放主要js代码</p><p>public目录存放固定的静态资源，如存放 <code>public/image.png</code> ，则开发时可以通过 <code>/image.png</code> 访问到</p><h2 id="src目录"><a href="#src目录" class="headerlink" title="src目录"></a>src目录</h2><h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><p>这是umi约定的<a href="https://umijs.org/docs/api/runtime-config">运行时配置文件</a>，和普通的开发配置的区别在于运行时配置的逻辑在浏览器端运行</p><p>一些常用到的配置如下：</p><ul><li>onRouteChange：在初始加载和路由切换时被调用</li><li>patchClientRoute：修改被 react-router 渲染前的树状路由表</li></ul><h3 id="全局布局"><a href="#全局布局" class="headerlink" title="全局布局"></a>全局布局</h3><p>Umi中约定，在项目工程的 <code>src/layouts/index.js</code> 中声明全局路由布局</p><h3 id="global-js"><a href="#global-js" class="headerlink" title="global.js"></a>global.js</h3><p>在应用前置，全局运行的逻辑</p><h3 id="global-css-less"><a href="#global-css-less" class="headerlink" title="global.css|less"></a>global.css|less</h3><p>全局样式文件（优先级在第三方组件库的样式之后）</p><p>当需要覆盖第三方组件库样式的时候，需要用<code>overrides.css</code></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="配置式路由"><a href="#配置式路由" class="headerlink" title="配置式路由"></a>配置式路由</h2><p>这边主要说一个比较常见的子路由配置方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;login&#x27;</span> &#125;,<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;@/layouts/index&#x27;</span>,<br>      <span class="hljs-comment">//routes作为自己的参数项，表示子路由</span><br>      <span class="hljs-attr">routes</span>: [<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;list&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;admin&#x27;</span> &#125;,<br>      ],<br>    &#125;, <br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><p>上述js的含义就是，对于 &#x2F; 的路由，访问 <code>/list</code> 和 <code>/admin</code> 就会带上 <code>src/layouts/index</code> 这个 layout 组件</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Umi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React|Thinking in React</title>
    <link href="/2025/02/05/React-Thinking-in-React/"/>
    <url>/2025/02/05/React-Thinking-in-React/</url>
    
    <content type="html"><![CDATA[<h1 id="React设计哲学"><a href="#React设计哲学" class="headerlink" title="React设计哲学"></a>React设计哲学</h1><p>使用 React 构建用户界面时，首先需要把它分解成一个个 <strong>组件</strong>，然后，你需要把这些组件连接在一起，使数据流经它们，在这个过程中，需要用到 hooks, props等React核心概念。</p><p>现在假设我们已经有了产品的原型，已经对应的接口数据返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span> category<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Fruits&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$1&quot;</span><span class="hljs-punctuation">,</span> stocked<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Apple&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span> category<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Fruits&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$1&quot;</span><span class="hljs-punctuation">,</span> stocked<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Dragonfruit&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span> category<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Fruits&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$2&quot;</span><span class="hljs-punctuation">,</span> stocked<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Passionfruit&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span> category<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Vegetables&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$2&quot;</span><span class="hljs-punctuation">,</span> stocked<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Spinach&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span> category<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Vegetables&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$4&quot;</span><span class="hljs-punctuation">,</span> stocked<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Pumpkin&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span> category<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Vegetables&quot;</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$1&quot;</span><span class="hljs-punctuation">,</span> stocked<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> name<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Peas&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/s_thinking-in-react_ui.png"></p><h1 id="1-将UI原型拆解为组件层级"><a href="#1-将UI原型拆解为组件层级" class="headerlink" title="1-将UI原型拆解为组件层级"></a>1-将UI原型拆解为组件层级</h1><p>这一步是将UI原型分割为多个组件，一般我们会根据功能来进行分割，一个组件理想情况下应仅做一件事情。</p><p>上面的原型可以分为：</p><ul><li>顶级组件：整个过滤产品的表格<ul><li>搜索框组件，获取用户输入进行过滤</li><li>产品表格组件，展示每个类别的产品和过滤的清单<ul><li>表格表头组件：指明哪一类category</li><li>表格数据行：展示产品的名称name和价格price，并根据是否是库存改变颜色</li></ul></li></ul></li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/s_thinking-in-react_ui_outline.png"></p><h1 id="2-构建静态页面"><a href="#2-构建静态页面" class="headerlink" title="2-构建静态页面"></a>2-构建静态页面</h1><p>根据上述梳理的层级逻辑，我们可以直接编写静态逻辑</p><p>核心在于编写组件，通过props传递数据</p><blockquote><p><strong>静态版本并不需要引用state等hooks，因为这是交互层面的</strong></p></blockquote><p>此外，构建静态版本的页面，一般大型工程都是自底向上编写组件的</p><h2 id="产品分类行"><a href="#产品分类行" class="headerlink" title="产品分类行"></a>产品分类行</h2><p>接收一个分类名称props</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductCategoryRow</span>(<span class="hljs-params">&#123; category &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">colSpan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>&#123;category&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="产品数据行"><a href="#产品数据行" class="headerlink" title="产品数据行"></a>产品数据行</h2><p>接收产品对象作为props</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductRow</span>(<span class="hljs-params">&#123; product &#125;</span>) &#123;<br>     <span class="hljs-comment">//JSX三元运算</span><br>  <span class="hljs-keyword">const</span> name = product.<span class="hljs-property">stocked</span> ? (<br>    product.<span class="hljs-property">name</span><br>  ) : (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span>&#123;product.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;product.price&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="产品表组件"><a href="#产品表组件" class="headerlink" title="产品表组件"></a>产品表组件</h2><p>包含产品分类行和产品数据行，遍历产品数组，渲染分类行和实际数据行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductTable</span>(<span class="hljs-params">&#123; products &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> rows = [];<br>  <span class="hljs-comment">//save lastCategory to avoid duplication rendering</span><br>  <span class="hljs-keyword">let</span> lastCategory = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">//handle products data, split to categories and product item rendering</span><br>  products.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">product</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (product.<span class="hljs-property">category</span> !== lastCategory) &#123;<br>      rows.<span class="hljs-title function_">push</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductCategoryRow</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">category</span>=<span class="hljs-string">&#123;product.category&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;product.category&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br>      );<br>    &#125;<br>    rows.<span class="hljs-title function_">push</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductRow</span> <span class="hljs-attr">product</span>=<span class="hljs-string">&#123;product&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;product.name&#125;</span> /&gt;</span></span>);<br>    lastCategory = product.<span class="hljs-property">category</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>&#123;rows&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h2><p>没有props，考察HTML基本功底</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Search...&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> /&gt;</span> Only show products int stocked</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可过滤搜索的产品表"><a href="#可过滤搜索的产品表" class="headerlink" title="可过滤搜索的产品表"></a>可过滤搜索的产品表</h2><p>父级组件&#x3D;搜索框+产品表组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FilterableProductTable</span>(<span class="hljs-params">&#123; products &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SearchBar</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProductTable</span> <span class="hljs-attr">products</span>=<span class="hljs-string">&#123;products&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="产品列表静态数据"><a href="#产品列表静态数据" class="headerlink" title="产品列表静态数据"></a>产品列表静态数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRODUCTS</span> = [<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Fruits&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$1&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Apple&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Fruits&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$1&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Dragonfruit&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Fruits&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$2&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Passionfruit&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Vegetables&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$2&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Spinach&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Vegetables&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$4&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pumpkin&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Vegetables&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$1&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Peas&quot;</span> &#125;,<br>];<br></code></pre></td></tr></table></figure><h2 id="渲染入口"><a href="#渲染入口" class="headerlink" title="渲染入口"></a>渲染入口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FilterableProductTable</span> <span class="hljs-attr">products</span>=<span class="hljs-string">&#123;PRODUCTS&#125;</span> /&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述我们实现的静态页面主要都是在写js以及html，基本就只用到了react中的props来进行父子组件数据传递，而且还是单项数据流</p><h1 id="3-规划动态页面所需最简state"><a href="#3-规划动态页面所需最简state" class="headerlink" title="3-规划动态页面所需最简state"></a>3-规划动态页面所需最简state</h1><p>为了让页面能够根据用户交互动态进行渲染，我们需要用到react中的state hook，同时为了定义最简化的state，我们一般遵循如下的法制：<strong>考虑本次整个组件中每一条数据</strong>，在这个动态渲染的表格中，主要有这些数据：</p><ul><li>产品原始列表</li><li>搜索框用户的输入</li><li>复选框的值</li><li>过滤后的产品数据列表</li></ul><h2 id="state判断方法论"><a href="#state判断方法论" class="headerlink" title="state判断方法论"></a>state判断方法论</h2><blockquote><p>其中哪些是 state 呢？标记出那些不是的:</p><ul><li>随着时间推移 <strong>保持不变</strong>？如此，便不是 state。</li><li>通过 props <strong>从父组件传递</strong>？如此，便不是 state。</li><li>是否可以基于已存在于组件中的 state 或者 props <strong>进行计算</strong>？如此，它肯定不是state！</li></ul><p>剩下的可能是 state。</p></blockquote><p>所以：</p><ul><li>产品原始列表：通过props传递，不是state</li><li>搜索框用户的输入：可以会是</li><li>复选框的值：可以会是，选中或者没选中</li><li>过滤后的产品数据列表：<strong>不是 state，因为可以通过被原始列表中的产品，根据搜索框文本和复选框的值进行计算</strong>。</li></ul><h1 id="4-验证state的位置"><a href="#4-验证state的位置" class="headerlink" title="4-验证state的位置"></a>4-验证state的位置</h1><p>现在我们需要确定state应该被那些组件<strong>持有</strong>，设计的方法论如下：</p><ul><li>确定哪些组件会用到state，在这里是ProductTable需要基于输入以及复选框来过滤产品列表；以及SearchBar需要展示state</li><li>寻找他们的最近父组件，一般都是放在这些组件的最近共同父组件上。（如果找不到一个有意义拥有这个 state 的地方，单独创建一个新的组件去管理这个 state，并将它添加到它们父组件上层的某个地方）</li></ul><p>所以我们选择在公共父级组件：FilterableProductTable中定义state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FilterableProductTable</span>(<span class="hljs-params">&#123; products &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [filterText, setFilterText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">const</span> [inStockOnly, setInStockOnly] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SearchBar</span> <span class="hljs-attr">filterText</span>=<span class="hljs-string">&#123;filterText&#125;</span> <span class="hljs-attr">inStockOnly</span>=<span class="hljs-string">&#123;inStockOnly&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProductTable</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">products</span>=<span class="hljs-string">&#123;products&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">filterText</span>=<span class="hljs-string">&#123;filterText&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">inStockOnly</span>=<span class="hljs-string">&#123;inStockOnly&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在输入框中新增state的props来展示数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBar</span>(<span class="hljs-params">&#123; filterText, inStockOnly &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Search...&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;filterText&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&#123;inStockOnly&#125;</span> /&gt;</span> Only show products int</span><br><span class="language-xml">        stocked</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在产品表中也是新增state的props</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductTable</span>(<span class="hljs-params">&#123; products, filterText, inStockOnly &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> rows = [];<br>  <span class="hljs-comment">//save lastCategory to avoid duplication rendering</span><br>  <span class="hljs-keyword">let</span> lastCategory = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">//handle products data, split to categories and product item rendering</span><br>  products.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">product</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//Input value filtering</span><br>    <span class="hljs-keyword">if</span> (product.<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">indexOf</span>(filterText.<span class="hljs-title function_">toLowerCase</span>()) === -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//when checkbox checked show only stocked product</span><br>    <span class="hljs-keyword">if</span> (inStockOnly &amp;&amp; !product.<span class="hljs-property">stocked</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (product.<span class="hljs-property">category</span> !== lastCategory) &#123;<br>      rows.<span class="hljs-title function_">push</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductCategoryRow</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">category</span>=<span class="hljs-string">&#123;product.category&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;product.category&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br>      );<br>    &#125;<br>    rows.<span class="hljs-title function_">push</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductRow</span> <span class="hljs-attr">product</span>=<span class="hljs-string">&#123;product&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;product.name&#125;</span> /&gt;</span></span>);<br>    lastCategory = product.<span class="hljs-property">category</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>&#123;rows&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-添加交互用反向数据流"><a href="#5-添加交互用反向数据流" class="headerlink" title="5-添加交互用反向数据流"></a>5-添加交互用反向数据流</h1><p>但是上面的代码实际上只处理了渲染的动态逻辑，用户的交互并未实现，也就是用户在搜索框这个组件输入数据的时候，怎么将state数据反向传递到父级组件FilterableProductTable，然后再向下正向传递到ProductTable中</p><p><strong>其实我们之前说的状态提升，本质上也就是将状态的更新反馈到父级组件，也就是反向数据流。</strong></p><p>具体的实现方式就是：<strong>在父级组件中将state的更新函数通过props的方式传递到子组件，供子组件的回调函数调用</strong></p><p>调整父组件，将回调函数作为props传递给搜索框</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FilterableProductTable</span>(<span class="hljs-params">&#123; products &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [filterText, setFilterText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">const</span> [inStockOnly, setInStockOnly] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SearchBar</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">filterText</span>=<span class="hljs-string">&#123;filterText&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">inStockOnly</span>=<span class="hljs-string">&#123;inStockOnly&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onFilterTextChange</span>=<span class="hljs-string">&#123;setFilterText&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onInStockOnlyChange</span>=<span class="hljs-string">&#123;setInStockOnly&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProductTable</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">products</span>=<span class="hljs-string">&#123;products&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">filterText</span>=<span class="hljs-string">&#123;filterText&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">inStockOnly</span>=<span class="hljs-string">&#123;inStockOnly&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>搜索框内容变动时调用props的回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBar</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">  filterText,</span><br><span class="hljs-params">  inStockOnly,</span><br><span class="hljs-params">  onFilterTextChange,</span><br><span class="hljs-params">  onInStockOnlyChange,</span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Search...&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;filterText&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onFilterTextChange(e.target.value)&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">checked</span>=<span class="hljs-string">&#123;inStockOnly&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onInStockOnlyChange(e.target.checked)&#125;</span><br><span class="language-xml">        /&gt;&#123;&quot; &quot;&#125;</span><br><span class="language-xml">        Only show products int stocked</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>至此我们已经实现了一个可以用于数据过滤的表格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductCategoryRow</span>(<span class="hljs-params">&#123; category &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">colSpan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>&#123;category&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductRow</span>(<span class="hljs-params">&#123; product &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> name = product.<span class="hljs-property">stocked</span> ? (<br>    product.<span class="hljs-property">name</span><br>  ) : (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span>&#123;product.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>  );<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;product.price&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ProductTable</span>(<span class="hljs-params">&#123; products, filterText, inStockOnly &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> rows = [];<br>  <span class="hljs-comment">//save lastCategory to avoid duplication rendering</span><br>  <span class="hljs-keyword">let</span> lastCategory = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">//handle products data, split to categories and product item rendering</span><br>  products.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">product</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//Input value filtering</span><br>    <span class="hljs-keyword">if</span> (product.<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">indexOf</span>(filterText.<span class="hljs-title function_">toLowerCase</span>()) === -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//when checkbox checked show only stocked product</span><br>    <span class="hljs-keyword">if</span> (inStockOnly &amp;&amp; !product.<span class="hljs-property">stocked</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (product.<span class="hljs-property">category</span> !== lastCategory) &#123;<br>      rows.<span class="hljs-title function_">push</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductCategoryRow</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">category</span>=<span class="hljs-string">&#123;product.category&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;product.category&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        /&gt;</span></span><br>      );<br>    &#125;<br>    rows.<span class="hljs-title function_">push</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProductRow</span> <span class="hljs-attr">product</span>=<span class="hljs-string">&#123;product&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;product.name&#125;</span> /&gt;</span></span>);<br>    lastCategory = product.<span class="hljs-property">category</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>&#123;rows&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchBar</span>(<span class="hljs-params">&#123;</span><br><span class="hljs-params">  filterText,</span><br><span class="hljs-params">  inStockOnly,</span><br><span class="hljs-params">  onFilterTextChange,</span><br><span class="hljs-params">  onInStockOnlyChange,</span><br><span class="hljs-params">&#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Search...&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;filterText&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onFilterTextChange(e.target.value)&#125;</span><br><span class="language-xml">      /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">checked</span>=<span class="hljs-string">&#123;inStockOnly&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onInStockOnlyChange(e.target.checked)&#125;</span><br><span class="language-xml">        /&gt;&#123;&quot; &quot;&#125;</span><br><span class="language-xml">        Only show products int stocked</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FilterableProductTable</span>(<span class="hljs-params">&#123; products &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [filterText, setFilterText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">const</span> [inStockOnly, setInStockOnly] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SearchBar</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">filterText</span>=<span class="hljs-string">&#123;filterText&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">inStockOnly</span>=<span class="hljs-string">&#123;inStockOnly&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onFilterTextChange</span>=<span class="hljs-string">&#123;setFilterText&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onInStockOnlyChange</span>=<span class="hljs-string">&#123;setInStockOnly&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ProductTable</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">products</span>=<span class="hljs-string">&#123;products&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">filterText</span>=<span class="hljs-string">&#123;filterText&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">inStockOnly</span>=<span class="hljs-string">&#123;inStockOnly&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRODUCTS</span> = [<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Fruits&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$1&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Apple&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Fruits&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$1&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Dragonfruit&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Fruits&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$2&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Passionfruit&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Vegetables&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$2&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Spinach&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Vegetables&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$4&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pumpkin&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">category</span>: <span class="hljs-string">&quot;Vegetables&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;$1&quot;</span>, <span class="hljs-attr">stocked</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Peas&quot;</span> &#125;,<br>];<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FilterableProductTable</span> <span class="hljs-attr">products</span>=<span class="hljs-string">&#123;PRODUCTS&#125;</span> /&gt;</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>简单来说，props就是作为参数，state可以看作是组件的内存变量，通过props和state等hooks的组合实现多个组件组件间数据的共享</p><p>此外，本文还为如何从头开始设计一个可用的React组件提供了建设性的意见以及实用的方法论</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nand2Tetris|VirtualMachine</title>
    <link href="/2025/01/26/Nand2Tetris-VirtualMachine/"/>
    <url>/2025/01/26/Nand2Tetris-VirtualMachine/</url>
    
    <content type="html"><![CDATA[<h1 id="Compliation"><a href="#Compliation" class="headerlink" title="Compliation"></a>Compliation</h1><h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><p>高级编程语言大部分都是通过以下的组件配合才能进行执行</p><ul><li>编译器</li><li>OS</li><li>VM虚拟机</li><li>汇编器</li></ul><p>根据编译的层级可以分成两种</p><ul><li>一级编译：高级编程语言通过编译器直接转换为机器语言</li><li>二级编译：高级编程语言————&gt;VM指令（字节码）————&gt;机器语言</li></ul><p>比较常见的一级编译代表就是cpp，二级编译代表是java</p><ul><li>一级编译<ul><li>生成的更高效更具有针对性的机器代码</li><li>但是针对多个硬件平台就需要需要多组编译器&#x2F;编译过程实现</li></ul></li><li>二级编译<ul><li>一次编译，处处运行！</li><li>针对每一个硬件平台就需要一个 VM Translator(但是VM Translator的实现远比编译器简单)；同时生成的机器代码也相对来说更低效（对于部分应用程序来说这个效果并不明显）</li></ul></li></ul><p>对于 Hack 机器来说，整体的执行流程如下：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250129134222371.png" alt="整体执行流程"></p><p>这里我们也引出整个课程第二部分的目标：</p><ul><li>构建编译器的后端（目前正在进行的）</li><li>实现一个高级编程语言Jack（类似Java，运行在Hack计算机上）</li><li>实现编译器的前端</li><li>实现Hack硬件通用的操作系统</li></ul><p>整体的流程：</p><p>高级编程语言编写代码，组合Hack硬件操作系统系统调用————通过编译器生成VM代码————VM代码转换为机器代码————机器代码通过汇编器转为二进制指令————Hack硬件取指执行指令进行相关功能</p><h1 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a>Virtual Machine</h1><blockquote><p>从整体角度来说：每个高级编程语言中的算术或逻辑表达式都可以转化为在虚拟机堆栈中运行的虚拟机命令序列。</p></blockquote><p>VM code：由编译器生成，在虚拟机上运行</p><p>VM Translator：将 VM code 转换为机器语言</p><p>VM Translator实现了VM code抽象</p><h2 id="VM基本操作介绍"><a href="#VM基本操作介绍" class="headerlink" title="VM基本操作介绍"></a>VM基本操作介绍</h2><p>Hack计算机的虚拟机是基于栈结构的</p><p>基于这个基础栈结构，程序在此数据基础上进行算数操作</p><p>虚拟机栈的算数操作抽象可以看作是一个函数f，这个函数调用会从栈中pop所需要的数据作为函数入参，将函数进行计算之后再将结果push至栈中</p><p>如下面的两张图</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250129135208830.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250129140241037.png"></p><p>简单来说就是：pop oprands, apply oprators on function 最后 push result</p><p>具体应用例子如下：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250129140455291.png"></p><h2 id="Virtual-Mem-Segments"><a href="#Virtual-Mem-Segments" class="headerlink" title="Virtual Mem Segments"></a>Virtual Mem Segments</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> s1, s2;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;    <br>          <span class="hljs-type">int</span> a, b, c; <br>          ...     <br>          c = s1 + y;<br>           ...<br>           <span class="hljs-keyword">return</span> c; <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于其中的 <code>c = s1 + y</code> 编译器得到的 VM code 实际上是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">push <span class="hljs-keyword">static</span> <span class="hljs-number">0</span><br>push argument <span class="hljs-number">1</span><br>add<br>pop local <br></code></pre></td></tr></table></figure><p>对于需要生成VM code的编译器，编译器在编译阶段会将变量根据其类型用<code>virtual memory segments</code>来进行表示</p><p>例如上面的代码，两个静态变量 <code>s1</code> 和 <code>s2</code>，函数局部参数 <code>x</code> 和 <code>y</code>，函数内部局部参数 <code>a</code> <code>b</code> <code>c</code>，分别代表三种不同的类型，对应三个不同的 segement</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250129141400075.png"></p><p>之后编译器会生成操作虚拟机栈和虚拟内存片段的VM指令</p><p>Jack的虚拟机架构支持8中不同的虚拟内存片段种类，分别是<code>local</code> <code>argument </code> <code>static</code> <code>constant</code> <code>this</code> <code>that</code> <code>temp</code> <code>pointer</code></p><p>具体在后续实现编译器的时候会知道他们各自的功能</p><p>一个很重要的VM抽象就是：<strong>所有操作虚拟内存片段（VM segment）对应的指令需要表现一致的行为</strong>：</p><ul><li>push只会更新栈顶元素</li><li>pop只会写入虚拟内存段</li></ul><h2 id="VM-指令"><a href="#VM-指令" class="headerlink" title="VM 指令"></a>VM 指令</h2><p>VM code 的基本格式就是</p><p><code>push/pop segement_type i</code> (i为非负整数)</p><p>除此之外还有基础的算数运算&#x2F;逻辑函数</p><p><code>add</code> <code>sub</code> <code>neg</code> <code>eq</code> <code>gt</code> <code>lt</code> <code>and</code> <code>or</code> <code>not</code></p><p>从具体的实现角度而言，有三种不同实现方式：</p><ul><li>原生硬件实现：在硬件基础上进行扩展，扩展专门的硬件模块来表示虚拟机的栈结构；此外还需要在计算机支持的指令集上扩展VM指令的原始版本</li><li>软件模拟：将虚拟机的栈和虚拟内存段视作高级编程语言中的抽象数据结构类型。在这种情况下VM指令其实就是操作这些数据结构类型的方法&#x2F;函数</li><li>翻译：将每条VM指令翻译成在主机 RAM 上运行的机器指令；使用内存寻址的方式，将堆栈和内存段作为主机 RAM 里的专用 RAM 段来实现（需要约定内存区域的哪些位置用来维护VM指令转换所需数据，后面都会提到）</li></ul><p>翻译的这种实现方式是比较广泛采取的方案，例如 java py, c# ruby scala 等，这里我们的 Jack 也采用第三种方案</p><h1 id="VM指令转机器指令"><a href="#VM指令转机器指令" class="headerlink" title="VM指令转机器指令"></a>VM指令转机器指令</h1><h2 id="实现push-const-i"><a href="#实现push-const-i" class="headerlink" title="实现push const i"></a>实现push const i</h2><p>对于VM指令中 push constant 类型的，我们根据对应的数据流向，先写出对应的汇编代码</p><p>我们约定：<strong>vm stack pointer 的地址存放于 RAM[0]，const 类型的 vm stack 的数据从 256 地址开始</strong></p><p>当执行 <code>push constant i </code> 这个VM指令的时候，实际上效果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">RAM[SP] = i<br>SP++     <br></code></pre></td></tr></table></figure><p>对应的 Hack 汇编就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//D=i</span><br><span class="hljs-meta">@i</span><br>D=A<br><span class="hljs-comment">//RAM[SP]=D</span><br><span class="hljs-meta">@SP</span><br>A=M<br>M=D<br><span class="hljs-comment">//SP++</span><br><span class="hljs-meta">@SP</span><br>M=M+<span class="hljs-number">1</span>     <br></code></pre></td></tr></table></figure><h2 id="实现push-x2F-pop-local-i"><a href="#实现push-x2F-pop-local-i" class="headerlink" title="实现push&#x2F;pop local i"></a>实现push&#x2F;pop local i</h2><p>对于Jack编写的函数中定义的局部变量，VM需要能够支持 push&#x2F;pop 操作</p><p><code>pop local i</code> 的语义是：<strong>将SP的数据pop出来，设置在 local segement 的 i 位置</strong></p><p>值得注意的是，对于函数内部的变量，地址是在RAM中不确定的，根据每一次程序的运行动态设置，我们通过<code>LCL</code>来表示基础地址，类似SP，LCL的<strong>地址</strong>存放于RAM[1]</p><p><code>pop local i</code>的对应伪代码就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//pop local i</span><br>addr &lt;- LCL + i<br>SP--<br>RAM[addr] &lt;- RAM[SP]     <br></code></pre></td></tr></table></figure><p>对应的汇编就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SP--</span><br><span class="hljs-meta">@SP</span><br>M=M-<span class="hljs-number">1</span><br><span class="hljs-comment">//D = RAM[SP]     </span><br>A=M<br>D=M<br><span class="hljs-comment">//addr &lt;- LCL + i</span><br><span class="hljs-meta">@LCL</span><br>D=M<br><span class="hljs-meta">@i</span><br>A=D+A     <br><span class="hljs-comment">//RAM[addr] = RAM[SP]</span><br>M=D     <br></code></pre></td></tr></table></figure><p>类似的 push 操作语义为 <strong>将i地址偏移后的数据写入到当前栈顶</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">addr &lt;- LCL + i<br>RAM[SP] &lt;- RAM[addr]<br>SP++     <br></code></pre></td></tr></table></figure><p>对应的汇编就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//addr &lt;- LCL + i</span><br><span class="hljs-meta">@LCL</span><br>D=M<br><span class="hljs-meta">@i</span><br>D=D+A<br><span class="hljs-comment">//RAM[SP] &lt;- RAM[addr]     </span><br>A=D<br>D=M<br><span class="hljs-meta">@SP</span><br>A=M<br>M=D<br><span class="hljs-comment">//SP++</span><br><span class="hljs-meta">@SP</span><br>M=M+<span class="hljs-number">1</span>     <br></code></pre></td></tr></table></figure><h2 id="类似local-segement的VM操作"><a href="#类似local-segement的VM操作" class="headerlink" title="类似local segement的VM操作"></a>类似local segement的VM操作</h2><p>对于<code>local</code> <code>argument</code> <code>this</code> <code>that</code> 的 segement，他们的转换实现其实都是一样的，都可以参照上述的汇编转换，对应的逻辑是完全一致的</p><p>只是 <code>segmentPointer</code> 是不一样的，也就是程序运行时分配的基础地址不同，分别用 <code>LCL</code> <code>ARG</code> <code>THIS</code> <code>THAT</code> 来进行区分</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250130115337481.png"></p><h2 id="实现push-x2F-pop-static-i"><a href="#实现push-x2F-pop-static-i" class="headerlink" title="实现push&#x2F;pop static i"></a>实现push&#x2F;pop static i</h2><blockquote><p>When the compiler compiles classes, it maps all their static variables onto one VM segment, named static</p><p>当编译器编译类时，它将所有静态变量映射到一个名为static的VM segment上</p></blockquote><p>我们约定：static 类型的 VM segment 从地址16开始，到255停止</p><p>想要实现<code>push/pop static i</code>的VM指令，只需要生成实现<code>push/pop Xxx.i</code>的汇编代码即可，其中 Xxx.i 是汇编符号名称</p><p>（因为Hack汇编器处理定义的变量的时候，符号表的映射起始地址就是从16开始）</p><h2 id="实现push-x2F-pop-temp-i"><a href="#实现push-x2F-pop-temp-i" class="headerlink" title="实现push&#x2F;pop temp i"></a>实现push&#x2F;pop temp i</h2><p>这里的temp类型是指汇编器在针对高级编程语言代码时，在生成VM指令的过程中可能需要一些临时的变量，这些变量本身并不是源代码中定义的</p><p>因此<code>temp</code>类型的segment是一个定长的8长度的片段，从5开始，12结束</p><p>所以实现<code>push/pop temp i</code>本质上就是在实现<code>push/pop RAM[5+i]</code>的语义</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250201151850546.png"></p><h2 id="实现push-x2F-pop-pointer-i"><a href="#实现push-x2F-pop-pointer-i" class="headerlink" title="实现push&#x2F;pop pointer i"></a>实现push&#x2F;pop pointer i</h2><p>pointer类型的segment主要是用于在汇编器处理代码中针对对象&#x2F;数组的引用，具体更多的内容我们会在后面实现编译器的时候提到</p><p>现在只需要知道他是一个定长的两格长度的segment即可</p><p>pointer 是真正意义上虚拟的segment，不存储在任何地方，仅仅包含 <code>this</code> 和 <code>that</code> 的基础地址</p><p>实际上i只能是0或者是1，对应this和that</p><p><code>pop pointer 0/1</code> 等价于将栈顶元素写入<code>RAM[3]/RAM[4]</code>里</p><p><code>push pointer 0/1</code> 等价于将<code>RAM[3]/RAM[4]</code>元素压入栈顶</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250201152853277.png"></p><p><strong>综上，我们描述了如何生成实现VM操作的汇编代码片段</strong></p><h2 id="实现VM算数逻辑指令"><a href="#实现VM算数逻辑指令" class="headerlink" title="实现VM算数逻辑指令"></a>实现VM算数逻辑指令</h2><p>对于任何一个VM算数指令，本质上就是将VM栈中的数据pop出来作为操作数，之后将操作数应用到计算函数中进行计算，最终将结果push入栈的过程</p><p>pop和push的汇编指令我们之前已经实现了，而计算函数其实本质上也就是加减乘除等，汇编本身支持</p><h1 id="VM-emulator"><a href="#VM-emulator" class="headerlink" title="VM emulator"></a>VM emulator</h1><p>VM的实现之前也提到了，主要分为两种：</p><ul><li>VM Emulator：通过高级编程语言编写，执行对应的VM指令（课程已经提供了）</li><li>VM translator：通过将VM指令等效替换为对应平台的汇编指令（实验7和8需要实现）</li></ul><p>这里简单提一下课程提供的VM模拟器，它可以可视化观看VM指令的执行过程，VM stack和对应的虚拟segment在主机RAM中是如何被模拟已经动态变化的</p><h1 id="Standard-Mapping"><a href="#Standard-Mapping" class="headerlink" title="Standard Mapping"></a>Standard Mapping</h1><p>这里的Standard Mapping的意思针对某些目标平台，提供的一套标准的内存映射约定（vm stack从何处开始存储，segment pointers有哪些，分别从哪里开始等），也就是将抽象的VM栈内存映射到物理内存区域的约定</p><p>其实我们上面说到现在一直在说的，其实都是针对 Hack Computer 的 Standard Mapping，这边顺带做一个总结</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250206112833451.png"></p><h1 id="VM-Tanslator实现"><a href="#VM-Tanslator实现" class="headerlink" title="VM Tanslator实现"></a>VM Tanslator实现</h1><p>先来梳理一下整体的逻辑：</p><ul><li>用户编写高级编程语言（例如Jack或者Java）</li><li>编译器编译阶段生成VM指令（此过程与平台无关，跨平台的核心本质上是套了一层）</li><li>VM Translator通过不同目的平台的实现，将VM指令转换为对应平台的汇编</li><li>汇编代码根据汇编器转换为对应硬件可直接执行的二进制代码</li></ul><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>主要可以包含三个部分：</p><ul><li>VMTranslator核心驱动程序，读取文件控制整体流程</li><li>Parser：读取文件中单行的VM command并解析</li><li>CodeWritter：Parser的解析结果，生成对应实现VM指令效果的Hack汇编代码</li></ul><h2 id="Parser实现"><a href="#Parser实现" class="headerlink" title="Parser实现"></a>Parser实现</h2><p>首先一个原始VM指令代码文件就对应一个Parser，这个Parser会读取所有内容并维护在内存中</p><p>同样类似于之前实现的汇编器，Parser中还是需要有判断是否还有下一行<code>hasMoreLines()</code>，以及维护一个隐式的游标在内存中维护当前的指令<code>advance()</code></p><p>针对核心的解析逻辑，需要对当前指令执行如下函数：</p><ul><li><code>commandType()</code>返回当前VM指令的类型：<code>C_ARITHMETIC</code>或者是<code>C_PUSH/C_POP</code>（这个其实没什么好的办法，只能根据指令内容来判断，暴力枚举即可）</li><li><code>arg1</code> 返回当前VM指令的第一个参数，也就是<code>push/pop</code>，对于算数运算VM指令，直接返回指令本身</li><li><code>arg2</code> 返回当前VM指令的第二个参数，也是就是segment的类型（仅<code>C_PUSH/C_POP</code>类型调用）</li></ul><h2 id="Code-Writer实现"><a href="#Code-Writer实现" class="headerlink" title="Code Writer实现"></a>Code Writer实现</h2><p>类似Parser，一个CodeWriter实例对应一个输出文件，核心实现函数包括：</p><ul><li><code>writeArithmetic</code>根据当前VM算数指令，在输出文件流中写入汇编内容</li><li><code>writePushPop</code>根据当前VM指令，在输出文件流中写入汇编内容</li><li><code>close</code>提供关闭输出流的接口防止内存泄露</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>Nand2Tetris</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript|JS拾遗</title>
    <link href="/2025/01/23/JavaScript-JS%E6%8B%BE%E9%81%97/"/>
    <url>/2025/01/23/JavaScript-JS%E6%8B%BE%E9%81%97/</url>
    
    <content type="html"><![CDATA[<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><p><code>export</code> 关键字修饰的函数使此函数可以在此 js 文件之外访问</p><p><code>default</code> 关键字表明它是文件中的主要函数</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React|Quick Start</title>
    <link href="/2025/01/23/React-Quick-Start/"/>
    <url>/2025/01/23/React-Quick-Start/</url>
    
    <content type="html"><![CDATA[<h1 id="基础声明"><a href="#基础声明" class="headerlink" title="基础声明"></a>基础声明</h1><h2 id="创建和嵌套组件"><a href="#创建和嵌套组件" class="headerlink" title="创建和嵌套组件"></a>创建和嵌套组件</h2><p><strong>React 组件是返回标签的 JavaScript 函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyButton</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-keyword">return</span> (<br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>测试按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>     );<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了这个组件之后，我们可以将其嵌套在另一个组件的声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">return</span> (<br>     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">               <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>测试应用<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">               <span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span>/&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>     );<br>&#125;<br></code></pre></td></tr></table></figure><p>其中上面的 <code>export default</code> 定义了文件中的重要组件</p><p>同时组件内引入组件的时候，标签名称必须是大写开头，React中组件名称都要求大写开头</p><blockquote><p><strong><code>export</code></strong> 声明用于从 JavaScript 模块中导出值。导出的值可通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import"><code>import</code></a>声明或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/import">动态导入</a>来将其导入其他程序</p></blockquote><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>上面所使用的通过JS函数返回HTML标签的语法被称为 <em>JSX</em></p><p><strong>JSX 元素是 JavaScript 代码和 HTML 标签的组合，用于描述要显示的内容</strong>。</p><p>JSX 比 HTML 更加严格。你必须闭合标签，如 <code>&lt;br /&gt;</code>。</p><p>可以看到我们上面定义标签的时候，在h1和自己定义的组件里，外部还套了一层div，这是因为组件也不允许一次直接返回多个 JSX 标签。我们必须将它们包裹到一个共享的父级中，比如 <code>&lt;div&gt;...&lt;/div&gt;</code> 或使用空的 <code>&lt;&gt;...&lt;/&gt;</code> 包裹</p><p>所以上述的代码也可以调整为这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TestButton</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>测试按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>测试应用<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">TestButton</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="添加样式"><a href="#添加样式" class="headerlink" title="添加样式"></a>添加样式</h2><p>React 中我们通过 <code>className</code> 指定一个 CSS 的class，等价于 html 中指定 class 属性</p><blockquote><p>React并未约定如何引入css，后续学习到的框架或者构建工具会实现</p></blockquote><h2 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h2><p>JSX的作用就是把HTML写入js内，渲染页面基本元素</p><p>而React支持在标签内写<code>&#123;&#125;</code>的方式又可以再回到js代码的编写，实现了页面数据的动态展示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>     <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Test&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showData</span>(<span class="hljs-params"></span>) &#123;<br>     retrun (<br>     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">       &#123;user.name&#125;     </span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>     );<br>&#125;<br></code></pre></td></tr></table></figure><p>上述就将标题内容展示为指定数据 user.name 也就是 Test</p><p>一个更为复杂的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义数据</span><br><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Test&#x27;</span>,<br>  <span class="hljs-attr">imageUrl</span>: <span class="hljs-string">&#x27;https://i.imgur.com/yXOvdOSs.jpg&#x27;</span>,<br>  <span class="hljs-attr">imageSize</span>: <span class="hljs-number">100</span>,<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Profile</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">return</span> (<br>     <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">           <span class="hljs-attr">className</span> = <span class="hljs-string">&quot;avatar&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">           <span class="hljs-attr">src</span> = <span class="hljs-string">&#123;user.imageUrl&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">           <span class="hljs-attr">alt</span> = <span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">Photo</span> <span class="hljs-attr">of</span>&#x27; + <span class="hljs-attr">user.name</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">           <span class="hljs-attr">style</span> = <span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    <span class="hljs-attr">width:</span> <span class="hljs-attr">user.imageSize</span>,</span></span><br><span class="hljs-tag"><span class="language-xml">                    <span class="hljs-attr">weight:</span> <span class="hljs-attr">user.imageSize</span>     </span></span><br><span class="hljs-tag"><span class="language-xml">               &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">              /&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/&gt;</span></span><br>     );<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意上述的 <code>style = &#123;&#123;&#125;&#125;</code> 并非特殊语法，最外层的大括号表示我们要在JSX中嵌入JS数据，而内层的大括号是一个js中的对象，由于style的属性接收的都是kv键值对，因此内层还需要一对括号定义JS的对象。</p><p>所以在上面的代码中，我们先通过花括号定义了一个key分别是width和weight的js对象，然后再套了一对花括号来在JSX中嵌入JS对象。</p><p>所以上述的两对并不是react中特殊的语法，理论上html标签中属性支持对象的元素在JSX中进行自定义初始化操作的声明 都需要两对花括号。</p><h2 id="条件展示-x2F-指定属性"><a href="#条件展示-x2F-指定属性" class="headerlink" title="条件展示&#x2F;指定属性"></a>条件展示&#x2F;指定属性</h2><p>这部分React并未进行特殊约定，因此我们可以直接写js的if-else代码，条件引入JSX，之后通过<code>&#123;&#125;</code>的方式将JSX以JS元素的方式渲染返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> content;<br><span class="hljs-keyword">if</span>(isLogin) &#123;<br>     content = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminPage</span> /&gt;</span></span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>     content = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginForm</span> /&gt;</span></span><br>&#125;<br><span class="hljs-keyword">return</span> (<br><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">       &#123;content&#125;</span><br><span class="language-xml">     <span class="hljs-tag">&lt;/&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>当然也可以使用三元运算符，不过需要注意的是三元运算符需要工作在 JSX 内部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div&gt;<br>  &#123;isLogin ? (<br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminPage</span> /&gt;</span></span><br>     ) : (<br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginForm</span> /&gt;</span></span><br>     )&#125;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h2 id="列表数据展示"><a href="#列表数据展示" class="headerlink" title="列表数据展示"></a>列表数据展示</h2><p>使用JSX标签语法下的<code>&lt;li&gt;</code>，同时使用JS提供的 <code>map()</code> 来处理映射每一个列表数据元素</p><p>假设我们有一组列表数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> products = [<br>  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;卷心菜&#x27;</span>, <span class="hljs-attr">isFruit</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;,<br>  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;大蒜&#x27;</span>, <span class="hljs-attr">isFruit</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">2</span> &#125;,<br>  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;苹果&#x27;</span>, <span class="hljs-attr">isFruit</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">3</span> &#125;,<br>];<br></code></pre></td></tr></table></figure><p>现在需要展示为列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ShoppingList</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">const</span> listItems = products.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span></span></span><br><span class="hljs-tag"><span class="language-xml">           <span class="hljs-attr">key</span> = <span class="hljs-string">&#123;product.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">           <span class="hljs-attr">style</span> = <span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                   <span class="hljs-attr">color:</span> <span class="hljs-attr">product.isFruit</span> ? &#x27;<span class="hljs-attr">magenta</span>&#x27; <span class="hljs-attr">:</span> &#x27;<span class="hljs-attr">darkgreen</span>&#x27;</span></span><br><span class="hljs-tag"><span class="language-xml">           &#125;&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">           &#123;product.title&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>      );<br>      <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>       );<br>&#125;<br></code></pre></td></tr></table></figure><p>上述 listItem 元素中 key 属性用来唯一区分列表元素，一般从后端数据里需要给出</p><p>在这里我们只是用 map 函数将数据根据字段修改了样式，还是将js逻辑修改应用到标签的样式，因此使用style属性</p><p>map函数返回了修改样式后的数据数组，直接用ul进行展示</p><h2 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ClickableButton</span> ()&#123;<br>     <span class="hljs-comment">//点击事件处理函数</span><br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;clicked&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> (<br>       <span class="hljs-comment">//不直接调用事件处理函数，而是传递给事件</span><br>       <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> =  <span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">       点击</span><br><span class="language-xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>     );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>(1)首先需要从React中引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br></code></pre></td></tr></table></figure><p>(2)在组件中声明 state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CountButton</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>(3)调用 useState 可以获得当前的 state 以及用于更新他的函数，命名随意，但是一般我们都用 <code>const [xxx, setXXX] = useState() </code> 来声明 state</p><p>(4)默认值：上面我们给 useState 函数的入参传入了0，这个作用是设置变量的默认值</p><p>(5)每个组件内部声明 useState 获得到的变量是独立的，也就是说我们引入两个 <code>&lt;CountButton&gt;</code> 可以得到两个独立统计点击次数的按钮</p><p>点击按钮累计计数的demo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MyApp</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>独立更新的计数器<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">CountButton</span>/&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">CountButton</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CountButton</span> () &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span> () &#123;<br>    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">    Click &#123;count&#125; times</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p><code>use</code> 开头的函数官方称之为 Hook，上面 <code>useState</code> 就是 React 内置的一个 Hook</p><p><a href="https://zh-hans.react.dev/reference/react">React API docs</a></p><p>Hooks 是React中一个很重要的概念，后续会重点进行学习</p><p>Hook 比普通函数更为严格。只能在你的组件（或其他 Hook）的 <strong>顶层</strong> 调用 Hook</p><p>如果想在一个条件或循环中使用 <code>useState</code>，需要提取一个新的组件并在组件内部使用它</p><h2 id="组件间数据共享"><a href="#组件间数据共享" class="headerlink" title="组件间数据共享"></a>组件间数据共享</h2><p>上述点击按钮展示点击次数的demo，多个按钮的useState的数据是独立的</p><p>我们想要在多个组件间数据共享，例如点击一次，同步更新到两个按钮显示数据里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ShareButton</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> (<br>       <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>共同更新的按钮<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">CustomizeButton</span> <span class="hljs-attr">count</span> = <span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">handleClick</span> = <span class="hljs-string">&#123;handleClick&#125;/</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">CustomizeButton</span> <span class="hljs-attr">count</span> = <span class="hljs-string">&#123;count&#125;</span> <span class="hljs-attr">handleClick</span> = <span class="hljs-string">&#123;handleClick&#125;/</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;/&gt;</span></span>  <br>     );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CustomizeButton</span>(<span class="hljs-params">&#123;count, handleClick&#125;</span>) &#123;<br>     <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span></span><br><span class="language-xml">          Click &#123;count&#125; times</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>     );<br>&#125;<br></code></pre></td></tr></table></figure><p>核心在于我们将 useState 的声明放在了父级组件，之后将hook中声明的state作为组件的参数传递到所有的子组件的prop上</p><p><code>function CustomizeButton(&#123;count, handleClick&#125;)</code> 这里就是定义了两个prop：count和handleClick</p><p>这种方式称为<strong>状态提升</strong></p><h1 id="工程基本结构"><a href="#工程基本结构" class="headerlink" title="工程基本结构"></a>工程基本结构</h1><p><a href="https://zh-hans.react.dev/learn/tutorial-tic-tac-toe">教程：井字棋游戏 – React 中文文档</a></p><p>以井字棋游戏为例，项目基本结构：</p><ul><li>public&#x2F;index.html 最终解析的目录页面</li><li>src&#x2F;index.js 应用和浏览器之间的桥梁</li><li>src&#x2F;style.css 样式文件</li></ul><p>其中 <code>index.js</code> 内的头几行非常关键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">StrictMode</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createRoot &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./styles.css&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;<br></code></pre></td></tr></table></figure><p>分别是：</p><ul><li>React 库</li><li>React 与 Web 浏览器对话的库（React DOM）</li><li>组件的样式</li><li><code>App.js</code> 里面创建的组件</li></ul><h1 id="井字棋demo"><a href="#井字棋demo" class="headerlink" title="井字棋demo"></a>井字棋demo</h1><h2 id="同个组件内显式调用函数的死循环"><a href="#同个组件内显式调用函数的死循环" class="headerlink" title="同个组件内显式调用函数的死循环"></a>同个组件内显式调用函数的死循环</h2><p>在井字棋实现过程中，遇到了死循环的现象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Board</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [squares, setSquares] = <span class="hljs-title function_">useState</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>));<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-keyword">const</span> nextSquares = squares.<span class="hljs-title function_">slice</span>();<br>    nextSquares[i] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>    <span class="hljs-title function_">setSquares</span>(nextSquares);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[0]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;handleClick(0)&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[1]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;handleClick(1)&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[2]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;handleClick(2)&#125;/</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[3]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;handleClick(3)&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[4]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;handleClick(4)&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[5]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;handleClick(5)&#125;/</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[6]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;handleClick(6)&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[7]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;handleClick(7)&#125;/</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[8]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;handleClick(8)&#125;/</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Square</span>(<span class="hljs-params">&#123; showValue, onSquareClick &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;square&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onSquareClick&#125;</span>&gt;</span></span><br><span class="language-xml">            &#123;showValue&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这是因为 <code>onClickHandle=&#123;handleClick(3)&#125;</code> 这种方式写，由于都在 Board 组件内声明，会直接调用Board组件中的handleClick进行setSquares重新渲染，然后由于重新渲染了Board，return时又会调用Board组件中的handleClick进行setSquares重新渲染，因此导致了无限循环</p><p>解决方案是套一层，我们可以定义9个不同的函数，分别调用handleClick传入0-8的index，但是也可以直接用箭头函数快速声明匿名函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Board</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [squares, setSquares] = <span class="hljs-title function_">useState</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>));<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-keyword">const</span> nextSquares = squares.<span class="hljs-title function_">slice</span>();<br>    nextSquares[i] = <span class="hljs-string">&quot;X&quot;</span>;<br>    <span class="hljs-title function_">setSquares</span>(nextSquares);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[0]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(0)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[1]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(1)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[2]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(2)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[3]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(3)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[4]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(4)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[5]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(5)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[6]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(6)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[7]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(7)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[8]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(8)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Square</span>(<span class="hljs-params">&#123; showValue, onSquareClick &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;square&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onSquareClick&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;showValue&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>在 React 中，我们通常使用 <code>onSomething</code> 命名事件的props，用<code>handleSomething</code> 命名处理事件的函数</p><p>例如上面，点击棋盘的事件我们命名为 <code>onSquareClick</code>，点击后更新棋盘的事件处理函数我们命名为 <code>handleClick</code> </p><h2 id="核心实现思路"><a href="#核心实现思路" class="headerlink" title="核心实现思路"></a>核心实现思路</h2><ul><li>基础组件绘制：编写 jsx &amp; 引入 props</li><li>实现落子：使用 props &amp; state</li><li>实现交替落子：在合适的位置定义额外的 state</li><li>校验一个格子只能落一次子：基础逻辑完善</li><li>计算胜者：简单算法 &amp; 整体流程把握（应该在什么时候计算胜者？）</li></ul><h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3><ul><li>棋盘组件——多个方格组件</li><li>方格组件——按钮</li></ul><h3 id="落子"><a href="#落子" class="headerlink" title="落子"></a>落子</h3><p>本质就是更改棋盘数组的数据</p><p>父级棋盘需要一个 state 来维护所有的格子的状态</p><p>当点击方格的时候，子组件（方格）需要能更新棋盘维护的格子的状态，采用 prop 的方式传递父组件（棋盘）的更新棋盘逻辑到 button 的 <code>onClick</code> 事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Board</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [squares, setSquares] = <span class="hljs-title function_">useState</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>));<br>  <span class="hljs-comment">//更新棋盘逻辑，更新指定方格</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">i</span>) &#123;<br>     <span class="hljs-comment">//保证数据不变性，直接copy一份副本  </span><br>     <span class="hljs-keyword">const</span> nextSquares = squares.<span class="hljs-title function_">slice</span>();<br>     nextSquares[i] = <span class="hljs-string">&quot;X&quot;</span>;<br>     <span class="hljs-title function_">setSquares</span>(nextSquares);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[0]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(0)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[1]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(1)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[2]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(2)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[3]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(3)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[4]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(4)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[5]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(5)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[6]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(6)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[7]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(7)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[8]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(8)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Square</span>(<span class="hljs-params">&#123; showValue, onSquareClick &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;square&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onSquareClick&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;showValue&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="交替落子"><a href="#交替落子" class="headerlink" title="交替落子"></a>交替落子</h3><ul><li>useState，由于只会有两种子，选择true&#x2F;false</li><li>每次一个人下完之后，更新true&#x2F;false同时更新落的子的符号</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Board</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [squares, setSquares] = <span class="hljs-title function_">useState</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>));<br>  <span class="hljs-comment">//再引入一个state,记录落子先后</span><br>  <span class="hljs-keyword">const</span> [xIsNext, setXIsNext] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">i</span>) &#123;<br>     <span class="hljs-keyword">const</span> nextSquares = squares.<span class="hljs-title function_">slice</span>();<br>     <span class="hljs-keyword">if</span> (xIsNext) &#123;<br>       nextSquares[i] = <span class="hljs-string">&quot;X&quot;</span>;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       nextSquares[i] = <span class="hljs-string">&quot;O&quot;</span>;<br>     &#125;<br>     <span class="hljs-title function_">setSquares</span>(nextSquares);<br>     <span class="hljs-comment">//更新落子顺序</span><br>     <span class="hljs-title function_">setXIsNext</span>(!xIsNext);  <br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      //...</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Square</span>(<span class="hljs-params">&#123; showValue, onSquareClick &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-comment">//...</span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一个格子只允许落一次"><a href="#一个格子只允许落一次" class="headerlink" title="一个格子只允许落一次"></a>一个格子只允许落一次</h3><p>在点击的处理函数逻辑中补充优先判断</p><p>如果已经有value了，直接返回不做任何处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Board</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [squares, setSquares] = <span class="hljs-title function_">useState</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>));<br>  <span class="hljs-keyword">const</span> [xIsNext, setXIsNext] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-comment">//放在最前面</span><br>     <span class="hljs-keyword">if</span>(squares[i])&#123;<br>          <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-comment">//...</span><br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="计算胜者"><a href="#计算胜者" class="headerlink" title="计算胜者"></a>计算胜者</h3><p><strong>每一次渲染棋盘的时候</strong>（注意不是点击按钮）都优先计算是否出现了胜者</p><p>如果出现了胜者，返回获胜的是X还是O</p><p>一个简单的算法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateWinner</span>(<span class="hljs-params">board</span>) &#123;<br> <span class="hljs-comment">//枚举所有的获胜判断条件</span><br>  <span class="hljs-keyword">const</span> lines = [<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>    [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>],<br>  ];<br>  <span class="hljs-comment">//遍历每一&quot;行&quot;，如果出现同符号说明获胜了</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; lines.<span class="hljs-property">length</span>; index++) &#123;<br>    <span class="hljs-keyword">const</span> [a, b, c] = lines[index];<br>    <span class="hljs-keyword">if</span> (board[a] &amp;&amp; board[a] === board[b] &amp;&amp; board[a] === board[c]) &#123;<br>     <span class="hljs-comment">//返回获胜的棋子</span><br>      <span class="hljs-keyword">return</span> board[a];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Board</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [squares, setSquares] = <span class="hljs-title function_">useState</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>));<br>  <span class="hljs-keyword">const</span> [xIsNext, setXIsNext] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">i</span>) &#123;<br><span class="hljs-comment">//...</span><br>  &#125;<br>  <span class="hljs-comment">//每一次渲染的时候都计算获胜者</span><br>  <span class="hljs-keyword">const</span> winner = <span class="hljs-title function_">calculateWinner</span>(squares);<br>  <span class="hljs-keyword">let</span> msg;<br>  <span class="hljs-keyword">if</span> (winner) &#123;<br>    msg = <span class="hljs-string">&quot;Winner is:&quot;</span> + winner;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    msg = <span class="hljs-string">&quot;Next player is: &quot;</span> + (xIsNext ? <span class="hljs-string">&quot;X&quot;</span> : <span class="hljs-string">&quot;O&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;status&quot;</span>&gt;</span>&#123;msg&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"> //...</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>点击的棋盘之后：优先判断，是否出现了胜者，已经出现了直接return，同时如果已经在一个位置下下棋子就不允许在更新棋盘，也是直接return</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">i</span>) &#123;<br>  <span class="hljs-keyword">if</span> (squares[i] || <span class="hljs-title function_">calculateWinner</span>(squares)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;       <br></code></pre></td></tr></table></figure><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Board</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [squares, setSquares] = <span class="hljs-title function_">useState</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">null</span>));<br>  <span class="hljs-keyword">const</span> [xIsNext, setXIsNext] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-keyword">if</span> (squares[i] || <span class="hljs-title function_">calculateWinner</span>(squares)) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> nextSquares = squares.<span class="hljs-title function_">slice</span>();<br>    <span class="hljs-keyword">if</span> (xIsNext) &#123;<br>      nextSquares[i] = <span class="hljs-string">&quot;X&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      nextSquares[i] = <span class="hljs-string">&quot;O&quot;</span>;<br>    &#125;<br>    <span class="hljs-title function_">setSquares</span>(nextSquares);<br>    <span class="hljs-title function_">setXIsNext</span>(!xIsNext);<br>  &#125;<br>  <span class="hljs-keyword">const</span> winner = <span class="hljs-title function_">calculateWinner</span>(squares);<br>  <span class="hljs-keyword">let</span> msg;<br>  <span class="hljs-keyword">if</span> (winner) &#123;<br>    msg = <span class="hljs-string">&quot;Winner is:&quot;</span> + winner;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    msg = <span class="hljs-string">&quot;Next player is: &quot;</span> + (xIsNext ? <span class="hljs-string">&quot;X&quot;</span> : <span class="hljs-string">&quot;O&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;status&quot;</span>&gt;</span>&#123;msg&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[0]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(0)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[1]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(1)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[2]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(2)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[3]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(3)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[4]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(4)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[5]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(5)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;board-row&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[6]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(6)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[7]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(7)&#125; /&gt;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">showValue</span>=<span class="hljs-string">&#123;squares[8]&#125;</span> <span class="hljs-attr">onSquareClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> handleClick(8)&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Square</span>(<span class="hljs-params">&#123; showValue, onSquareClick &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;square&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onSquareClick&#125;</span>&gt;</span></span><br><span class="language-xml">      &#123;showValue&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateWinner</span>(<span class="hljs-params">board</span>) &#123;<br>  <span class="hljs-keyword">const</span> lines = [<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>    [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>],<br>  ];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; lines.<span class="hljs-property">length</span>; index++) &#123;<br>    <span class="hljs-keyword">const</span> [a, b, c] = lines[index];<br>    <span class="hljs-keyword">if</span> (board[a] &amp;&amp; board[a] === board[b] &amp;&amp; board[a] === board[c]) &#123;<br>      <span class="hljs-keyword">return</span> board[a];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nand2Tetris|Assembler</title>
    <link href="/2025/01/22/Nand2Tetris-Assembler/"/>
    <url>/2025/01/22/Nand2Tetris-Assembler/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编语句翻译"><a href="#汇编语句翻译" class="headerlink" title="汇编语句翻译"></a>汇编语句翻译</h1><p>是连接硬件和软件的关键，也是课程第二部分开发的翻译器中最低级最接近硬件的一层</p><p>由于前面我们已经介绍了Hack指令集中A和C指令的二进制形式了（例如第一位0是A指令，1是C指令，C还额外分成comp,dest和jmp等）</p><p>因此现在想要实现Assembler本质上就是将对应的Hack指令翻译转换成二进制指令</p><h2 id="先从最简单的A指令开始说起"><a href="#先从最简单的A指令开始说起" class="headerlink" title="先从最简单的A指令开始说起"></a>先从最简单的A指令开始说起</h2><p>我们前面的学习中介绍了A指令可以有两种operands，直接数，或者是符号。那时我们也提到了符号表实际上就是汇编器去实现的，汇编语言开发者并不关心。</p><ul><li>直接数：将其值转化为16-bit binary，首位为0</li><li>符号：后面再说</li></ul><h2 id="C指令"><a href="#C指令" class="headerlink" title="C指令"></a>C指令</h2><p>首先前三位一定是111</p><p>之后七位是comp计算逻辑</p><p>三位dest目的地</p><p>三位跳转逻辑jmp</p><p>其实真值表都有了，所有的排列组合枚举都出来了，直接拆分成comp、dest和jmp三个部分查表最终组装在一起即可得出最终的C指令二进制形式</p><p>（定义一个指令转换器接口，转换指定一行的Hack汇编语句）</p><h1 id="解析完整程序"><a href="#解析完整程序" class="headerlink" title="解析完整程序"></a>解析完整程序</h1><p>对于整段完整的汇编程序，我们需要关注三个部分：</p><ul><li>空白换行，什么时候换，注释怎么忽略，缩进怎么处理</li><li>指令转换</li><li>符号处理</li></ul><h2 id="空白换行"><a href="#空白换行" class="headerlink" title="空白换行"></a>空白换行</h2><p>针对空白换行的需求：扫描文本并替换指定部分（注释）为空内容即可</p><h2 id="指令转换"><a href="#指令转换" class="headerlink" title="指令转换"></a>指令转换</h2><p>针对指令转换，从上至下，每一行内容进行转换，具体转换逻辑上面已经提到了</p><h2 id="符号处理"><a href="#符号处理" class="headerlink" title="符号处理"></a>符号处理</h2><p>针对符号处理，有点复杂，主要包括三种符号：</p><ul><li>Hack计算机自带的预定义符号，例如KBD，SCREEN</li><li>标签符号，程序过程中出现的用户编写的标签，例如LOOP，END等</li><li>变量符号，汇编程序定义的变量，例如i,j,k等</li></ul><h3 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h3><p>这个最简单，本质上就是一个kv map，扫描到内容后直接获取Hack计算机规定的指定value即可，例如R0就一定是0</p><p>（放在内存的kv map，实际上也不用维护，直接static，表示Hack计算机所支持的所有预定义符号集）</p><h3 id="标签符号"><a href="#标签符号" class="headerlink" title="标签符号"></a>标签符号</h3><p>扫描程序，标签所在行号就是最终的结果</p><h3 id="变量符号"><a href="#变量符号" class="headerlink" title="变量符号"></a>变量符号</h3><p>只要不是预定义符号或者是标签符号，就都是自定义符号</p><p>Hack语言规定，自定义符号绑定的实际地址从16开始</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此我们可以归纳总结，所谓汇编器的符号表，本质上只是一个在初始化时根据硬件特性预先维护一些数据的map，之后在运行过程中扫描文本，更新这个map</p><p>符号表的生命周期：</p><ul><li>程序启动时预先放入硬件系统规定的预定义符号</li><li>第一遍扫描代码，重点关注汇编代码中的标签，统计行数并维护标签的符号表信息</li><li>第二遍扫描代码，逐行翻译，并对变量符号进行更新维护</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>Nand2Tetris</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nand2Tetris|Hack Computer</title>
    <link href="/2025/01/16/Nand2Tetris-HackComputer/"/>
    <url>/2025/01/16/Nand2Tetris-HackComputer/</url>
    
    <content type="html"><![CDATA[<h1 id="现代计算机的体系结构"><a href="#现代计算机的体系结构" class="headerlink" title="现代计算机的体系结构"></a>现代计算机的体系结构</h1><p>主要特征：</p><ul><li>包括处理器，寄存器，内存</li><li>将运行程序存储起来的概念</li><li>通用抽象</li></ul><p><strong>计算机的本质：使用指令来操纵数据的机器</strong></p><p>而从硬件技术角度来看，计算机也可以看作是一组通过总线连接的芯片</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250116144759155.png" alt="硬件角度来看"></p><p>从上图我们可以看出，针对上面的 CPU 架构：</p><ul><li>内存存储了只读程序本身和运行时操作的数据</li><li>CPU包括多个数据寄存器，地址寄存器，PC指针以及 ALU</li></ul><p>我们上一节实际上是在没有实际硬件的情况下，<strong>用 hack 汇编来模拟 Hack 计算机中 内存和 CPU 的行为</strong></p><h1 id="取址-执行的循环"><a href="#取址-执行的循环" class="headerlink" title="取址-执行的循环"></a>取址-执行的循环</h1><ul><li>CPU的PC总是指向下一条需要执行的指令的地址，CPU通过地址总线，根据PC地址获取到内存中（只读内存部分）的指令数据</li><li>取出只读内存中的指令，通过控制总线传向CPU的ALU</li><li>这条指令中指定段的指定几个bit会被ALU解析，解析后CPU知道是进行何种的操作，操作的是CPU寄存器还是内存的寄存器（解析的语义由指令集和硬件设计特性共同决定）</li><li>CPU根据指令解析的结果，执行指令</li><li>更新PC（JMP或者是正常执行都会更新PC中的地址）</li><li>。。。（回到第一步）</li></ul><p>在上述过程中存在一个值得讨论的地方：</p><p>对内存输入一个地址，在CPU侧，输出的数据可以是指令本身（获取指令阶段），也可以是指令所需要的数据（执行指令阶段），CPU应该如何区分？</p><p>根据计算机硬件设计架构的不同，有两种：</p><ul><li>指令和数据分开存放的，我们称之为 two memory machine（哈佛）</li><li>指令和数据一起存放的，我们称之为 one memory machine（冯诺依曼）</li></ul><h2 id="one-memory-machine"><a href="#one-memory-machine" class="headerlink" title="one memory machine:"></a>one memory machine:</h2><p>我们通过 MUX 和 DMUX 来进行多路选择，在内存输入侧，通过 MUX 来选择地址是数据地址还是指令地址；在内存输出侧，通过 DMUX 来将输出传输到 控制总线&#x2F;数据总线，如果是获取指令阶段，就通过 DMUX 将指令输出到控制总线上。如果是指令执行阶段，就通过 DMUX 将数据输出到数据总线上；</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250117143707436.png"></p><h2 id="two-memory-machine"><a href="#two-memory-machine" class="headerlink" title="two memory machine:"></a>two memory machine:</h2><p>由于指令和数据在物理层面是分开存放，因此不存在上述需要通过多路复用和解复用器来进行区分的情况。在获取指令时CPU只会把指令地址传输到ROM侧，在指令执行时CPU只会把数据地址传输到RAM侧</p><p>这种架构意味着处理器在同一时钟周期内可以同时访问两个存储器，也就是同时取指和取操作数，运算能力更强。也叫做哈佛架构</p><blockquote><p><strong>ARM 处理器</strong>可以实现某些哈佛架构特性，尽管它们通常属于更灵活的“哈佛式”架构（分开指令和数据总线，但内存还是共享的</p><p>现代CPU引入了指令缓存和数据缓存，能够高效地访问指令和数据，同时又能将程序和数据存储在同一块内存中。</p></blockquote><h1 id="Hack-CPU"><a href="#Hack-CPU" class="headerlink" title="Hack CPU"></a>Hack CPU</h1><h2 id="Hack-指令"><a href="#Hack-指令" class="headerlink" title="Hack 指令"></a>Hack 指令</h2><p>A指令：第一位是0</p><p>C指令：前三位是1，后面分为三个部分：计算、目的地、跳转</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/Ch0401.png" alt="C-instruction"></p><p>其中计算的部分又分为7bit：</p><ul><li>第一个bit a:决定CPU将解析A寄存器里的数据是字面地址还是要访存寻址找数据</li><li>后面6bit c:操作ALU作为输入</li></ul><p>目的地包含3bit:八种不同的结果存储位置排列组合</p><p>跳转包含3bit:也是根据计算结果控制八种不同排列组合跳转</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250117150210235.png"></p><h2 id="CPU抽象"><a href="#CPU抽象" class="headerlink" title="CPU抽象"></a>CPU抽象</h2><p>我们都知道，CPU在运行期间的工作，通俗的来概括其实就是两步：</p><ul><li>执行当前指令</li><li>找出下一条要执行的指令准备执行</li></ul><p>下面我们将详细展开描述这个过程</p><h3 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h3><p>首先会去解析是 A 指令还是 C 指令</p><p>(1) 如果是 A 指令则直接设置 A寄存器的 value</p><p>(2) 如果是 C 指令，则<strong>基于 A 寄存器， D寄存器以及来自内存数据输入 inM 的数据</strong>，根据指令执行指定的 ALU 操作</p><ul><li>之后将 ALU 的输出，传输到指令指定的 A, D 或者是内存 outM</li><li>如果计算结果需要写回内存，CPU会有一个输出位 1bit 的 writeM 表示是否需要写回内存，写回的是这个位为1，然后 addressM 为具体地址（其实就是指令包含的）需要赋给A寄存器</li></ul><h2 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h2><h3 id="区分A指令和C指令"><a href="#区分A指令和C指令" class="headerlink" title="区分A指令和C指令"></a>区分A指令和C指令</h3><p>实现的方式是将指令的 MSB 最高位传入 MUX 的控制位</p><h3 id="实现C指令"><a href="#实现C指令" class="headerlink" title="实现C指令"></a>实现C指令</h3><p>C指令的每一个组成部分都有专门的硬件来分别处理，整坨的bit作为一个整体经过硬件设计后指示CPU应该如何行动</p><blockquote><p>computation bits</p></blockquote><p>我们之前说过C指令中的操作部分(comp)还可以分为a和c，a指示CPU将解析A寄存器中数据究竟是字面地址还是需要访存，而c才是 真正的ALU输入</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250122150201829.png"></p><p>得出计算结果后ALU会同时将结果传输到A、D以及outM里（关闭开始通过控制位）</p><blockquote><p>destination bits</p></blockquote><p>根据dest的一坨bit，我们按顺序设置A、D的控制位以及writeM的值，如图，可以发现这里其实就是CPU的解释逻辑和指令集设计是绑定在一起的，010排列组合的dest bits就是指向D结果，不会存到A或者是内存里</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250122150726722.png"></p><h3 id="实现跳转"><a href="#实现跳转" class="headerlink" title="实现跳转"></a>实现跳转</h3><p>TODO</p><h1 id="Mem"><a href="#Mem" class="headerlink" title="Mem"></a>Mem</h1><p>Hack机器由于采取的是分开存储程序和指令，因此指令内存是一个插拔式的ROM</p><p>物理层面来说我们可以直接拔插ROM芯片</p><p>软件模拟层面来说就是读取不同的包含指令的文件来实现指令ROM的模拟</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>Nand2Tetris</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nand2Tetris|Machine Language</title>
    <link href="/2025/01/07/Nand2Tetris-MachineLanguage/"/>
    <url>/2025/01/07/Nand2Tetris-MachineLanguage/</url>
    
    <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>在传统计算机系统中：</p><p>CPU包括 ALU 和 一些通用寄存器，负责数学和逻辑运算、内存操作和控制操作</p><p>内存主要可以分为：程序和具体数据</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20241225144717977.png"></p><p>再具体来说，如下图</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20241225144935678.png"></p><p>CPU操作寄存器，主要包括两大类：</p><ul><li>归属于CPU的寄存器，一般直接通过名字访问</li><li>归属于内存的寄存器，一般需要通过地址进行访问</li></ul><p>我们所说的机器语言，本质上其实只是<strong>一种控制CPU访问并且操作寄存器的形式</strong></p><p>寄存器主要可以通俗的分为：</p><ul><li>数据寄存器 <code>Data registers</code></li><li>地址寄存器 <code>Address register</code></li><li>指令寄存器 <code>Instruction register</code></li></ul><p>不同计算机的寄存器数量和寄存器大小（位宽）各不相同</p><p>不同计算机体系结构的机器语言，语义各不相同；但是他们的目的或者说作用场景都是一致的：<strong>访问并且操作寄存器</strong></p><h1 id="Hack-Computer"><a href="#Hack-Computer" class="headerlink" title="Hack Computer"></a>Hack Computer</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>16 bit 的计算机，有两个存储单元，RAM 和 ROM</p><p>其中 ROM 是程序内存，只存储指令，只读</p><p>RAM 是数据内存，存储数据，可读可写</p><p>ROM 和 RAM 共同使用一个寄存器 A，这个寄存器可以用来存放地址也可以用来存放数据，本质都是16bit的数据</p><h2 id="A基础指令"><a href="#A基础指令" class="headerlink" title="A基础指令"></a>A基础指令</h2><p>A指令用于写入地址寄存器，其中 @符号表示写入A寄存器，例如 @19 就表示向地址寄存器中写入19的数据，这样就会导致 ROM[A] 变得可见，同时 RAM[A] 也就是 M 也变得可见（可访达）</p><p>例如我们想要将 RAM[100] 中的数据写入到 RAM[200] 中，直观描述就是： RAM[200] &lt;- RAM[100]，可以使用如下的指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">@<span class="hljs-number">100</span> <span class="hljs-comment">//让A地址寄存器中值位100，此时M就是RAM[100]</span><br>D=M  <span class="hljs-comment">//将M[100]的数据写入数据寄存器D中</span><br>@<span class="hljs-number">200</span> <span class="hljs-comment">//获取M[200]</span><br>M=D  <span class="hljs-comment">//更新M[200]=D=M[100]</span><br></code></pre></td></tr></table></figure><p>简单测试一下</p><p> Computes: RAM[2] &#x3D; RAM[0] + RAM[1] + 17</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//RAM[0]</span><br>@<span class="hljs-number">0</span><br>D=M<br><span class="hljs-comment">//RAM[0]+RAM[1]</span><br>@<span class="hljs-number">1</span><br>D=D+M<br><span class="hljs-comment">//RAM[0] + RAM[1] + 17</span><br>@<span class="hljs-number">17</span><br>D=D+A  <span class="hljs-comment">//A当数据寄存器用</span><br><span class="hljs-comment">//RAM[2]= RAM[0] + RAM[1] + 17</span><br>@<span class="hljs-number">2</span><br>M=D  <br></code></pre></td></tr></table></figure><h2 id="C指令实现条件跳转"><a href="#C指令实现条件跳转" class="headerlink" title="C指令实现条件跳转"></a>C指令实现条件跳转</h2><p>在 Hack 指令中，实现跳转也是依靠组合指令，A指令来设置地址寄存器的数据，用于指示要跳转到哪一行程序指令</p><p>此后 ROM[A] 就会自动选择，通过 JMP 指令来实现跳转，跳转到 ROM 中指定位置的程序读取</p><p>例如 0;JMP 的语义就是跳转去执行 ROM[A] （也就是 声明 @ 之后自动选择到的）中指向的指令，其中开头的 0 是个无意义前缀</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20241230151406329.png" alt="image-20241230151406329"></p><p>上图中的 D 可以替换为任意一种 ALU 可以计算的指令</p><p>例如 <code>if(D=0) goto 300</code> 的 hack 语言实现就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">@300<br>D;JEQ<br></code></pre></td></tr></table></figure><p><code>if(RAM[3]&lt;100) goto 12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">@3<br>D=M  //RAM[3]<br>@100<br>D=D-A //RAM[3]-100<br>@12<br>D;JLE<br></code></pre></td></tr></table></figure><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>我们可以通过 <code>@i</code> 等<strong>任意非常量</strong>的方式，声明一个在我们广义上来看是变量的元素，<strong>编译器会将这个变量和对应分配的地址进行绑定</strong>，在 hack 语言的使用者来看，只需要每次向 A 地址寄存器中指定相同名称的非常量名，即可通过 M 访问这个变量在内存进行读写</p><p>例如：如下的高级语言代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">i = <span class="hljs-number">1</span><br>sum = <span class="hljs-number">0</span><br><br>sum = sum + <span class="hljs-type">i</span> <br><span class="hljs-variable">i</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>在 hack 语言上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">//i=1<br>@i<br>M = 1<br>//sum=0<br>@sum<br>M = 0<br>//sum = sum + i<br>@i<br>D=M<br>@sum<br>M=M+D<br>//i = i + 1<br>@i<br>M=M+1<br></code></pre></td></tr></table></figure><h3 id="Pre-defined-Symbol-in-Hack"><a href="#Pre-defined-Symbol-in-Hack" class="headerlink" title="Pre-defined Symbol in Hack"></a>Pre-defined Symbol in Hack</h3><p>hack 中还存在 16 个内置的变量，我们有时也会称他们虚拟寄存器 R0 … R15</p><p>其实对应的就是 hack 系统中内存 0-15，只是更易于维护和编写 hack 代码</p><h2 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h2><p>通过@也可以定义标签来实现某些兼容了低级语言的编程语言中 <code>goto</code> 表达式的效果</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250103155937324.png" alt="image-20250103155937324"></p><p>其实这里的 @CONT 或者是 @LOOP 可以等价于是变量定义的一种特殊声明，因为底层是汇编器去维护所有标签和对应所在的程序地址关系，hack语言编写者只需要@之后就会自动选择ROM[A]中对应的地址</p><h1 id="Low-Level-Programming"><a href="#Low-Level-Programming" class="headerlink" title="Low Level Programming"></a>Low Level Programming</h1><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>综合上述的概念，我们现在对一段程序进行解析</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250103161112129.png"></p><p>除此之外，还有一个最佳实践：由于内存永远都不会是空的，因此需要在每一个汇编代码结束时设置死循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">(END)<br>@END<br>0;JMP<br></code></pre></td></tr></table></figure><blockquote><p>动手实践</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//if (R0 &gt; R1) then R2 = R0 </span><br><span class="hljs-comment">//else              R2 = R1</span><br></code></pre></td></tr></table></figure><p>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">R2 = R1<br><span class="hljs-title function_">if</span><span class="hljs-params">(R0 &lt;= R1)</span> goto <span class="hljs-type">END</span><br><span class="hljs-variable">R2</span> <span class="hljs-operator">=</span> R0<br>END:<br></code></pre></td></tr></table></figure><p>hack assembly</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">//R2=R1<br>@1<br>D=M<br>@2<br>M=D<br>//if(R0 &lt;= R1) goto END<br>@0<br>D=M<br>@1 <br>D=D-M<br>@END<br>D;JLE<br>//R2=R0<br>@0<br>D=M<br>@2<br>M=D<br>(END)<br>@END<br>D;JMP<br></code></pre></td></tr></table></figure><h2 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h2><p>这部分其实就是上一个部分的差不多内容，会基础部分就会这一个部分</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250103170536922.png"></p><h2 id="Pointer-based-processing"><a href="#Pointer-based-processing" class="headerlink" title="Pointer-based processing"></a>Pointer-based processing</h2><p>通过上面的描述也不难发现，如果想要实现类似指针的操作，其实就是将具体数值赋给 A 地址寄存器即可</p><p>例如下面这个需求</p><blockquote><p>Sets RAM[R0] to –1  对应高级编程语言的 *p &#x3D; -1，其中p指针的值就是R0</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">@R0<br>A=M<br>M=-1<br></code></pre></td></tr></table></figure><p>上面的A&#x3D;M 其实就是将 R0 中包含的内容作为地址</p><p>下面一句的 M &#x3D; -1 则是将 RAM[A] 中的数据设置为 -1</p><blockquote><p>Gets R1 &#x3D; RAM[R0] 对应高级编程语言的 r1 &#x3D; *p</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">@R0<br>A=M<br>D=M<br>@R1<br>M=D<br></code></pre></td></tr></table></figure><h3 id="Array-Processing"><a href="#Array-Processing" class="headerlink" title="Array Processing"></a>Array Processing</h3><p>对于高级编程语言中数组的处理需要引入一个基础地址和 offset 的概念，其实也就是对应数组的起始分配位置和数组数据类型（每一个元素所占内存空间）</p><p>也就是数组类型的指针也会在内存中进行存储，而指针的具体位置我们并不关心，由编译器管理，指针包含的数据才是 arr 的实际地址</p><p>假设伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Variable declarations</span><br> <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> ...<br> <span class="hljs-comment">// Enters some values into the array</span><br> <span class="hljs-comment">// (code omitted) </span><br>...<br> <span class="hljs-comment">// Sums up the array elements</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br> sum = sum + arr[j];<br> &#125;<br> ...<br> <span class="hljs-comment">// Increments each array element</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br> arr[j] = arr[j] + <span class="hljs-number">1</span><br> &#125;<br> ...<br></code></pre></td></tr></table></figure><p>对应的 hack 语言如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">//对于 sum = sum + arr[j]<br>//1.arr[j]的获取，首先需要确定基础地址<br>@arr<br>D=M  //基础地址<br>@j<br>A=D+M //偏移后的地址<br>D=M<br>//2.sum数值的获取<br>@sum<br>D=D+M<br>//3.sum = sum + arr[j]<br>M=D<br><br><br>//对于 arr[j] = arr[j] + 1<br>@arr<br>D=M<br>@j<br>A=D+M<br>M=M+1<br></code></pre></td></tr></table></figure><p>所有高级语言的数组访问表达式 arr[expression] 都可以编译成 Hack 代码，使用低级语法 A &#x3D; arr + expression 来实现访问</p><h1 id="Hack-Language"><a href="#Hack-Language" class="headerlink" title="Hack Language"></a>Hack Language</h1><h2 id="C指令"><a href="#C指令" class="headerlink" title="C指令"></a>C指令</h2><p>一段完整的 C 指令包含三个部分，计算表达式comp，目的地dest，跳转jump，其实本文前面的部分都是在用到 C 指令，只是没有建立完整的概念</p><p>C指令的语义为：计算 comp 的值并将结果存储在 dest 中。如果 (comp jump 0)，则分支执行 ROM[A]</p><p>例如：</p><ul><li>Sets the D register to -1 ：<code> D = -1</code></li><li>Sets D and M to the value of the D register, plus 1： <code>DM = D + 1</code></li><li>If (D-1 &#x3D; 0) jumps to execute the instruction stored in ROM[56]</li><li>@56</li><li>D-1;JEQ</li><li>goto LOOP</li><li>@LOOP</li><li>0;JMP</li></ul><p>我们可以发现，<strong>C指令和A指令几乎都是成对出现的</strong>，在计算之前我们需要 A 指令来取地址，跳转之前也需要 A 指令来设置具体要跳转的内存地址</p><p>C 指令使用相同的地址同时访问数据存储器和指令存储器是没有意义的；所以给出的最佳实践是：C指令要么指定 M 要么指定跳转，不能同时指定两者</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>处理输出和输出的方式有两个维度：</p><ul><li>使用高级编程语言中提供的库<ul><li>输出：用于处理文本、图形、音频、视频等的 I&#x2F;O </li><li>输入：readInt, readString 等</li></ul></li><li>低级层面：<ul><li>输出：使用驻留在内存中的位图(<strong>bitmap</strong>)直接操作位</li><li>输入：直接读取裸 bit 数据</li></ul></li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>屏幕内存映射，其实就是将屏幕可以显示的像素，映射到内存中具体的地址位置：</p><p>一个 8K 内存块，专用于表示黑白显示单元，屏幕分辨率是 512*256。</p><p>基地址：SCREEN &#x3D; 16384（在 hack 语言中是一个预定义符号 @SCREEN）</p><p>通过在屏幕内存映射map中写入指定的某个bit来呈现输出</p><p>由于 hack 中数据字长是16bit，因此屏幕上每一行的512个像素实际上对应内存中的 512&#x2F;16 &#x3D; 32行，如下图</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20250107164221858.png"></p><p>给出几个样例：</p><blockquote><p>将输出屏幕第一行的前16个bit设置为全黑（1）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">@SCREEN<br>M=-1<br></code></pre></td></tr></table></figure><blockquote><p>将输出屏幕的第三行（行号为2）的前16个bit设置为全黑</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">@64<br>D=A      //第三行偏移量<br>@SCREEN<br>A=A+D    //定位到第三行<br>M=-1<br></code></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入也有键盘内存映射，只需要分配 16 bit 的长度空间即可表示键盘的输入</p><p>也有一个预定义符号 @KBD &#x3D; 24576</p><p>当按下键盘上的某个键时，该键的字符代码就会出现在键盘内存映射中，内存中 24576 地址的数据就是用户此时的输入字符对应 code （Hack 采用 Unicode）的二进制数据；例如 A &#x3D; 65，键盘按下 A , RAM[KBD] &#x3D; 65，当键盘没有按下任何按键的时候， RAM[KBD] &#x3D; 0</p><blockquote><p>如果用户输入了 q 则跳转到 END label 结束汇编程序</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">@KBD<br>D=M<br>@113<br>D=D-A<br>@END<br>D;JEQ<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://github.com/lng205/Nand2Tetris/blob/master/04/readme.md">Nand2Tetris&#x2F;04&#x2F;readme.md at master · lng205&#x2F;Nand2Tetris</a></p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>Nand2Tetris</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年度总结</title>
    <link href="/2024/12/31/2024%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <url>/2024/12/31/2024%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>24年上半年还在学校，亲身体验了一段大四老狗的生活：工作算是定了下来，唯一能在忙的就是毕业论文，那一段时间过的还算是大学四年里较为轻松的一段 XD</p><p>看着校园里来往的大一新生，想起自己四年前刚步入校园的时候也曾经和他们一样，现在经历了摆烂、迷茫、焦虑后，自己没几个月也要离开这个校园了，时间真是快啊。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>庆幸自己能在就业环境这么差的一年 选择了一份满意的 offer。</p><p>公司算是中厂吧，整体业务方向也还可观；项目组团队氛围很好，同事、导师和部门 leader人也很不错。</p><p>目前项目产品需求不算少但也不会很忙，虽然从毕业后到现在也经历过加班995，但是好在周末能有固定的双休。（当然有的时候会在家里修bug XD）</p><p>在学校的时候瞧不起 CRUD，一味的追求什么分布式微服务，各种技术栈吹的昏天黑地，工作后自己写的代码依托，各种低内聚高耦合，牵一发动全身，低并发编程，第一次负责的模块上测试环境直接报错 XD </p><p>其实 CRUD远没想象的那么简单，只要你的系统背靠关系型数据库，业务说白了就是换着花样的 CRUD。能把 CRUD 做好也是一种本事，我也还需要更多的技术沉淀和经验总结。</p><p>除了基础的 CRUD 学的更花、写的更快之外，更多的还是业务模型抽象，需求抽象，对产品业务的理解更高了一个层次。一个需求功能下来，现在可以快速抽象成需要哪些字段，这里字段配置应该是什么样的？前端客户端应该要展示哪些？哪些功能细节可以做成配置文件？要用上哪些中间件？性能要求如何？这些都是我在学校里自己写 demo 的时候没有体会到的。<strong>技术始终是为业务服务，贴合实际业务的学习、业务驱动的学习是最有效的学习。</strong></p><p>希望能沉淀下去，有机会在实际业务方向上更进一步。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h2 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h2><p>今年的游戏玩了真的不少，截至到写字的今天，前前后后通关了15款，简单做个总结吧：</p><ul><li>最终幻想10</li><li>勇者斗恶龙11S</li><li>光环2</li><li>猎天使魔女2</li><li>忍龙2</li><li>GTASA</li><li>意航员</li><li>马力欧64</li><li>马力欧惊奇</li><li>伊苏10</li><li>宇宙机器人无线控制器使用指南</li><li>宇宙机器人</li><li>寂静岭2重制版</li><li>生化危机4重制版</li></ul><blockquote><p>年度最佳游戏：宇宙机器人</p></blockquote><p>终于也是在工作后用第一笔转正工资买了心心念念的 PS5 和宇宙机器人。虽然在此之前一直觉得 PS5 上没独占游戏，自己有高配PC，没必要买。但是工作下班回家实在是不想碰电脑，有一种在加班的错觉XD</p><p>感谢 Team Asobi 这帮对游戏艺术有独到理解，真正热爱电子游戏的真玩家们制作了这款游戏，将真正次世代的 Dualsense 手柄硬件特性和出色的 3D 平台跳跃关卡设计发挥到了极致，让我找回了游戏本身最初的目的，最纯粹的快乐。那些曾经存在过但是现在已经消失的遗憾ip和那些陪伴玩家们一同成长、见证了 PlayStation 30年来发展的经典系列角色能够集结在这个游戏，就是写给 PlayStation 老玩家最好的情书。</p><h2 id="驾照"><a href="#驾照" class="headerlink" title="驾照"></a>驾照</h2><p>上半年起早贪黑学了三个月还是四个月的车总算是拿下了驾照。</p><p>选择了一个离家很远的驾校，好几天都是早上六点爬起来练科三。好在教练是朋友推荐的，人很好，点赞。</p><p>虽然科三还是考了两次，构式监考官第二次机会强判我不合格，但是也是体验到了成年人生活的常态化失败XD</p>]]></content>
    
    
    <categories>
      
      <category>杂谈&amp;人生哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java|Bulit-in Functional Interface</title>
    <link href="/2024/12/24/Java-Bulit-in-Functional-Interface/"/>
    <url>/2024/12/24/Java-Bulit-in-Functional-Interface/</url>
    
    <content type="html"><![CDATA[<p>所有的函数式接口实现类，都可以用 lambda 表达式来简化书写，关注实现本身</p><h1 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h1><p>对应常见操作：<code>stream().filter()</code></p><h2 id="基础逻辑关系"><a href="#基础逻辑关系" class="headerlink" title="基础逻辑关系"></a>基础逻辑关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetEvenNumber</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>      System.out.println(findEvenResult(list));<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">findEvenResult</span><span class="hljs-params">(List&lt;Integer&gt; originalData)</span> &#123;<br>      Predicate&lt;Integer&gt; even = num -&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">return</span> originalData.stream()<br>              .filter(even)<br>              .collect(Collectors.toList());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合逻辑关系"><a href="#组合逻辑关系" class="headerlink" title="组合逻辑关系"></a>组合逻辑关系</h2><p>下次再进行逻辑组合就不需要两次 filter 了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetEvenNumber</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>      System.out.println(findEvenAndGreaterThanFiveResult(list));<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">findEvenAndGreaterThanFiveResult</span><span class="hljs-params">(List&lt;Integer&gt; originalData)</span> &#123;<br>      Predicate&lt;Integer&gt; even = num -&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>      Predicate&lt;Integer&gt; greaterThanFive = num -&gt; num &gt; <span class="hljs-number">5</span>;<br>      <span class="hljs-keyword">return</span> originalData.stream()<br>              .filter(even.and(greaterThanFive))<br>              .collect(Collectors.toList());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理可以适用于 or 逻辑关系操作</p><blockquote><p>注意 and 和 or 都是会直接断路的操作</p><p>等价于 &amp;&amp; 和 ||</p></blockquote><h2 id="逻辑取反"><a href="#逻辑取反" class="headerlink" title="逻辑取反"></a>逻辑取反</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">findOddResult</span><span class="hljs-params">(List&lt;Integer&gt; originalData)</span> &#123;<br>   Predicate&lt;Integer&gt; even = num -&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>   Predicate&lt;Integer&gt; odd = even.negate();<br>   <span class="hljs-keyword">return</span> originalData.stream()<br>           .filter(odd)<br>           .collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="直接判断是否相等"><a href="#直接判断是否相等" class="headerlink" title="直接判断是否相等"></a>直接判断是否相等</h2><p>Predicate 这个函数式接口中提供了一个静态方法用于直接获取 Predicate 断言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">findEqFive</span><span class="hljs-params">(List&lt;Integer&gt; originalData)</span> &#123;<br>   Predicate&lt;Integer&gt; equalFive = Predicate.isEqual(<span class="hljs-number">5</span>);<br>   Optional&lt;Integer&gt; first = originalData.stream()<br>           .filter(equalFive)<br>           .findFirst();<br>   <span class="hljs-keyword">return</span> first.orElse(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">negate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title function_">isEqual</span><span class="hljs-params">(Object targetRef)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span> == targetRef)<br>                ? Objects::isNull<br>                : object -&gt; targetRef.equals(object);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p>对应常见应用场景：<code>stream().map()</code></p><h2 id="一个输入一个输出"><a href="#一个输入一个输出" class="headerlink" title="一个输入一个输出"></a>一个输入一个输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toUpperCase</span><span class="hljs-params">(String s)</span> &#123;<br>   Function&lt;String, String&gt; upper = str -&gt; str.toUpperCase(Locale.ROOT);<br>   <span class="hljs-keyword">return</span> upper.apply(s);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>执行当前函数之前，先执行指定的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">plusFiveAndToString</span><span class="hljs-params">(Integer i)</span>&#123;<br>   Function&lt;Integer, Integer&gt; plusFive = num -&gt; num + <span class="hljs-number">5</span>;<br>   Function&lt;Integer, String&gt; toString = String::valueOf;<br>   <span class="hljs-keyword">return</span> toString.compose(plusFive).apply(i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="andThen"><a href="#andThen" class="headerlink" title="andThen"></a>andThen</h2><p>执行当前函数之后，再执行指定的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">toIntAndPlusFive</span><span class="hljs-params">(String s)</span> &#123;<br>   Function&lt;String, Integer&gt; toInt = Integer::parseInt;<br>   Function&lt;Integer, Integer&gt; plusFive = num -&gt; num + <span class="hljs-number">5</span>;<br>   <span class="hljs-keyword">return</span> toInt.andThen(plusFive).apply(s);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h2><p>返回输入，最常用于我们在 reduce 的时候 Collectors.toMap() 中</p><p>我们假设输入的string中每一个开头的字符都不一样，现在想统计对应的映射关系（只是模拟）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Map&lt;Character, String&gt; <span class="hljs-title function_">getFirstCharAndStrMap</span><span class="hljs-params">(List&lt;String&gt; stringList)</span> &#123;<br>   <span class="hljs-keyword">return</span> stringList.stream()<br>           .collect(Collectors.toMap(str -&gt; str.charAt(<span class="hljs-number">0</span>), Function.identity()));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h1><p>和 Function 差不多类似</p><p>只有 apply 以及 andThen 方法</p><p>常见的使用场景：<code>stream().reduce()</code></p><h1 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h1><p>不接受参数但是返回结果</p><p>常用于懒加载等场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomSupplier</span> &#123;<br>   <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getRandomInt</span><span class="hljs-params">()</span>&#123;<br>      Supplier&lt;Integer&gt; randomSupplier = () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>      <span class="hljs-keyword">return</span> randomSupplier.get();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h1><p>和 Supplier 相对应</p><p>只接收参数但是不返回结果</p><p>比较常见的场景是：<code>stream().foreach()</code></p><h1 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h1><p>常见的使用场景：<code>list.sort()</code> 传入 Comparator</p>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx|前端工程容器化部署</title>
    <link href="/2024/12/09/Nginx-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2024/12/09/Nginx-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>最大的需求其实还是前端的工程每次调试都需要 <code>npm start</code> 占用内存太大，能有1个多G，加上电脑本身内存就16，应用又是需要多个调试，经常出现爆内存的情况。第一时间想到改动最少的前端进行容器化打包</p><h1 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h1><p>前端目前工程打包完是一个 dist 文件夹，以往部署都是托管在 ng 上进行访问</p><p>本地也采用 ng 来进行部署， docker 容器运行 nginx 镜像，通过容器数据卷的方式挂载打包后的 dist 目录到容器内进行转发</p><p>整体架构大致如下，我们假设后端的接口全局前缀为 <code>prefix</code> ，部署在 <code>address:port</code> 上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">+-------------------+       +-----------------+       +------------------+<br>|                   |       |                 |       |                  |<br>|    用户浏览器      |       |     Nginx 容器   |       |   后端服务 (port)|<br>|                   |       |                 |       |                  |<br>|  http://localhost:8000 |&lt;-&gt;|     :80         |&lt;------&gt;|     :port        |<br>|                   |       |                 |       |                  |<br>+-------------------+       +-----------------+       +------------------+<br><br>                             | 静态资源请求 / |<br>                             v                |<br>                     +-------------------------+<br>                     |                        |<br>                     |  提供静态资源          |<br>                     |  (HTML, CSS, JS等)     |<br>                     +-------------------------+<br><br>                             | API 请求 /prefix/ |<br>                             v                |<br>                     +-------------------------+<br>                     |                        |<br>                     |  反向代理到后端服务       |<br>                     |  (http://address:port/prefix/) |<br>                     +-------------------------+<br></code></pre></td></tr></table></figure><ul><li>浏览器 8000 端口访问页面，发出请求</li><li>请求被 nginx 配置文件中定义的 <code>location ^~/prefix</code> 代理，反向代理到后端服务上</li><li>后端接受请求返回数据给 nginx </li><li>nginx 收到响应后返回给客户端数据</li></ul><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>启动容器的 Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用官方的 Nginx 镜像作为基础镜像</span><br><span class="hljs-keyword">FROM</span> nginx:latest<br><br><span class="hljs-comment"># 拷贝自定义的 Nginx 配置文件</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./nginx.conf /etc/nginx/conf.d/default.conf</span><br><br><span class="hljs-comment"># 暴露 80 端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-comment"># 启动 Nginx</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>由于需要转发我们需要进行自定义配置文件</p><p><code>nginx.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>    listen       80;<br>    server_name  localhost;<br><br>    client_max_body_size 100m;<br><br>    # 后端接口的全局前缀<br>    location ^~/prefix &#123;<br>       # 后端服务的 ip + 端口<br>        proxy_pass http://address:port;<br>        proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;<br>        proxy_connect_timeout 6000s;<br>        proxy_read_timeout 6000s;<br>        proxy_http_version 1.1;<br>        proxy_set_header Upgrade $http_upgrade;<br>        proxy_set_header Connection &quot;upgrade&quot;;<br>        proxy_set_header Host $http_host;<br>    &#125;<br><br>    location / &#123;<br>        root   /usr/share/nginx/html; # 前端打包后的静态资源位置<br>        index  index.html index.htm;<br>        try_files $uri $uri/ /index.html;<br>    &#125;<br><br>    error_page   500 502 503 504  /50x.html;<br>    location = /50x.html &#123;<br>        root   html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>    location ^~/prefix &#123;&#125;</code> 指定了请求前缀转发，prefix 可以更换为后端接口的全局前缀</p><p><code>proxy_pass http://address:port</code> 中指定后端服务的 ip + 端口</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 根据 Dockerfile 构建镜像</span><br>docker build -t frontend .<br><span class="hljs-comment"># 1. -p 容器80端口映射到宿主机8000端口进行访问</span><br><span class="hljs-comment"># 2. -v 挂载 dist 目录到容器指定位置，需要和上面的 nginx.conf location.root 的 value 匹配上</span><br>docker run -d -p 8000:80 --name my-frontend-container -v xxx\dist:/usr/share/nginx/html frontend<br></code></pre></td></tr></table></figure><p>之后本机访问 <code>localhost:8000</code> 即可访问前端工程</p><p>每次更新前端代码，更新 dist 目录包后重启容器即可</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式|建造者设计模式</title>
    <link href="/2024/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>当我们构建一个对象的时候，这个<strong>对象的字段比较多</strong>（比如超过四个以上）</p><p>而又存在<strong>某些字段是可选的不用额外传入进行构造的场景</strong></p><p>这个时候我们有这些方式：</p><ul><li>折叠构造器</li><li>Java Bean</li><li>建造者模式</li></ul><p>这里还是最推荐使用建造者设计模式</p><h1 id="传统的设计方式"><a href="#传统的设计方式" class="headerlink" title="传统的设计方式"></a>传统的设计方式</h1><p>假设我们要构造一个电脑对象，其中 CPU 和 RAM 是必选的构造参数（符合实际）</p><h2 id="折叠构造器"><a href="#折叠构造器" class="headerlink" title="折叠构造器"></a>折叠构造器</h2><p>这种方式写的时候爽，但是维护起来难受，在实例化之前需要明白所有构造器的传参规范，都有哪些，构造器内是做什么，后期维护困难</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConventionalConstructorComputer</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String cpu;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ram;<br><br>   <span class="hljs-keyword">private</span> String display;<br><br>   <span class="hljs-keyword">private</span> String keyboard;<br><br>   <span class="hljs-keyword">private</span> String usbCount;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConventionalConstructorComputer</span><span class="hljs-params">(String cpu, String ram)</span> &#123;<br>      <span class="hljs-built_in">this</span>.cpu = cpu;<br>      <span class="hljs-built_in">this</span>.ram = ram;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConventionalConstructorComputer</span><span class="hljs-params">(String cpu, String ram, String display)</span> &#123;<br>      <span class="hljs-built_in">this</span>.cpu = cpu;<br>      <span class="hljs-built_in">this</span>.ram = ram;<br>      <span class="hljs-built_in">this</span>.display = display;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConventionalConstructorComputer</span><span class="hljs-params">(String cpu, String ram, String display, String keyboard)</span> &#123;<br>      <span class="hljs-built_in">this</span>.cpu = cpu;<br>      <span class="hljs-built_in">this</span>.ram = ram;<br>      <span class="hljs-built_in">this</span>.display = display;<br>      <span class="hljs-built_in">this</span>.keyboard = keyboard;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConventionalConstructorComputer</span><span class="hljs-params">(String cpu, String ram, String display, String keyboard, String usbCount)</span> &#123;<br>      <span class="hljs-built_in">this</span>.cpu = cpu;<br>      <span class="hljs-built_in">this</span>.ram = ram;<br>      <span class="hljs-built_in">this</span>.display = display;<br>      <span class="hljs-built_in">this</span>.keyboard = keyboard;<br>      <span class="hljs-built_in">this</span>.usbCount = usbCount;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h2><p>这种就是最基础的 get set 方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConventionalBeanComputer</span> &#123;<br>   <span class="hljs-keyword">private</span> String cpu;<br><br>   <span class="hljs-keyword">private</span> String ram;<br><br>   <span class="hljs-keyword">private</span> String display;<br><br>   <span class="hljs-keyword">private</span> String keyboard;<br><br>   <span class="hljs-keyword">private</span> String usbCount;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> cpu;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCpu</span><span class="hljs-params">(String cpu)</span> &#123;<br>      <span class="hljs-built_in">this</span>.cpu = cpu;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRam</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> ram;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRam</span><span class="hljs-params">(String ram)</span> &#123;<br>      <span class="hljs-built_in">this</span>.ram = ram;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDisplay</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> display;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDisplay</span><span class="hljs-params">(String display)</span> &#123;<br>      <span class="hljs-built_in">this</span>.display = display;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getKeyboard</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> keyboard;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKeyboard</span><span class="hljs-params">(String keyboard)</span> &#123;<br>      <span class="hljs-built_in">this</span>.keyboard = keyboard;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsbCount</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> usbCount;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsbCount</span><span class="hljs-params">(String usbCount)</span> &#123;<br>      <span class="hljs-built_in">this</span>.usbCount = usbCount;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然比较简洁而且也便于维护</p><p>但是可能会导致对象的其他属性在不可见的情况下被修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConventionalPattern</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//传统折叠构造函数模式</span><br>      <span class="hljs-type">ConventionalConstructorComputer</span> <span class="hljs-variable">computer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConventionalConstructorComputer</span>(<span class="hljs-string">&quot;Intel&quot;</span>, <span class="hljs-string">&quot;16g&quot;</span>);<br>      <span class="hljs-type">ConventionalConstructorComputer</span> <span class="hljs-variable">computer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConventionalConstructorComputer</span>(<span class="hljs-string">&quot;Intel&quot;</span>, <span class="hljs-string">&quot;16g&quot;</span>, <span class="hljs-string">&quot;Display&quot;</span>);<br>      <span class="hljs-type">ConventionalConstructorComputer</span> <span class="hljs-variable">computer3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConventionalConstructorComputer</span>(<span class="hljs-string">&quot;Intel&quot;</span>, <span class="hljs-string">&quot;16g&quot;</span>, <span class="hljs-string">&quot;Display&quot;</span>, <span class="hljs-string">&quot;keyboard&quot;</span>);<br>      <span class="hljs-type">ConventionalConstructorComputer</span> <span class="hljs-variable">computer4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConventionalConstructorComputer</span>(<span class="hljs-string">&quot;Intel&quot;</span>, <span class="hljs-string">&quot;16g&quot;</span>, <span class="hljs-string">&quot;Display&quot;</span>, <span class="hljs-string">&quot;keyboard&quot;</span>, <span class="hljs-string">&quot;usbCount&quot;</span>);<br><br>      <span class="hljs-comment">//传统 javaBean 方式</span><br>      <span class="hljs-type">ConventionalBeanComputer</span> <span class="hljs-variable">beanComputer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConventionalBeanComputer</span>();<br>      beanComputer.setCpu(<span class="hljs-string">&quot;Intel&quot;</span>);<br>      beanComputer.setRam(<span class="hljs-string">&quot;16G&quot;</span>);<br>      beanComputer.setDisplay(<span class="hljs-string">&quot;display&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="建造者模式使用"><a href="#建造者模式使用" class="headerlink" title="建造者模式使用"></a>建造者模式使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String cpu;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ram;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String display;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String keyboard;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String usbCount;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Computer</span><span class="hljs-params">(Builder builder)</span> &#123;<br>      <span class="hljs-built_in">this</span>.cpu = builder.cpu;<br>      <span class="hljs-built_in">this</span>.ram = builder.ram;<br>      <span class="hljs-built_in">this</span>.display = builder.display;<br>      <span class="hljs-built_in">this</span>.keyboard = builder.keyboard;<br>      <span class="hljs-built_in">this</span>.usbCount = builder.usbCount;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String cpu;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ram;<br><br>      <span class="hljs-keyword">private</span> String display;<br><br>      <span class="hljs-keyword">private</span> String keyboard;<br><br>      <span class="hljs-keyword">private</span> String usbCount;<br><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 必须填写的作为构造参数</span><br><span class="hljs-comment">       *</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param</span> cpu cpu</span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param</span> ram ram</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(String cpu, String ram)</span> &#123;<br>         <span class="hljs-built_in">this</span>.cpu = cpu;<br>         <span class="hljs-built_in">this</span>.ram = ram;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">buildDisplay</span><span class="hljs-params">(String display)</span> &#123;<br>         <span class="hljs-built_in">this</span>.display = display;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">buildKeyboard</span><span class="hljs-params">(String keyboard)</span> &#123;<br>         <span class="hljs-built_in">this</span>.keyboard = keyboard;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">buildUsbCount</span><span class="hljs-params">(String usbCount)</span> &#123;<br>         <span class="hljs-built_in">this</span>.usbCount = usbCount;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> Computer <span class="hljs-title function_">build</span><span class="hljs-params">()</span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>(<span class="hljs-built_in">this</span>);<br>      &#125;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>程序可以调用 builder 的任何一个方法来组装拼接对象的部分可选属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BuilderPattern</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>      <span class="hljs-type">Computer</span> <span class="hljs-variable">intelComputer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>.Builder(<span class="hljs-string">&quot;INTEL&quot;</span>, <span class="hljs-string">&quot;16G&quot;</span>)<br>              .buildDisplay(<span class="hljs-string">&quot;DISPLAY&quot;</span>)<br>              .build();<br><br>      <span class="hljs-type">Computer</span> <span class="hljs-variable">amdComputer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>.Builder(<span class="hljs-string">&quot;AMD&quot;</span>, <span class="hljs-string">&quot;32G&quot;</span>)<br>              .buildKeyboard(<span class="hljs-string">&quot;Cherry&quot;</span>)<br>              .buildDisplay(<span class="hljs-string">&quot;DISPLAY&quot;</span>)<br>              .buildUsbCount(<span class="hljs-string">&quot;4&quot;</span>)<br>              .build();<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL|查询基础</title>
    <link href="/2024/11/15/SQL-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/11/15/SQL-%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><h2 id="基础分组计算"><a href="#基础分组计算" class="headerlink" title="基础分组计算"></a>基础分组计算</h2><p>查询出 每个学校 每种性别的 用户数、30天内平均活跃天数和平均发帖数量。</p><p>用户信息表：user_profile</p><p>30天内活跃天数字段（active_days_within_30）</p><p>发帖数量字段（question_cnt）</p><p>回答数量字段（answer_cnt）</p><table><thead><tr><th>id</th><th>device_id</th><th>gender</th><th>age</th><th>university</th><th>gpa</th><th>active_days_within_30</th><th>question_cnt</th><th>answer_cnt</th></tr></thead><tbody><tr><td>1</td><td>2138</td><td>male</td><td>21</td><td>北京大学</td><td>3.4</td><td>7</td><td>2</td><td>12</td></tr><tr><td>2</td><td>3214</td><td>male</td><td></td><td>复旦大学</td><td>4.0</td><td>15</td><td>5</td><td>25</td></tr><tr><td>3</td><td>6543</td><td>female</td><td>20</td><td>北京大学</td><td>3.2</td><td>12</td><td>3</td><td>30</td></tr><tr><td>4</td><td>2315</td><td>female</td><td>23</td><td>浙江大学</td><td>3.6</td><td>5</td><td>1</td><td>2</td></tr><tr><td>5</td><td>5432</td><td>male</td><td>25</td><td>山东大学</td><td>3.8</td><td>20</td><td>15</td><td>70</td></tr><tr><td>6</td><td>2131</td><td>male</td><td>28</td><td>山东大学</td><td>3.3</td><td>15</td><td>7</td><td>13</td></tr><tr><td>7</td><td>4321</td><td>male</td><td>26</td><td>复旦大学</td><td>3.6</td><td>9</td><td>6</td><td>52</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span><br>    gender,<br>    university,<br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> user_num,<br>    <span class="hljs-built_in">AVG</span>(active_days_within_30) <span class="hljs-keyword">AS</span> avg_active_day,<br>    <span class="hljs-built_in">AVG</span>(question_cnt) <span class="hljs-keyword">AS</span> avg_question_cnt<br><span class="hljs-keyword">from</span><br>    user_profile<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>    gender,<br>    university<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">by</span><br>    gender <span class="hljs-keyword">ASC</span>,<br>    university <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><blockquote><p>注意</p><p>分组查询使用 GROUP BY 关键字，在 select 中大部分时候都需要使用到分组函数（常见的有 count, avg 等），分组查询 select 后直接查询列的唯一场景就是这个列是被分组的列，不然会语法报错</p></blockquote><h2 id="分组过滤"><a href="#分组过滤" class="headerlink" title="分组过滤"></a>分组过滤</h2><p>查询出平均发贴数低于5的学校或平均回帖数小于20的学校，和他们对应的平均发帖数，平均回帖数</p><table><thead><tr><th>id</th><th>device_id</th><th>gender</th><th>age</th><th>university</th><th>gpa</th><th>active_days_within_30</th><th>question_cnt</th><th>answer_cnt</th></tr></thead><tbody><tr><td>1</td><td>2138</td><td>male</td><td>21</td><td>北京大学</td><td>3.4</td><td>7</td><td>2</td><td>12</td></tr><tr><td>2</td><td>3214</td><td>male</td><td></td><td>复旦大学</td><td>4.0</td><td>15</td><td>5</td><td>25</td></tr><tr><td>3</td><td>6543</td><td>female</td><td>20</td><td>北京大学</td><td>3.2</td><td>12</td><td>3</td><td>30</td></tr><tr><td>4</td><td>2315</td><td>female</td><td>23</td><td>浙江大学</td><td>3.6</td><td>5</td><td>1</td><td>2</td></tr><tr><td>5</td><td>5432</td><td>male</td><td>25</td><td>山东大学</td><td>3.8</td><td>20</td><td>15</td><td>70</td></tr><tr><td>6</td><td>2131</td><td>male</td><td>28</td><td>山东大学</td><td>3.3</td><td>15</td><td>7</td><td>13</td></tr><tr><td>7</td><td>4321</td><td>female</td><td>26</td><td>复旦大学</td><td>3.6</td><td>9</td><td>6</td><td>52</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>SQL BOY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式|抽象工厂设计模式</title>
    <link href="/2024/11/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/11/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h1><p>工厂生产产品</p><p>一个工厂可以生产多种具有相同功能的产品</p><h1 id="工厂生产的产品"><a href="#工厂生产的产品" class="headerlink" title="工厂生产的产品"></a>工厂生产的产品</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Button</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HTMLButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Button</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;HTML Click&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Button</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Windows Click&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="工厂创造者"><a href="#工厂创造者" class="headerlink" title="工厂创造者"></a>工厂创造者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABaseButtonFactory</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createAndAutoClickButton</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> createButton();<br>      button.click();<br>   &#125;<br><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Button <span class="hljs-title function_">createButton</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HTMLButtonFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ABaseButtonFactory</span> &#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Button <span class="hljs-title function_">createButton</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLButton</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsButtonFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ABaseButtonFactory</span> &#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Button <span class="hljs-title function_">createButton</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowsButton</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="测试演示"><a href="#测试演示" class="headerlink" title="测试演示"></a>测试演示</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryMethodPattern</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>      <span class="hljs-type">HTMLButtonFactory</span> <span class="hljs-variable">htmlButtonFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLButtonFactory</span>();<br>      htmlButtonFactory.createAndAutoClickButton();<br><br>      <span class="hljs-type">WindowsButtonFactory</span> <span class="hljs-variable">windowsButtonFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowsButtonFactory</span>();<br>      windowsButtonFactory.createAndAutoClickButton();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工厂方法模式适用于<strong>需要创造一系列具有相同行为的产品</strong>，提供一个抽象的通用基类</p><p>创建者子类继承基类，通过实现父类的某个抽象方法，在客户端调用基类的公共方法（会重新调用子类重写的版本）来创造出不同的，但是具有相同行为的产品</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Framework</tag>
      
      <tag>Design Pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java|ThreadPool</title>
    <link href="/2024/11/12/Java-ThreadPool/"/>
    <url>/2024/11/12/Java-ThreadPool/</url>
    
    <content type="html"><![CDATA[<h1 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h1><h2 id="任务本体-Runnable-x2F-Callable"><a href="#任务本体-Runnable-x2F-Callable" class="headerlink" title="任务本体 Runnable&#x2F;Callable"></a>任务本体 Runnable&#x2F;Callable</h2><p>具体的异步执行任务通过实现 Runnable&#x2F;Callable 接口来作为一个可被执行的任务实例</p><h2 id="任务执行-Executor-接口"><a href="#任务执行-Executor-接口" class="headerlink" title="任务执行 Executor 接口"></a>任务执行 Executor 接口</h2><p>JDK提供了一系列的任务执行工具</p><p>比较常用的是 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor</p><h2 id="异步计算结果-Future-接口"><a href="#异步计算结果-Future-接口" class="headerlink" title="异步计算结果 Future 接口"></a>异步计算结果 Future 接口</h2><p>只需要知道异步计算的结果都在 Future 接口中</p><p>具体看下面的流程</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>一个多线程任务从创建到结束的流程大致如下：</p><ul><li>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象</li><li>把创建完成的实现 <code>Runnable</code>&#x2F;<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）</li><li>上面这两步其实可以通过一个 lambda reference 来实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">threadPoolExecutor.execute(() -&gt; doBusinessAsync());<br></code></pre></td></tr></table></figure><p>上面的情况是我们不关心结果，只管提交的情况</p><p>如果关心结果，可以调用 <code>submit</code> 接口，拿到 FutureTask 实例</p><p>需要注意的是如果直接 futureTask.get() 直接变同步阻塞了</p>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring|@Conditional</title>
    <link href="/2024/11/11/Spring-Conditional/"/>
    <url>/2024/11/11/Spring-Conditional/</url>
    
    <content type="html"><![CDATA[<h1 id="场景需求引入"><a href="#场景需求引入" class="headerlink" title="场景需求引入"></a>场景需求引入</h1><p>有个新的需求功能模块，需要对内部的计算引擎进行监控统计</p><p>在消费端（读取内存记录数据持久化）可以获取系统配置，选择创建和不创建某些调度任务来对内存的监控数据进行消费</p><p>但是在内存数据的生产者端，如果不进行特殊处理，就会出现没有消费但是每次业务操作还会对内存中维护的统计数据不断更新，造成资源浪费</p><p>因此想到将内存中维护的统计数据类注入到 Spring 容器中，通过读取配置文件，来动态注册到 Spring 容器中，在生产消息的时候，只需要额外进行判断 bean 是否为空即可</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="自定义条件"><a href="#自定义条件" class="headerlink" title="自定义条件"></a>自定义条件</h2><p>Spring 提供了 Condition 接口，可以实际这个接口来自定义业务需要的条件</p><p>之后在需要条件注册的 Bean 类上，除了打上 @Component 外，再打上 <code>@Conditonal(自定义条件.class)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputeCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;<br>        <span class="hljs-comment">// 返回true或false，决定是否注册Bean</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Conditional(ComputeCondition.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorMemDataModel</span> &#123;<br>     <span class="hljs-comment">//业务定义的内存数据模型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只有当<code>ComputeCondition</code>返回<code>true</code>时，<code>MonitorMemDataModel</code>才会被注册</p><h2 id="组合条件"><a href="#组合条件" class="headerlink" title="组合条件"></a>组合条件</h2><p>有的时候根据不同业务场景，条件也不止简单的一个，可能是复杂组合条件</p><p>但是再怎么复杂本质上也都是 <code>|</code> 或是 <code>&amp;</code> 的排列组合</p><p>对此 Spring 分别为我们提供了 <code>AnyNestedCondition</code> 和 <code>AllNestedCondition</code>  类来实现复杂业务条件组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AOrBCondition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AnyNestedCondition</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AOrBCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(ConfigurationPhase.REGISTER_BEAN);<br>    &#125;<br><br>    <span class="hljs-meta">@Conditional(ConditionA.class)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionA</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Conditional(ConditionB.class)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Condition2</span> &#123;&#125;<br>     <br>&#125; <br></code></pre></td></tr></table></figure><p>这里构造函数中传递给父类的一个枚举需要注意：</p><ul><li>如果这个条件修饰的是配置类，目的是为了条件被解析使配置类动态注入，则需要传递 <code>ConfigurationPhase.PARSE_CONFIGURATION</code></li><li>如果这个条件修饰的是普通的Bean，目的是为了条件被解析控制普通的类动态注入，则需要传递<code>ConfigurationPhase.REGISTER_BEAN</code></li></ul><p>上面我们自定义的组合条件，效果就是 A | B 生效，那么就注册对应这个条件修饰的 Bean 到容器中</p><h2 id="Spring-内置条件"><a href="#Spring-内置条件" class="headerlink" title="Spring 内置条件"></a>Spring 内置条件</h2><p>Spring框架提供了多种内置的条件类，如<code>@ConditionalOnProperty</code>、<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>等</p><p>比较常用的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConditionalOnProperty(name = &quot;my.property&quot;, havingValue = &quot;true&quot;)</span><br></code></pre></td></tr></table></figure><h1 id="实际使用场景"><a href="#实际使用场景" class="headerlink" title="实际使用场景"></a>实际使用场景</h1><h2 id="根据项目全局环境条件"><a href="#根据项目全局环境条件" class="headerlink" title="根据项目全局环境条件"></a>根据项目全局环境条件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DevCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;<br>        <span class="hljs-keyword">return</span> context.getEnvironment().acceptsProfiles(<span class="hljs-string">&quot;dev&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类路径下是否存在某个类条件"><a href="#类路径下是否存在某个类条件" class="headerlink" title="类路径下是否存在某个类条件"></a>类路径下是否存在某个类条件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnClass(name = &quot;com.example.MyClass&quot;)</span><br>    <span class="hljs-keyword">public</span> MyBean <span class="hljs-title function_">myBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合配置文件具体值"><a href="#组合配置文件具体值" class="headerlink" title="组合配置文件具体值"></a>组合配置文件具体值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConditionalOnProperty(name = &quot;my.property&quot;, havingValue = &quot;true&quot;)</span><br></code></pre></td></tr></table></figure><h2 id="指定Bean存在与否条件"><a href="#指定Bean存在与否条件" class="headerlink" title="指定Bean存在与否条件"></a>指定Bean存在与否条件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnBean(name = &quot;myDependencyBean&quot;)</span><br>    <span class="hljs-keyword">public</span> MyBean <span class="hljs-title function_">myBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBean</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于自定义注解实现重复读取请求头拦截器</title>
    <link href="/2024/11/06/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2024/11/06/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>目前的需求是，由于服务端不是简单的控制台而是计算引擎，因此暴露的接口在接收客户端参数的时候进行签名校验</p><p>客户端将签名参数设置在 RequestHeader 中传递，将接口入参设置在 RequestBody 中</p><p>朴素的做法是直接读取数据流中的数据，但是 ServletRequest 的 getInputStream 和 getReader 是不可重复调用的，读完数据就没了，因此需要实现可重复读取请求头</p><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>基本的思路是在请求处理之前通过 HandlerInterceptor 拦截，将 HttpServletRequest 中的数据获取到并缓存在内存中，再通过框架提供的配置接口将数据 Set 回去</p><p>因此总结分为两个部分处理：</p><ul><li>拦截请求</li><li>缓存请求数据并重新设置回去</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="缓存请求并重新设置回请求对象"><a href="#缓存请求并重新设置回请求对象" class="headerlink" title="缓存请求并重新设置回请求对象"></a>缓存请求并重新设置回请求对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> javax.servlet.http.HttpServletRequest</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> Servlet 2.3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServletRequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServletRequestWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpServletRequest</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>我们需要继承 MVC 提供的一个基础 Warpper 类，这个类提供了最基础的基于 HttpServletRequest 的实现，我们可以在这上面进行自己业务的特殊需求实现（缓存请求数据）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpRequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServletRequestWrapper</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] m_byteRequestBody;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpServletRequest m_pRequest;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HttpRequestWrapper</span><span class="hljs-params">(HttpServletRequest pRequest)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">super</span>(pRequest);<br>        <span class="hljs-built_in">this</span>.m_pRequest = pRequest;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-comment">//缓存数据，其实这里调用getInputStream()的时候request的数据就已经没了</span><br>        IOUtils.copy(m_pRequest.getInputStream(), byteStream);<br>        <span class="hljs-built_in">this</span>.m_byteRequestBody = byteStream.toByteArray();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getRequestBody() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.m_byteRequestBody;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletInputStream <span class="hljs-title function_">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">byteStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(m_byteRequestBody);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletInputStream</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFinished</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReady</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setReadListener</span><span class="hljs-params">(ReadListener listener)</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Async not supported&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> byteStream.read();<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BufferedReader <span class="hljs-title function_">getReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-built_in">this</span>.getInputStream()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心在于我们重写了 getInputStream 方法，将缓存的数据byteStream返回到上游调用方 </p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>之后我们就可以根据我们的业务代码编写对应的签名拦截器</p><p>由于签名校验是公共逻辑，我们可以自定义注解，通过拦截器拦截注解来处理，只对打了对应自定义注解的接口进行签名校验</p><p>自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SignatureCheck &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SignInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>         <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>           <span class="hljs-comment">//拦截对应注解</span><br>            <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br>            <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">pHandlerMethod</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>            <span class="hljs-type">SignCheck</span> <span class="hljs-variable">pSignCheck</span> <span class="hljs-operator">=</span> pHandlerMethod.getMethodAnnotation(SignCheck.class);<br>            <span class="hljs-keyword">if</span> (pSignCheck != <span class="hljs-literal">null</span>) &#123;<br>                 <span class="hljs-comment">//对应校验签名的业务代码</span><br>            &#125;<br>            &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka|消费最佳实践</title>
    <link href="/2024/10/08/Kafka-%E6%B6%88%E8%B4%B9%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/10/08/Kafka-%E6%B6%88%E8%B4%B9%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="消息消费顺序"><a href="#消息消费顺序" class="headerlink" title="消息消费顺序"></a>消息消费顺序</h1><p>Kafka 在发送消息的时候，需要指定 topic, partition, key,data（数据） 4 个参数</p><p>其中这个 key 是用来保证消息有序的重要概念</p><p>发送的消息都有一个 offset ，如果一个 topic 下只保证一个 partition 的话，光靠 offset 确实可以实现有序</p><p>但是为了并发吞吐，partition 在 topic 下一定是多个存在的。因此 key 的出现就是为了解决这个问题</p><p><strong>同一个 key 的消息可以保证只发送到同一个 partition</strong></p><p>所以我们在业务代码中，对于一个场景下需要保证强顺序消费的业务场景，可以在发消息的时候，多条消息按顺序发送，并指定唯一的 key </p><h1 id="消息丢失的情况-amp-解决方案"><a href="#消息丢失的情况-amp-解决方案" class="headerlink" title="消息丢失的情况&amp;解决方案"></a>消息丢失的情况&amp;解决方案</h1><h2 id="生产者侧消息丢失"><a href="#生产者侧消息丢失" class="headerlink" title="生产者侧消息丢失"></a>生产者侧消息丢失</h2><p>这个是最基本的，一般来说生产者都是异步发消息，那么就会存在可能 CPU 资源不足，或者极端状况下生产者网络问题导致消息发送失败的情况</p><p>这种情况比较好解决， 可以通过设置发送重试次数+调大重发间隔 来解决</p><h2 id="消费者侧消息不一致"><a href="#消费者侧消息不一致" class="headerlink" title="消费者侧消息不一致"></a>消费者侧消息不一致</h2><p>这里和 Kafka 的提交方式有关</p><p>Kafka 提供了自动提交和消费者手动提交来标记 topic 中消息被消费（实际上就是修改 Partition 中的 offset） 的两种方式：</p><ul><li>在消费者侧自定义手动提交</li><li>Kafka 侧自动提交</li></ul><p>两种实际上<strong>都会导致消费者侧消息不一致的问题</strong>：</p><ul><li>Kafka自动提交，消费者可能还没开始消费就挂了，但是消息已经标记为提交，出现<strong>消息丢失</strong></li><li>消费者侧手动提交，可能极端状况下还没提交但是消费了，进程挂了，那么就会出现<strong>重复消费</strong>的情况</li></ul><h2 id="Kafka-内部消息不一致"><a href="#Kafka-内部消息不一致" class="headerlink" title="Kafka 内部消息不一致"></a>Kafka 内部消息不一致</h2><p>这种情况主要是配置说明，一般配置正确不会发生</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EDA</tag>
      
      <tag>Distribued System</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Akka|Introduction</title>
    <link href="/2024/09/30/Akka-Introduction/"/>
    <url>/2024/09/30/Akka-Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Actor-模型"><a href="#Actor-模型" class="headerlink" title="Actor 模型"></a>Actor 模型</h2><p>AKKA 中核心在于其 Actor 模型</p><p>如果说并发编程的概念中，线程是最小执行单元；那么在 AKKA 中，Actor 才是最小的执行单元</p><p>在Actor模型中并不是通过Actor对象的某个方法来告诉Actor需要做什么，而是给Actor发送一条消息，消息传递的方式是异步的</p><p>Actor 在收到消息的时候会做三种操作：</p><ul><li>发送有限个消息给其他 Actor</li><li>创建有限个 子Actor</li><li>指定下一条消息的接收行为</li></ul><p>在 AKKA 的模型概念中，Actor彼此之间直接发送消息，不需要经过什么中介，消息是异步发送和处理</p><p>在Actor模型中一切都是Actor，所有逻辑或模块都可以看成是Actor，通过不同Actor之间的消息传递实现模块之间的通信和交互。</p><h2 id="抽象属性"><a href="#抽象属性" class="headerlink" title="抽象属性"></a>抽象属性</h2><p><strong>Actor是由状态（state）、行为（behavior）、邮箱（mailbox）三者组成的</strong></p><ul><li>状态（state）：状态是指<strong>actor对象的变量信息</strong>，状态由actor自身管理，避免并发环境下的锁和内存原子性等问题</li><li>行为（behavior）：行为指定的是actor中<strong>计算逻辑</strong>，<strong>通过actor接收到的消息来改变actor的状态</strong></li><li>邮箱（mailbox）：邮箱是actor之间的通信桥梁，邮箱内部通过<strong>FIFO</strong>消息队列来存储发送发消息，而接收方则从邮箱中获取消息。</li></ul><h2 id="消息处理方式"><a href="#消息处理方式" class="headerlink" title="消息处理方式"></a>消息处理方式</h2><p>即使是在分布式系统中，一个 Actor 同时也只能处理一条消息，如果要实现并发处理多条消息，则需要创建多个 Actor</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EDA</tag>
      
      <tag>Distribued System</tag>
      
      <tag>Akka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper|数据同步最佳实践</title>
    <link href="/2024/09/28/Zookeeper-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/09/28/Zookeeper-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>项目目前采用的是分布式系统的架构，虽然不能算得上是微服务，但是也是需要部署指定服务的集群，核心业务服务部署集群和控制台服务需要通过某种方式来进行协调保证数据的一致性</p><p>目前采用的方式是通过 ZK 来进行数据的同步</p><p>涉及到一些基本概念：</p><ul><li><strong>Znode（ZooKeeper Node）</strong>: ZooKeeper 的数据单位，类似于文件系统中的目录和文件。Znode 可以存储数据，客户端（也就是我们注册到 ZK 的服务，对于 ZK 来说是客户端）可以对 ZNode 进行 CRUD 操作。 ZooKeeper 使用类似于树状结构的数据模型，根节点为 <code>/</code>，其下可以有多个子节点，每个子节点可以继续拥有自己的子节点</li><li><strong>会话（Session）</strong>: 客户端与 ZooKeeper 服务器之间的连接，每个会话有一个超时时间，若超时则会话失效。</li><li><strong>Watch 机制</strong>: ZooKeeper 提供的一种事件通知机制，客户端可以对特定的 Znode 设置 Watch 监听，当 Znode 发生变化时（这个变化一般来说也是业务系统中指定的操作来对 ZNode 的数据进行变化操作），ZooKeeper 会通知监听了这个 ZNode 的客户端，执行对应的操作</li></ul><h1 id="数据同步流程"><a href="#数据同步流程" class="headerlink" title="数据同步流程"></a>数据同步流程</h1><p>我们这里以 核心服务集群同步来自管理控制台不断更新的商品信息 这一需求为例</p><p>也就是用户可以在管理端控制台操作更新商品信息，核心处理业务的服务需要能够同步具体的商品信息</p><h2 id="启动-amp-节点注册"><a href="#启动-amp-节点注册" class="headerlink" title="启动 &amp; 节点注册"></a>启动 &amp; 节点注册</h2><p>客户端应用（例如 SpringBoot）在启动的时候通过 ZK 提供的客户端，比较常用的库是 Curator 来连接到 ZK 服务器</p><p>每个 SpringBoot 应用在 ZK 中注册自己的服务信息，这个服务信息，也可以是一个 ZNode (TEMPORAL类型)，当 SpringBoot 应用挂掉的时候， ZK 上对应的 ZNode 会被删除，从而实现核心服务业务和管理控制台之间状态的监听</p><h2 id="注册-Watcher-监听"><a href="#注册-Watcher-监听" class="headerlink" title="注册 Watcher 监听"></a>注册 Watcher 监听</h2><p>管理控制台将业务需要用到的商品数据存储在 ZK 的指定 path(例如 &#x2F;coreService&#x2F;instance1)上的 ZNode 上</p><p>核心服务集群中每一个实例，在启动注册的时候，都监听 ZK 的对应 path 中上的 ZNode 信息，监听的类型为 Update 事件，也就是每当 ZK 上这个 ZNode 的数据更新时，就要同步更新自己持有的商品数据</p><p>那么 ZK 上这个 ZNode 的数据什么时候会更新，就是在前端用户对商品进行修改操作的时候，管理控制台除了更新入库操作外，还要去更新 ZK 上 ZNode 的数据</p><p>当 ZK 上 ZNode 数据发生变化时，ZooKeeper 会触发 Watch 事件，我们的核心业务服务应用接收到通知后，重新读取最新的 ZNode 数据并更新（这个就要看具体业务了，在这里可能是根据商品唯一不变标识来进行内存中数据的更新操作，具体根据业务可以定制处理）</p><blockquote><p>需要注意的是：Watch 事件是一次性的，应用需要在处理完事件后重新设置 Watch，以持续监听后续的变化</p></blockquote><p>通过上述的流程，我们的服务应用集群的每一个节点就可以通过 ZK 来保证数据的一致性</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EDA</tag>
      
      <tag>Distributed System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nintendo 3DS|折腾记录</title>
    <link href="/2024/08/20/Nintendo-3DS-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/20/Nintendo-3DS-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0-装前须知"><a href="#0-装前须知" class="headerlink" title="0-装前须知"></a>0-装前须知</h1><p>本文基于 <code>3ds.hacks.guide</code> 用于个人学习记录，因为机器太多以后怕忘所以记录下每台机器型号记录的过程</p><p>目前 3DS 全系已经完美破解可以说破的连底裤都不剩了，因此无论你的机器是什么版本什么尺寸什么型号什么系统版本什么成色，只要能正常玩，都可以连接网络升级到最新的版本之后，再进行固件的安装</p><p>同时也不区分具体是什么机型，无论是什么机型最终安装的固件都一样，只是引导安装方式不同</p><ul><li>老款 2DS&#x2F;3DS 采用 MSET9 的方式安装 B9S</li><li>新款 2DSLL&#x2F;3DS&#x2F;3DSLL 采用 super-skaterhax 的方式安装 B9S</li></ul><h1 id="1-通过-MSET9-CLI-安装-BootStrap9"><a href="#1-通过-MSET9-CLI-安装-BootStrap9" class="headerlink" title="1-通过 MSET9 CLI 安装 BootStrap9"></a>1-通过 MSET9 CLI 安装 BootStrap9</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li>需要电脑安装好 Python3 及以上的版本，windows 查看 Python 版本的命令 <code>python -V</code> 或 <code>python --version</code> </li><li><a href="https://github.com/hacks-guide/MSET9/releases/tag/v2.0">MSET9的最新release</a></li><li>一张 SD 卡，这里我用的是 32G TF卡 + 一个 SD 卡套马甲，因为官方推荐的是 32G及一下的支持 SDHC 的 sd卡，加上 3ds 游戏本身不大，就算是装满了反而也会电子杨威，因此 32G 恰好够用</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>将下载的 release 安装包解压到 SD 卡根目录</p><p>双击运行 <code>MSET9-Windows.bat</code></p><p>在显示出来的终端上，根据提示信息输入不同的数字</p><ul><li>老款3DS&#x2F;2DS<ul><li>11.4.0-11.7.0 扣3回车</li><li>11.8.0-11.17.0 扣1回车</li></ul></li><li>新款3DS&#x2F;3DSLL&#x2F;2DSLL<ul><li>11.4.0-11.7.0 扣4回车</li><li>11.8.0-11.17.0 扣2回车</li></ul></li></ul><p>之后在新的终端界面，会显示: <code>Current MSET9 state: ID1 not created</code></p><p>按下1回车，创建 MSET9 ID1，这个时候会跳一个免责声明，继续回车确认</p><p>之后会看到消息，<code>Created hacked ID1</code> 再次回车关闭窗口</p><p>把 SD 卡插进 3DS 里，启动机器，进入 Mii Maker</p><blockquote><p>注意，插回去开机的时候，主界面上的任何用户先前自己安装过的数据都会显示不出来，这是正常现象，后续可以让他重新回来</p></blockquote><p>等到 Mii Maker 进入到欢迎页面给出一个继续的按钮之后，退出 Mii Maker，回到主页，将会看到下图的状态，这是正常现象，表示正在创建额外数据（后面有用）</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240820170724015.png"></p><p>如果点进 Mii Maker 直接就是下图，说明已经有额外数据了，不用管，继续往下看</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240820170856396.png"></p><p>进入到系统设置-数据管理-Nintendo 3DS-软件-重置，点确定</p><p>关机，拔出 SD 卡，插回电脑，再次双击运行 <code>MSET9-Windows.bat</code></p><p>还是需要和上面一样先根据自己机器的型号已经对应的系统版本，输入数字，之后再次来到新的界面，如果一切都正常，应该显示的是：<code>Current MSET9 state: Ready</code></p><p>按 0 推出界面，重新将 SD 卡插回机器</p><h1 id="2-利用-MSET9-触发漏洞进入-SafeB9SInstaller-自制固件安装器"><a href="#2-利用-MSET9-触发漏洞进入-SafeB9SInstaller-自制固件安装器" class="headerlink" title="2-利用 MSET9 触发漏洞进入 SafeB9SInstaller 自制固件安装器"></a>2-利用 MSET9 触发漏洞进入 SafeB9SInstaller 自制固件安装器</h1><blockquote><p>注意！这一部分的内容很重要，建议每一次操作前都进行二次确认</p></blockquote><p>启动机器，此时在下屏，[系统设置] 应该是已经选中了的状态，如果没有，将选中框移动到[系统设置]上，保持这个状态关机，然后再开，直到开机后 [系统设置] 是自动选中的状态下，才能进行下一步</p><p>按 A 进入系统设置，数据管理-Nintendo 3DS-额外数据(从上往下第二个)</p><p>不要按任何按键，不要点击屏幕</p><p>保持机器的开机状态，在不按任何按键和点击屏幕任何位置的情况下，将 SD 卡热拔出，此时菜单将会刷新，并且提示你没有插入 SD 卡（注意，不要关机）</p><p>将 SD 卡插回电脑，还是启动 MSET9 脚本，输入数字回车进入到那个熟悉的窗口页面</p><p>这次是按下 3 后回车，此时界面应该会显示: <code>MSET9 successfully injected!</code>，按下回车关闭界面</p><p>在不按任何按键和点击屏幕任何位置的情况下，重新将 SD 卡插回还在开机的 3DS 里</p><p>如果漏洞运行一切顺利，我们将会进入到 SafeB9SInstaller 的启动界面</p><h1 id="3-安装-B9S-自制固件"><a href="#3-安装-B9S-自制固件" class="headerlink" title="3-安装 B9S 自制固件"></a>3-安装 B9S 自制固件</h1><p>出现提示时，输入上屏给出的组合键以安装 boot9strap</p><p>安装好之后，按下 A 重启机器</p><p>机器将会启动到 Luma3DS 配置菜单（Luma3DS 配置菜单是 Luma3DS 自定义固件的设置，其中许多设置可能对于自定义或调试机器很有用）</p><p>目前我们还是不要修改任何设置，一切都保留默认，按下 start 保存并正式启动机器</p><h1 id="4-移除-MSET9"><a href="#4-移除-MSET9" class="headerlink" title="4-移除 MSET9"></a>4-移除 MSET9</h1><p>关闭机器，拔出 SD 卡，插回电脑</p><p>双击运行 MSET9脚本，还是熟悉的输入数字回车进入，此时新界面上显示的信息应该是：<code>Current MSET9 state: Injected</code></p><p>但是这一次，我们按下 4 移除触发漏洞的文件</p><p>此时会显示 <code>Removed trigger file</code></p><p>再按下 5 完整移除 SD 卡上的 MSET9 相关文件</p><p>按下回车关闭窗口</p><p>从现在开始，机器启动将默认启动到 Luma3DS</p><h1 id="5-系统救砖以及自制软件安装"><a href="#5-系统救砖以及自制软件安装" class="headerlink" title="5-系统救砖以及自制软件安装"></a>5-系统救砖以及自制软件安装</h1><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><ul><li><a href="https://github.com/hacks-guide/finalize/releases/latest/download/x_finalize_helper.firm">x_finalize_helper.firm</a></li><li><a href="https://github.com/hacks-guide/finalize/releases/latest/download/finalize.romfs">finalize.romfs</a></li></ul><h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><p>关机，拔出 SD 卡，插回电脑</p><p>将 <code>finalize.romfs</code> 复制到 SD 卡根目录</p><p>复制 <code>x_finalize_helper.firm </code> 到 <code>SD卡:\luma\payloads\</code> 下，如果 payloads 目录不存在，需要手动新建</p><p>将 SD 卡插回机器</p><h2 id="RTC-和-DSP-设置"><a href="#RTC-和-DSP-设置" class="headerlink" title="RTC 和 DSP 设置"></a>RTC 和 DSP 设置</h2><p>这部分主要是将 3DS 内部时钟和实际时间进行同步，备份 3DS 的音频固件（在部分自制程序中需要使用，不然会出现声音异常）</p><p>按下 L + ↓ + select 启动 Rosalina Menu</p><p>选择 <code>Miscellaneous options</code></p><p>选择 <code>Dump DSP firmware</code></p><p>按 B 下一步</p><p>选择 <code>Nullify user time offset</code></p><p>按 B 下一步，按 B 退回 Rosalina 主菜单，再按 B 退出</p><h2 id="系统固件备份防砖-amp-一键安装实用自制程序"><a href="#系统固件备份防砖-amp-一键安装实用自制程序" class="headerlink" title="系统固件备份防砖 &amp; 一键安装实用自制程序"></a>系统固件备份防砖 &amp; 一键安装实用自制程序</h2><p>关机，按住 X 启动机器，此时会通过进入到 GodMode9 菜单 （从现在开始，我们可以按住 start 开机进入到 GodMode9 菜单）</p><p>在 GodMode9 菜单里，推荐进行系统重要固件备份，防止以后手贱变砖了还能救回来，同时推荐 <code>RTC date&amp;time</code></p><p>按下 Home 按键，呼出 action menu</p><p>选择 Scripts</p><p>选择 finalize</p><p>按照脚本中的提示操作，执行相应操作</p><p>当脚本最后提示 <code>Setup complete!</code>，按下 A 关机</p><p>此时机器的 SD 卡里已经有我们之前备份好的系统重要固件，我们将他插回电脑</p><p>备份的目录是在 <code>SD卡:\gm9\backups\</code> 记得复制到重要位置，硬盘云盘都备份一下，简单说明一下备份文件组成：</p><ul><li>SysNAND 和 NAND 备份用于恢复机器</li><li><code>essential.exefs</code> 包含主机系统的唯一信息文件，可用于在硬件故障时恢复数据</li></ul><p>备份好了可以将SD卡下的备份文件删除，由于 <code>essential.exefs</code> 文件并不大，建议保留在机器里，以便随时访问</p><h1 id="6-自制程序说明-amp-系统快捷键说明"><a href="#6-自制程序说明-amp-系统快捷键说明" class="headerlink" title="6-自制程序说明 &amp; 系统快捷键说明"></a>6-自制程序说明 &amp; 系统快捷键说明</h1><h2 id="自制程序说明"><a href="#自制程序说明" class="headerlink" title="自制程序说明"></a>自制程序说明</h2><p>在前面的脚本中，自动为我们安装了一些很实用的自制程序：</p><ul><li>FBI（安装 CIA 格式的应用程序）</li><li>Homebrew Launcher Loader（启动 Homebrew Launcher）</li><li>Anemone3DS （安装自定义主题）</li><li>Checkpoint（备份和恢复 3DS 和 DS 游戏的存档）</li><li>ftpd（通过 FTP 协议无线访问 3DS SD 卡文件系统）</li><li>Universal-Updater（一个自制应用程序商店，用于通过 Wi-Fi 从 3DS 下载自制软件）</li><li>GodMode9（NAND和游戏卡带备份的多功能工具）</li></ul><p>如果有任何一个自制软件不想要了，可以在系统设置 -&gt; 数据管理 -&gt; Nintendo 3DS -&gt; 软件 来删除它们（GodMode9 不能以这种方式删除）</p><h2 id="系统快捷键说明"><a href="#系统快捷键说明" class="headerlink" title="系统快捷键说明"></a>系统快捷键说明</h2><p>常用的快捷键按键组合：</p><ul><li>在启动时按住 Select 将启动 Luma3DS 配置菜单</li><li>在启动时按住 Start 键将启动 GodMode9（本质上是读取 <code>SD卡\luma\payloads\</code> 下的文件，如果有多个 payloads 启动的需求，可以使用 Luma3DS 链式加载器）</li><li>默认情况下，在 3DS 系统下按 L + ↓ + Select 将打开 Rosalina 菜单，可以在其中查看系统信息、截屏、启用作弊等</li><li>在启动时按住 Start + Select + X 将使机器外部的 LED 显示一种颜色，以便进行调试</li></ul>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win11内存管理</title>
    <link href="/2024/08/13/Win11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/08/13/Win11%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Edge优化"><a href="#Edge优化" class="headerlink" title="Edge优化"></a>Edge优化</h1><p>Edge 本身可以说是几家浏览器产品中性能优化最好的了，内存占用和硬件资源调度因为原生的原因做的都很不错</p><p>但是最近新加了一些没用的但是也很臃肿的功能，可以尝试关闭</p><h2 id="系统性能"><a href="#系统性能" class="headerlink" title="系统性能"></a>系统性能</h2><p>设置-系统和性能</p><ul><li>关闭启动增强，这玩意会在后台一直挂着一个进程用于快速开启浏览器，可以关掉这个减少内存占用，慢就慢一点</li><li>关闭继续运行后台扩展和应用，AdBlock也可以尝试关闭，内存占用较高</li><li>关闭在可用时使用图形加速</li><li>效率模式选择君和的节点量，资源调度和响应速度的折衷处理</li></ul><h1 id="IDEA优化"><a href="#IDEA优化" class="headerlink" title="IDEA优化"></a>IDEA优化</h1><p>一些没用的插件都可以直接卸载</p><p>Bundle 的就 Disable 掉</p><p>可以显著减少内存占用，亲测关闭了很多对大型项目运行没有帮助但是还是很占用内存的插件，直接腾出 1G 的 RAM 空间</p><h1 id="Antimalware"><a href="#Antimalware" class="headerlink" title="Antimalware"></a>Antimalware</h1><p>Windows Defender 的一个子程序</p><p>属于是流氓软件了，不能手动停止进程，开机自启</p><p>直接使用 dControl(v2.1) 强制关闭</p><p><a href="https://www.cnblogs.com/rqcim/p/16116684.html">Windows 11 彻底关闭 Windows Defender 降低内存占用，杀掉 Antimalware Service Executable 进程</a></p><h1 id="AlibabaProtect"><a href="#AlibabaProtect" class="headerlink" title="AlibabaProtect"></a>AlibabaProtect</h1><p>这个也是一个流氓软件，建议删除</p><p>服务无法在 Service 中进行禁用</p><p>可以通过管理员身份运行 Terminal 进行禁用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sc delete AliababaProtect<br></code></pre></td></tr></table></figure><p>会先标志为已删除，之后重启电脑的时候就不会再运行了</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper|部署与实战</title>
    <link href="/2024/08/08/Zookeeper-%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <url>/2024/08/08/Zookeeper-%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper重要概念-amp-架构"><a href="#Zookeeper重要概念-amp-架构" class="headerlink" title="Zookeeper重要概念&amp;架构"></a>Zookeeper重要概念&amp;架构</h1><p><a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html">ZooKeeper | Overview</a></p><p><a href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html">ZooKeeper | Quick Start</a></p><h3 id="数据模型和命名空间结构"><a href="#数据模型和命名空间结构" class="headerlink" title="数据模型和命名空间结构"></a>数据模型和命名空间结构</h3><p>ZK 的目录树结构有点类似文件系统，但是也有所区别</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/1723089429545-3e14456d-da46-4790-ac32-59e41fd5faf0.png"></p><h3 id="ZNode"><a href="#ZNode" class="headerlink" title="ZNode"></a>ZNode</h3><p>ZK中称每一个注册到ZK的节点为 ZNode，每个 ZNode 之间通过&#x2F;来进行分层，进行父子关系区分</p><p>每个 znode 包含了一个记录自身数据变化版本，访问权限控制，时间戳等的状态信息，用于缓存验证和一致性更新。每当 znode 的数据发生变化时，版本号会更新，因此任何一个客户端读取到 ZNode 的数据都包含了数据版本信息</p><p>ZNode 也有分很多类型，比较常用的是 Ephmeral 类型的节点，这种类型的节点会随着 服务节点和 ZK 连接会话的消亡而一起消亡，只要会话还保持心跳链接，这个 ZNode 就可以一致存在；如果会话结束，节点自动删除，节省资源</p><h3 id="条件更新和-Watchers"><a href="#条件更新和-Watchers" class="headerlink" title="条件更新和 Watchers"></a>条件更新和 Watchers</h3><p>ZK中的 Watch 类似事件驱动的消息</p><p>当 ZNode 发生变更时（通常就是断联），Watch 将会被触发和移除</p><p>当 Watch 触发时，客户端会受到 ZNode 发生变更的消息</p><p>3.6.0 以后支持客户端设置常驻Watcher，这种类型的Watcher在触发之后不会被删除，同时会触发关于某个 ZNode 和其所有子 ZNode 的消息</p><h3 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h3><ul><li>create 在ZK维护的路径树上新增 ZNode</li><li>delete</li><li>exists 判断某个指定位置是否存在指定 ZNode</li><li>get data 读取 ZNode 数据</li><li>set data 写数据</li><li>get childeren 获取某个 ZNode 下所有 ZNode</li><li>sync 同步数据传播（？）</li></ul><h1 id="Docker部署Zookeeper最佳实践"><a href="#Docker部署Zookeeper最佳实践" class="headerlink" title="Docker部署Zookeeper最佳实践"></a>Docker部署Zookeeper最佳实践</h1><h2 id="单点部署"><a href="#单点部署" class="headerlink" title="单点部署"></a>单点部署</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --name zk-standalone -p 2181:2181 -p 2888:2888 -p 3888:3888 -v G:/Docker Volumes/zk_standalone:/data -e ZOO_MY_ID=1 zookeeper:latest<br></code></pre></td></tr></table></figure><p>CLI接口交互执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it zk-standalone bin/zkCli.sh -server localhost:2181<br></code></pre></td></tr></table></figure><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>TODO，目前暂时没有需求，一个 Docker-compose 即可在单机上拉集群，Kubernetes 应该可以部署多点集群</p><h1 id="Spring-Boot-整合-Curator"><a href="#Spring-Boot-整合-Curator" class="headerlink" title="Spring Boot 整合 Curator"></a>Spring Boot 整合 Curator</h1><p>更多的时候还是通过项目的客户端接口来对 ZK 进行 ZNode 操作，项目使用的是 Curator</p><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p><a href="https://curator.apache.org/docs/getting-started">Getting Started | Apache Curator</a></p><p>官方提供了预构建的 Curator Recipes 部署包</p><p>当然很多时候我们只是想要用 Curator 更方便的客户端包，只需要引用 Curator Framework 即可</p><h2 id="获得连接"><a href="#获得连接" class="headerlink" title="获得连接"></a>获得连接</h2><p>对于一个 ZK 的集群对象，只需要一个 CuratorFramework 实例</p><p>建议针对项目新增一个配置类，来映射配置文件的地址信息</p><p>在实例化客户端对象的时候需要的参数大致就是：</p><ul><li>ZK的ip:port</li><li>会话超时时间</li><li>连接超时时间</li><li>重试次数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">cf</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.newClient(...);<br>cf.start();<br></code></pre></td></tr></table></figure><p>客户端实例对象 CuratorFramework 必须在使用前 start 不需要时 close</p><p>之后就是一些增删改查的基础 API 了</p><p>Curator 提供的 API 基本都是流式接口的规范，也就是链式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cf.create().withMode(CreateMode.EPHEMERAL).forPath(path, bytes);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EDA</tag>
      
      <tag>Distributed System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java|重学泛型</title>
    <link href="/2024/08/06/Java-%E9%87%8D%E5%AD%A6%E6%B3%9B%E5%9E%8B/"/>
    <url>/2024/08/06/Java-%E9%87%8D%E5%AD%A6%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>之前提到泛型，更多的时候只是在容器类中用到这个，知道他是参数化类型，除此之外别无其它了，甚至自己写也不一定能写的明白</p><p>今天写业务需求刚好需要用到泛型</p><p>趁此机会参考<a href="https://www.cnblogs.com/coprince/p/8603492.html">一个博客</a>系统性的学习一下泛型相关的知识点</p><p>这边以自定义一个简单的通用容器 GenericContainer 为例开始学习</p><h1 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h1><p>Java中的泛型，特性是<strong>只会在编译期生效</strong></p><p>对于定义了参数化类型的泛型类，不一定需要传入参数，例如常见的容器类型，泛型参数只是一个<strong>约束限制</strong>，如果没有传也可以，但是<strong>在编译期间得不到对应类型的结果</strong>，具体在 IDEA 中就是会爆黄</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果不传入泛型参数，默认得到的都是Object类型</span><br>      <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br><br>List&lt;String&gt; paramiterizedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> paramiterizedList.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h1 id="从泛型类开始"><a href="#从泛型类开始" class="headerlink" title="从泛型类开始"></a>从泛型类开始</h1><p>知道了上面泛型的特性之后我们可以自定义做一个容器，来运用泛型类的特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericContainer</span>&lt;T&gt; &#123;<br><br><span class="hljs-comment">//参数化类型属性作为类的成员，一种很常见的操作，容器类也都是这样定义的</span><br><span class="hljs-keyword">private</span> T item;<br><br>T <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> item;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setItem</span><span class="hljs-params">(T item)</span> &#123;<br><span class="hljs-built_in">this</span>.item = item;<br>&#125;<br><br>GenericContainer() &#123;<br>&#125;<br><br>GenericContainer(T item) &#123;<br><span class="hljs-built_in">this</span>.item = item;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在声明这个泛型类的时候，编译阶段就锁死了容器中泛型的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//String 类型容器</span><br>GenericContainer&lt;String&gt; strContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericContainer</span>&lt;&gt;();<br><span class="hljs-comment">//Integer 类型容器</span><br>GenericContainer&lt;Integer&gt; intContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericContainer</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span> &lt;T&gt;&#123;<br><br>T <span class="hljs-title function_">duplicateItem</span><span class="hljs-params">(T item)</span>;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">duplicateItem</span><span class="hljs-params">(Object item)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有传递类型作为参数约束，那么类型就没有特定化，只能返回 Object 类型的通用对象</p><p>当然更常见的是将参数设置权抛出给上游，在实现类中继续接收类型参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">duplicateItem</span><span class="hljs-params">(T item)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//String 类型容器</span><br>GenericContainer&lt;String&gt; strContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericContainer</span>&lt;&gt;();<br><span class="hljs-comment">//Integer 类型容器</span><br>GenericContainer&lt;Integer&gt; intContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericContainer</span>&lt;&gt;();<br><span class="hljs-comment">//Number 类型容器</span><br>GenericContainer&lt;Number&gt; numberContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericContainer</span>&lt;&gt;();<br><br><span class="hljs-comment">//显示Integer类型容器</span><br>showItem(intContainer);<br><span class="hljs-comment">//显示Number类型容器</span><br>showItem(numberContainer);<br>&#125;<br><span class="hljs-comment">//需要用?通配符来兼容所有泛型类型，但是由于兼容性高，只能对具体item看作Object进行操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showItem</span><span class="hljs-params">(GenericContainer&lt;?&gt; numberContainer)</span>&#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> numberContainer.getItem();<br>System.out.println(item);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过 ? 来标识，这个类型参数我们不知道，但是为了<strong>适配兼容具有多态通用性，使用通配符 ？作为类型实参</strong></p><p>但是需要注意由于使用了通配符，兼容性很强，可以把？看作是所有参数类型的父类，相当于是参数类型中的Object，因此只能当作 Object 用，可用的方法在编译期间十分有限</p><p>可以解决当具体类型不确定的时候，这个通配符就是 ?  </p><p>当操作类型时，<strong>不需要使用类型的具体功能时，只使用Object类中的功能</strong>，那么可以用 ? 通配符来表未知类型</p><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p>泛型类和泛型方法差别很大，并且这两个都会更加常见，一开始学习的时候也是把泛型方法和泛型类混淆了，尤其是泛型方法看着很吃力</p><p>泛型类，是在实例化类的时候指明泛型的具体类型</p><p>泛型方法，是在调用方法的时候指明泛型的具体类型</p><p>具体看一下代码就知道了，泛型方法需要在 范围修饰符 和 返回值之间通过一个 &lt;&gt; 来限定作用在这个方法中的所有参数类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,E&gt; E <span class="hljs-title function_">changeItem</span><span class="hljs-params">(GenericContainer&lt;T&gt; container)</span>&#123;<br>GenericContainer&lt;E&gt; changedContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericContainer</span>&lt;&gt;();<br>       <span class="hljs-comment">//这里只是简单模拟转换，具体根据业务场景进行转换</span><br>changedContainer.setItem((E)container.getItem());<br><span class="hljs-keyword">return</span> changedContainer.getItem();<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是泛型方法 和带有通配符的泛型方法之间很容易在初学的时候被混淆</p><p>下面这两个都是和泛型确实有关的方法，但是<strong>只是确定参数类型的泛型类对象 作为方法参数的 一个普通方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//这个只是带有特殊确定实参的容器，作为参数，的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showItem</span><span class="hljs-params">(GenericContainer&lt;?&gt; trueGenericContainer)</span>&#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> trueGenericContainer.getItem();<br>System.out.println(item);<br>&#125;<br>   <span class="hljs-comment">//本质上和这个方法没有任何区别</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showIntItem</span><span class="hljs-params">(GenericContainer&lt;Integer&gt; intContainer)</span>&#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> intContainer.getItem();<br>System.out.println(item);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果你想要在调用方法的时候，传递不确定的参数，就需要声明泛型方法👆</p><h2 id="泛型类中的泛型方法"><a href="#泛型类中的泛型方法" class="headerlink" title="泛型类中的泛型方法"></a>泛型类中的泛型方法</h2><p>我们在之前的 GenericContainer 泛型类中新增三个方法，当然第一个不是泛型方法，只是带有泛型类型参数的 <strong>在泛型类中存在的</strong> 普通方法，<strong>他的 T 一定等于 泛型类初始化的时候的 T</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意这三个方法的名称不能重复，由于泛型只作用于编译阶段，因此同名的方法在编译阶段会被认为是同一个方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showContainerItem</span><span class="hljs-params">(T item)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;item is &quot;</span> + item);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">showParameterizedItem</span><span class="hljs-params">(E item)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;item is &quot;</span> + item);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAnotherParameterizedItem</span><span class="hljs-params">(T item)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;item is &quot;</span> + item);<br>&#125; <br></code></pre></td></tr></table></figure><p>之后我们测试调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//-----测试泛型类中泛型方法-----//</span><br>GenericContainer&lt;Number&gt; numberGenericContainer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericContainer</span>&lt;Number&gt;();<br><span class="hljs-type">Number</span> <span class="hljs-variable">numberItem</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//泛型类型作为参数调用传参，没有任何问题</span><br>numberGenericContainer.showContainerItem(numberItem);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">intItem</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">//也没有问题，对应的是函数调用多态，要求传入 T 类型，由于上面的实例化，在编译期间已经确定了是 Number 类型</span><br><span class="hljs-comment">// 实际传入子类，一点问题没有</span><br>numberGenericContainer.showContainerItem(intItem);<br><span class="hljs-type">String</span> <span class="hljs-variable">strItem</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-comment">//这个有问题，因为泛型类型是Number，showContainerItem本质不是泛型方法</span><br><span class="hljs-comment">//只能固定接收泛型类型以及对应类型的子类，所以这里编译器会报错</span><br>numberGenericContainer.showContainerItem(strItem);<br><span class="hljs-comment">//没有问题，showParameterizedItem本质上是一个泛型方法，此时E = String</span><br>numberGenericContainer.showParameterizedItem(strItem);<br><span class="hljs-comment">//没有问题，showClassSameParameterizedItem本质上也是一个泛型方法，此时方法的T = String，类的T = Number，两个不是一个T</span><br>numberGenericContainer.showClassSameParameterizedItem(strItem);<br></code></pre></td></tr></table></figure><h2 id="泛型方法和可变参数"><a href="#泛型方法和可变参数" class="headerlink" title="泛型方法和可变参数"></a>泛型方法和可变参数</h2><p>可变参数可以看作是 Object[]</p><p>那么我们可以编写一个通用的工具方法打印不同类型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericUtils</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printData</span><span class="hljs-params">(E... data)</span>&#123;<br><span class="hljs-keyword">for</span> (E e : data) &#123;<br><span class="hljs-comment">//要求传入的类都实现toString方法</span><br>System.out.println(e);<br>&#125;<br>&#125;<br>&#125;<br>GenericUtils.printData(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-number">3L</span>,<span class="hljs-number">4.0f</span>,<span class="hljs-number">5.0</span>);<br></code></pre></td></tr></table></figure><h2 id="泛型方法和静态"><a href="#泛型方法和静态" class="headerlink" title="泛型方法和静态"></a>泛型方法和静态</h2><p>当静态方法想要使用泛型的时候，不可以存在之前那样将泛型类型作为形参，而本身不是泛型方法的情况</p><p>我们上面的工具方法就是一个静态的泛型方法，<E> 不可删除</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li>泛型方法可以使得方法独立于类做到动态接收不同类型的变化，在设计一些通用的工具方法和设计模式中十分好用</li><li>泛型方法定义在泛型类中时，泛型方法自身定义的泛型类型 和 类定义的泛型类型 可以重名会覆盖，但是在设计时应当尽量避免重名减少歧义（T E V 不够你用了吗XD）</li><li>需要警惕区分 <strong>在泛型类中存在的，泛型类型作为函数接收形参（本质上和泛型类初始化强绑定）的普通方法</strong>  和正常的泛型方法，自己在定义泛型方法的时候也应当先看看所在类是否已经是泛型类</li></ul><h1 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h1><p>在实际使用的时候，我们往往希望限定传入的类型实参 是某个特定的父类或者子类，这样在对类型实参对象操作的时候能力会更多</p><ul><li>在通配符（特定不知道的类型实参限定，从Object下更加细化）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showNumberItem</span><span class="hljs-params">(GenericContainer&lt;? extends Number&gt; trueGenericNumberContainer)</span>&#123;<br><span class="hljs-comment">//限定了上下界后，通配符获得的就不再是 Object 类型，能力更强</span><br><span class="hljs-type">Number</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> trueGenericNumberContainer.getItem();<br>System.out.println(item.longValue());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>泛型类中限定（容器只能存储特定类型）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericContainer</span>&lt;T <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Number</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>泛型方法中限定</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">showParameterizedNumberItem</span><span class="hljs-params">(E item)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;item is &quot;</span> + item.longValue());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NS|Hekate+Atomosphere Guide</title>
    <link href="/2024/07/25/NS-Hekate-Atomosphere-Guide/"/>
    <url>/2024/07/25/NS-Hekate-Atomosphere-Guide/</url>
    
    <content type="html"><![CDATA[<h1 id="所需硬件"><a href="#所需硬件" class="headerlink" title="所需硬件"></a>所需硬件</h1><ul><li>短接器，可以回形针自己做一个，我是淘宝直接买</li><li>大于 64G 的 TF 卡一张</li><li>Unpatched Switch 我这里是 2018 的早期版本，RCM 的硬件漏洞未被</li></ul><h1 id="专业术语介绍"><a href="#专业术语介绍" class="headerlink" title="专业术语介绍"></a>专业术语介绍</h1><h2 id="何为-RCM"><a href="#何为-RCM" class="headerlink" title="何为 RCM"></a>何为 RCM</h2><blockquote><p>RCM (short for ReCovery Mode) is a pre-boot mode for Tegra processors that allows NVIDIA and Nintendo to send the Switch tiny programs for various internal uses. On unpatched consoles, once a payload was sent, then quickly copied into the memory buffer behind the stack, it overflowed the memory buffer into the stack. This leads to a “smashed stack” and unsigned code execution within a bootROM context, giving us access to nearly everything on the console. We use it here to launch Atmosphère.If you choose the emuMMC path introduced later in the guide, it’ll be important to disable the Automatic Save Data Cloud function beforehand, as well as making sure the Switch is set as the primary console.</p><p>RCM（ReCovery Mode 的缩写）是 Tegra 处理器的预启动模式，允许 NVIDIA 和任天堂向 Switch 发送用于各种内部用途的微型程序。在未打补丁的控制台上，一旦发送了有效负载，然后快速复制到堆栈后面的内存缓冲区中，它就会使内存缓冲区溢出到堆栈中。这导致了在bootROM上下文中“破碎的堆栈”和未签名的代码执行，使我们能够访问控制台上的几乎所有内容。我们在这里使用它来启动 Atmosphère。如果您选择指南后面介绍的 emuMMC 路径，请务必事先禁用自动保存数据云功能，并确保将 Switch 设置为主控制台。</p></blockquote><h2 id="SysMMC-amp-EmuMMC"><a href="#SysMMC-amp-EmuMMC" class="headerlink" title="SysMMC &amp; EmuMMC"></a>SysMMC &amp; EmuMMC</h2><p>SysMMC 为真实系统所在的系统固件</p><p>但是我们完全可以复制一份真实系统的副本，将其存储在 SD 卡里，我们成为 EmuMMC</p><p>两个系统互不影响，相互独立，真实系统可以进行正版的任何行为，虚拟系统可以长时间保持飞行模式</p><h1 id="进入-RCM-amp-发送负载"><a href="#进入-RCM-amp-发送负载" class="headerlink" title="进入 RCM &amp; 发送负载"></a>进入 RCM &amp; 发送负载</h1><h2 id="进入-RCM"><a href="#进入-RCM" class="headerlink" title="进入 RCM"></a>进入 RCM</h2><p>保持 NS 关机状态，短接器短接右侧有线滑轨，按住 音量+ 后按下开机</p><p>如果没有开机说明已经进入了 RCM 模式，如果开机了，要么是短接正反面拿反了（不要问我为什么会知道XD）要么就是机器的硬件漏洞已经被修复，是无法软破的机器(Patched Console)</p><p>确保进入 RCM 模式之后短接器就可以拆走了</p><h2 id="发送负载"><a href="#发送负载" class="headerlink" title="发送负载"></a>发送负载</h2><ul><li>下载最新版本的 TegraRcmGUI</li><li>使用USB-A 转 USB-C 线缆（如果您的计算机本身支持 USB-C，则为标准 USB-C 线缆）</li><li>下载 Hekate 的最新版本 目前只需要关注压缩包内的 hekate_ctcaer_(version).bin 这个文件，这个文件就是负载</li></ul><p>电脑运行 TegraRcmGUI，同时将 Switch 连接到电脑上</p><p>首次运行请安装驱动，不然检测不到 Switch</p><p>如果下面窗口是绿色代表检测到了进入 RCM 模式的 Switch，选择上面的 hekate_ctcaer_(version).bin 进行负载的发送</p><p>这个时候就已经进入到 Hekate 引导界面了</p><h1 id="TF-卡制作"><a href="#TF-卡制作" class="headerlink" title="TF 卡制作"></a>TF 卡制作</h1><p>进入到引导界面的时候可以安全取出 TF 卡，所以没必要完全关机，直接拔插是没有问题的</p><p>在 Hekate 的最新版本压缩包内找到 bootloader 文件夹，放在 TF 卡根目录即可，TF 卡放回 NS </p><p>使用音量+和音量-来在 Hekate 菜单中移动，移动到 <code>reload</code> 按下电源键进行选择</p><p>现在应该可以进入到 Hekate 的 GUI 里了</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Switch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU 15-213|Machine Level Programming-Procedure</title>
    <link href="/2024/07/03/CMU-15-213-Machine-Level-Programming-Procedure/"/>
    <url>/2024/07/03/CMU-15-213-Machine-Level-Programming-Procedure/</url>
    
    <content type="html"><![CDATA[<h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><p>在机器指令实现过程调用（函数调用）的这个过程中，需要考虑的基本流程主要有下面三个：</p><ul><li>传递控制：PC 变更，以及保留 PC 原始位置，return 要能回得来</li><li>传递数据：调用函数的时候形参的传递，以及 return value 的传递</li><li>内存管理：在调用函数的时候需要进行内存管理，函数 return 回来之后需要释放所占内存</li></ul><h1 id="X86-64的栈"><a href="#X86-64的栈" class="headerlink" title="X86-64的栈"></a>X86-64的栈</h1><p>X86中的栈本质上是一块内存区域，还记得我们之前介绍寄存器的时候一直在避开一个寄存器叫 <code>%rsp</code> 也就是 rigister stack pointer 他存储的是栈的栈顶指针</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702141225086.png"></p><p>实际上它是一个倒过来的栈，<strong>地址越高说明在栈的越里面</strong></p><h2 id="pushq"><a href="#pushq" class="headerlink" title="pushq"></a>pushq</h2><p>我们假设当前 <code>%rsp</code> 指向的是红色位置</p><p>对于一个 push 操作，他的机器指令一般是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushq src<br></code></pre></td></tr></table></figure><p>主要完成的操作分为三步</p><ul><li>读取 src 地址所指向的操作数</li><li>更新 <code>%rsp += 8</code> 也就是栈的指针向下移动一个位置，用于存数据（此时 rsp 位置是在蓝色的位置）</li><li>把操作数写入到 <code>%rsp</code> 所指向的栈中位置里</li></ul><h2 id="popq"><a href="#popq" class="headerlink" title="popq"></a>popq</h2><p>我们还是假设当前 <code>%rsp</code> 指向的是红色位置</p><p>对于一个 pop 操作，他的机器指令一般是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">popq dest<br></code></pre></td></tr></table></figure><p>主要完成的操作分为三步</p><ul><li>读取此时 <code>%rsp</code> 所指向的栈内的数据</li><li>更新 <code>%rsp -=8</code> 也就是栈的指针向上移动一个位置，表示已经 pop 出了这个数据了，之前那个数据就不再记录了，要记录也是下一次覆盖了（此时 rsp 的位置是在黄色的位置）</li><li>把之前读取的栈内的数据写入 dest 中（<strong>这里要求 dest 必须是一个寄存器</strong>）</li></ul><h1 id="调用详细流程"><a href="#调用详细流程" class="headerlink" title="调用详细流程"></a>调用详细流程</h1><p>我们看一个最简单的例子，相乘两数之后存储到一个指定位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// multstore 函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">multstore</span> <span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span>, y, <span class="hljs-type">long</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> t = mult2(x, y);<br>    *dest = t;<br>&#125;<br><br><span class="hljs-comment">// mult2 函数</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">mult2</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b)</span><br>&#123;<br>    <span class="hljs-type">long</span> s = a * b;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的机器代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000400540 &lt;multstore&gt;:<br>    # x 在 %rdi 中，y 在 %rsi 中，dest 在 %rdx 中<br>    400540: push    %rbx            # 通过压栈保存 %rbx<br>    400541: mov     %rdx, %rbx      # 保存 dest<br>    400544: callq   400550 &lt;mult2&gt;  # 调用 mult2(x, y)<br>    # t 在 %rax 中<br>    400549: mov     %rax, (%rbx)    # 结果保存到 dest 中<br>    40054c: pop     %rbx            # 通过出栈恢复原来的 %rbx<br>    40054d: retq                    # 返回<br><br>0000000000400550 &lt;mult2&gt;:<br>    # a 在 %rdi 中，b 在 %rsi 中<br>    400550: mov     %rdi, %rax      # 得到 a 的值<br>    400553: imul    %rsi, %rax      # a * b<br>    # s 在 %rax 中<br>    400557: retq                    # 返回<br></code></pre></td></tr></table></figure><h2 id="传递控制"><a href="#传递控制" class="headerlink" title="传递控制"></a>传递控制</h2><p>在这个过程中，代码是如何跳转的，主要就是依靠 <code>call</code> 以及 <code>ret</code> 借助 stack 的隐式 push 和 pop 操作来实现程序的控制传递</p><p>初始状态在控制传递之前的一步，此时的 PC 指向的是准备进行调用函数的语句 call 那一段的地址</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702144928344.png"></p><p>在调用 call Label 的时候会隐式的进行 pushq 的操作，这个时候 push 的数据是原先 PC 要更新的值，也就是 call 之后的下一条语句，我们进行入栈保存，如图栈顶数据以及栈顶的指针 <code>%rsp</code> 都得到了更新</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702153524410.png"></p><p>之后执行调用函数的逻辑，准备返回外部函数的时候， PC 的指针已经指向了 return 语句</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702153751107.png"></p><p>此时调用 return 语句，也会隐式地调用 pop 操作，将之前压入栈内的返回地址交给 PC ，同时也更新 <code>%rsp</code> 的指针位置，至此就完成了过程调用时控制传递，PC有去有回的效果</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702153903157.png"></p><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>下面需要回答之前提出的第二个问题，也就是在过程调用的时候，参数数据应该如何传递</p><p>在看到上面的汇编代码时我们也能总结出规律：</p><ul><li>在参数少于六个的时候，用通用寄存器组(%rdi, %rsi, %rdx, %rcx, %r8, %r9 )来传递；大于六个参数的时候，多出来的参数会放在栈中存储</li><li>由于 caller 和 callee 都能正常访问到对应的寄存器，因此就是<strong>通过可见的通用寄存器来实现数据的传递</strong></li><li>无论是外层函数还是被调用的内层函数，存储返回值的寄存器都是 <code>%rax</code> 寄存器</li></ul><h3 id="内存管理（栈帧）"><a href="#内存管理（栈帧）" class="headerlink" title="内存管理（栈帧）"></a>内存管理（栈帧）</h3><p>至于之前提出的第三个问题，机器级别的代码如何实现内存管理</p><p>市面上主流的基于堆栈的编程语言例如 Java 他们的代码就要求是<strong>可重入</strong>的，因为可能会出现多个单一程序的实例并发的进入</p><p>因此对于每一个实例需要有个地方去存储状态：</p><ul><li>程序参数</li><li>本地变量</li><li>返回的指针信息</li></ul><p>对于每个过程调用来说，都会在栈中分配一个帧 Frame</p><p>每一帧里需要包含：</p><ul><li>返回信息</li><li>本地存储（如果需要）</li><li>临时空间（如果需要）</li></ul><p>由于引入了帧的概念，也需要一个指针来记录当前帧的位置，当然这个是可选的，对应记录帧位置的寄存器就是 <code>%rbp</code></p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702162318342.png"></p><p>每一个过程调用对应的栈帧都会在 call 的第一时间进行空间分配，在 return 返回的最后一刻进行回收</p><p>在 x86-64 &#x2F; Linux 的栈帧中，基本的组成包含如下</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702162649622.png"></p><p>下面我们进行举例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">incr</span><span class="hljs-params">(<span class="hljs-type">long</span> *p, <span class="hljs-type">long</span> val)</span> &#123; <br>      <span class="hljs-type">long</span> x = *p; <br>      <span class="hljs-type">long</span> y = x + val; <br>      *p = y; <br>      <span class="hljs-keyword">return</span> x; <br>&#125; <br></code></pre></td></tr></table></figure><p>这个被调用的函数 callee 的汇编很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">incr: <br>      movq (%rdi), %rax<br>      addq %rax, %rsi<br>      movq %rsi, (%rdi) <br>  ret <br></code></pre></td></tr></table></figure><p>但是调用他的 call_incr 就不那么简单了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">call_incr</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">long</span> v1 = <span class="hljs-number">15213</span>;<br>     <span class="hljs-type">long</span> v2 = incr(&amp;v1, <span class="hljs-number">3000</span>);<br>     <span class="hljs-keyword">return</span> v1+v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call_incr: <br>      subq $16, %rsp<br>      movq $15213, 8(%rsp) <br>      movl $3000, %esi<br>      leaq 8(%rsp), %rdi<br>      call incr<br>      addq 8(%rsp), %rax<br>      addq $16, %rsp<br>      ret<br></code></pre></td></tr></table></figure><p>逐步解析：</p><p>首先第一行，此时还是在 <code>call_incr</code> 的栈帧，栈帧中存储局部参数</p><p>注意图中 <code>%rsp</code> 指向的地址是调用 <code>call_incr</code> 的 caller 在 <code>call call_incr</code> 的下一步就设置好了的，它是属于 <code>call_incr</code> 栈帧的一部分，图里 <code>...</code> 的部分才是栈中其他前面的函数的栈帧</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702164752302.png"></p><p>第二行，这里是在进行 callee 的入参设置</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702165051161.png"></p><p>之后通过 call label 的方式进行过程调用，返回值（根据上面的c代码，返回的是相加前的 value）存储在 <code>%rax</code> 中</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702165230931.png"></p><p>下面就要结束 <code>caller</code> 的代码了，在 return 的最后一步，把栈帧抹去</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702165526018.png"></p><h3 id="Caller-amp-Callee-寄存器一致性协调"><a href="#Caller-amp-Callee-寄存器一致性协调" class="headerlink" title="Caller &amp; Callee 寄存器一致性协调"></a>Caller &amp; Callee 寄存器一致性协调</h3><p>通过上面的例子我们也可以发现</p><p>实际上在进行过程调用的时候，Caller 和 Callee 之间是通过彼此都可见的寄存器来进行参数传递的</p><p>因此在汇编代码中需要尽可能避免调用前后使用同一个寄存器的情况，因为此时作为入参的寄存器中数据可能已经在 Callee 中被修改了</p><p>同时也并不是所有的寄存器都可以用来存放临时的变量，因此需要某些规则或者说一致性的协商来实现</p><p>这也正是不同 ISA 之间函数过程调用之间的细小差异，只是在调用规则的一致性合约上进行了不同的规定，哪些寄存器用来传递参数，哪些存储返回值，哪些寄存器调用者&#x2F;被调者可以放心使用(Caller Saved &amp; Callee Saved)等，主要就是在这一块不一样</p><ul><li>Caller Saved 的寄存器<ul><li>Caller 在调用前在他的栈帧中可以保存临时值</li></ul></li><li>Callee Saved 的寄存器<ul><li>Callee 在使用前可以在他的栈帧中保存临时值</li><li>Callee 可以在返回 Caller 之前恢复临时值</li></ul></li></ul><p>具体都有哪些呢？这个其实不是重点也不用记，简单看一下就好了，因为不会让你手写汇编的，实际上编译器也比你更聪明XD</p><p><img src="/../../../../Pictures/Markdown_Pic/CMU-15-213-Machine-Level-Programming-Procedure/image-20240702171418503.png"></p><p>针对 callee saved 的寄存器，也有对应的例子，实际上我们可以理解为，它就是函数的入参，callee 可以对这个寄存器进行修改，但是原先传入的入参都需要保留和恢复</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">call_incr2</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123; <br>      <span class="hljs-type">long</span> v1 = <span class="hljs-number">15213</span>; <br>      <span class="hljs-type">long</span> v2 = incr(&amp;v1, <span class="hljs-number">3000</span>); <br>      <span class="hljs-keyword">return</span> x+v2; <span class="hljs-comment">//注意是x+x2</span><br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240702172922031.png"></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归本质上也是一次特殊的过程调用</p><p>课件中的例子如下：实际上就是迭代式的 popcount 改写成了递归式的实现方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">pcount_r</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x)</span> &#123;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> (x &amp; <span class="hljs-number">1</span>) + pcount_r(x &gt;&gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pcount_r:<br>    mov     $0, %eax<br>    testq   %rdi, %rdi<br>    je      .L6<br>    push    %rbx<br>    movq    %rdi, %rbx<br>    andl    $1, %ebx<br>    shrq    %rdi<br>    call    pcount_r<br>    addq    %rbx, %rax<br>    popq    %rbx<br>.L6:<br>    rep; ret<br></code></pre></td></tr></table></figure><p>下面我们就来分析这段代码例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pcount_r:<br>    mov     $0, %eax<br>    testq   %rdi, %rdi<br>    je      .L6<br></code></pre></td></tr></table></figure><p>这一部分其实就对应 <code>x==0</code> 的判断，很好理解</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术日记</title>
    <link href="/2024/07/01/%E6%8A%80%E6%9C%AF%E6%97%A5%E8%AE%B0/"/>
    <url>/2024/07/01/%E6%8A%80%E6%9C%AF%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2024"><a href="#2024" class="headerlink" title="2024"></a>2024</h1><h2 id="6月小结"><a href="#6月小结" class="headerlink" title="6月小结"></a>6月小结</h2><p>TODO</p><h2 id="07-x2F-01"><a href="#07-x2F-01" class="headerlink" title="07&#x2F;01"></a>07&#x2F;01</h2><h3 id="Github-上发现的开源大佬"><a href="#Github-上发现的开源大佬" class="headerlink" title="Github 上发现的开源大佬"></a>Github 上发现的开源大佬</h3><p>今天上班的时候摸鱼刷 Github 刷到一个做 MIT6.828 实验的大佬，点进主页一看还真的是个大佬</p><p>看到他的自我介绍，高中毕业的学历，18 年 28 岁转行程序员，自学前端，一步步走到管理层，感觉很有兴趣，肯定有值得学习的地方</p><p>虽然如果 18 年换成六年后的今天，同样的情况几乎不可能实现，18 年的计算机行业算不上黄金的红利风口时期，但是也远没有到今年的地步，在感慨他人恰逢一个好的时代的同时，不得不肯定的是这个老哥的自学能力以及对技术的追求和热爱</p><p>其中他的开源文章就分享了一些从业前端和管理方向的开发者工作心得，觉得很有用，记录一下：</p><ul><li>一个好的程序员必须得懂业务，但是和写不写业务页面关系不大，就算是搞基础架构也需要懂业务，你得明白公司靠什么赚钱，脱离了业务讨论都是扯淡</li><li>找工作的时候心态很重要，或者说生活中的任何事情，心态都很重要。面试是双向的选择，不是候选人在求着别人给工作，所以面试时不要把自己的位置放得太低。面试也是一件很讲运气的事，通过不了不一定是你技术不行，很有可能是问的问题刚好你不会（位置对调，面试官也有可能通过不了面试）、气场不合、价值观不符合等等。面试挂了做下复盘再准备下一次面试，不要在一棵树上吊死</li><li>计算机基础是地基，决定了一个程序员的技术上限。管理系统写得再好，也只能证明你是一个熟练业务操作的人员，想要成为行业拔尖的水平，想要铸就不可替代性，需要的是计算机基础，任何框架和第三方库都是基于基础设施的高层建筑，基础打好了，楼才能建得高</li><li>其中还提到了作为一个程序员的学习方式，内容比较多直接提取出来<a href="#%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%BC%8F">单独成一点</a></li><li>通常情况下，技术和薪资成正比</li><li>技术好的人比较自信，脾气也比一般人暴躁</li><li>不要裸辞，找好下家再辞职</li><li>涨薪基本靠跳槽</li><li>同事有可能会成为朋友，但最终都是过客</li><li>要有职业规划，没有就去想，直到想出来为止</li><li>面试造航母，工作拧螺丝不是玩笑话</li><li>要学会心平气和的跟产品沟通，尤其是不懂技术的产品，虽然很难</li><li>每天写业务页面不能让你变强，顶多算是比较熟练的流水线工人，要变强还得靠业余时间</li><li>喜欢学习的程序员很少，得过且过才是大多数</li><li>工作不忙时，尽量利用这段时间学习；技术越好，任务完成得越快，摸鱼的时间就越多</li><li>少管闲事，有时间多学习</li><li>少关注八卦新闻，多学习</li><li>别拍马屁，有那功夫多学习</li><li>时刻反省自己，今天有没有学习</li></ul><h3 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h3><p>主要有两种：</p><ul><li>知识固化，写作</li><li>灵魂三连问</li></ul><p>知识固化这个就不多说了，之前其实也在 <code>游戏札记</code> 这一系列文章中提到了，可以将学习到的知识尽可能的记忆下来，强化记忆。同时也能锻炼自己的表达能力，一个程序员必须需要具备优秀的表达能力，才能在职场中进行有效的沟通交流。此外，能把自己每日的学习总结提取成一段精炼的文字，也是理解能力的一种表现。</p><p>至于这个灵魂三连问，主要是说：在学习新的知识点时，时常问自己三个问题：</p><ul><li>这是什么？</li><li>为什么要这样？可以不这样吗？</li><li>有没有更好的方式？</li></ul><h3 id="CSAPP-流水线"><a href="#CSAPP-流水线" class="headerlink" title="CSAPP 流水线"></a>CSAPP 流水线</h3><p>回家后主要还是在学习 CSAPP 的汇编条件控制部分知识</p><p>之前教授上课讲到的为何需要 Conditional Branch 技术，之前流水线技术听的一知半解，现在配合博客总算是有了大概的概念</p><p>大致的意思就是由于 CPU 的流水线技术，编译器需要尽可能地减少错误的分支判断，<strong>一旦判断失误进入了错误的分支，先前因为流水线技术而加载进入寄存器的数据全部都是对不上号的了</strong>，因此需要进行分支预测来优化程序的执行</p><p>针对仅仅只有两种条件跳转的代码（例如<strong>三元运算符</strong>），编译器往往就会采用 Conditional Branch 的技术，通过枚举出所有可能的结果状态（实际上也就只有两种），最后根据一条比较指令来同时设置结果值，从而不会进行跳转，实现性能的优化</p><p>同时我们也分析了采用这种 Conditional Branch 的技术局限性，具体适用于什么场景，当然这些是编译器设计需要考虑到的因素之一了</p><h2 id="07-x2F-02"><a href="#07-x2F-02" class="headerlink" title="07&#x2F;02"></a>07&#x2F;02</h2><h3 id="久违的基础课环节"><a href="#久违的基础课环节" class="headerlink" title="久违的基础课环节"></a>久违的基础课环节</h3><p>学习 CSAPP 的汇编</p><h2 id="07-x2F-03"><a href="#07-x2F-03" class="headerlink" title="07&#x2F;03"></a>07&#x2F;03</h2><h3 id="极速原型是个好东西"><a href="#极速原型是个好东西" class="headerlink" title="极速原型是个好东西"></a>极速原型是个好东西</h3><p>化身产品经理画项目原型图 XD</p><p>xiaopiu 这个原型图网站我也算是懂得了一些了，能够简单拖拉拽开发产品原型，并且进行简单逻辑跳转用于演示，不得不说确实方便</p><h2 id="07-x2F-04"><a href="#07-x2F-04" class="headerlink" title="07&#x2F;04"></a>07&#x2F;04</h2><h3 id="业务和技术都重要"><a href="#业务和技术都重要" class="headerlink" title="业务和技术都重要"></a>业务和技术都重要</h3><p>今天部门同事聚餐，聊了一会，感觉还是业务和技术都很重要</p><p>入职到现在对于中台项目的业务流程还是不太了解，当然更重要的业务还是金融方面的业务知识了，这些都是需要时间沉淀下来的</p><h3 id="台式机部署一下MySQL8"><a href="#台式机部署一下MySQL8" class="headerlink" title="台式机部署一下MySQL8"></a>台式机部署一下MySQL8</h3><p>回家刚好部署了一下 MySQL8 感觉还是踩了一点坑，这里记录一下</p><ul><li>去官网下载最新的开源社区版</li><li>之后解压，新增 <code>my.ini</code> 配置文件，同时配置 bin 目录为系统 path 环境变量</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><br><span class="hljs-comment"># 设置3306端口</span><br><br><span class="hljs-attr">port</span>=<span class="hljs-number">3306</span><br><br><span class="hljs-comment"># 设置mysql的安装目录</span><br><br><span class="hljs-attr">basedir</span>=D:\Coding\mysql-<span class="hljs-number">8.4</span>.<span class="hljs-number">1</span>-winx64<br><br><span class="hljs-comment"># 设置mysql数据库的数据的存放目录</span><br><br><span class="hljs-attr">datadir</span>=D:\Coding\mysql-<span class="hljs-number">8.4</span>.<span class="hljs-number">1</span>-winx64\data<br><br><span class="hljs-comment"># 允许最大连接数</span><br><br><span class="hljs-attr">max_connections</span>=<span class="hljs-number">200</span><br><br><span class="hljs-comment"># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span><br><br><span class="hljs-attr">max_connect_errors</span>=<span class="hljs-number">10</span><br><br><span class="hljs-comment"># 服务端使用的字符集默认为UTFMB4</span><br><br><span class="hljs-attr">character-set-server</span>=utf8mb4<br><br><span class="hljs-comment"># 创建新表时将使用的默认存储引擎</span><br><br><span class="hljs-attr">default-storage-engine</span>=INNODB<br><br><span class="hljs-comment"># 默认使用“mysql_native_password”插件认证，这里注释掉了，不注释掉会报错启动服务失败</span><br><br><span class="hljs-comment"># default_authentication_plugin=mysql_native_password</span><br><br><span class="hljs-section">[mysql]</span><br><br><span class="hljs-comment"># 设置mysql客户端默认字符集</span><br><br><span class="hljs-attr">default-character-set</span>=utf8mb4<br><br><span class="hljs-section">[client]</span><br><br><span class="hljs-comment"># 设置mysql客户端连接服务端时默认使用的端口</span><br><br><span class="hljs-attr">port</span>=<span class="hljs-number">3306</span><br><br><span class="hljs-attr">default-character-set</span>=utf8mb4<br></code></pre></td></tr></table></figure><ul><li><p>此时还没有 data 目录，问题不大，启动服务的时候会自动生成创建对应的目录，我们输入命令生成 root 的密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysqld --no-defaults --initialize --console<br></code></pre></td></tr></table></figure></li><li><p>之后会在控制台显示对应的密码</p></li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240704223854999.png"></p><ul><li>输入 <code>mysqld --install mysql</code> 安装服务</li><li>启动 mysql 服务 <code>net start mysql</code></li></ul><p>上面的配置文件中 <code>default_authentication_plugin=mysql_native_password</code> 之前没有注释掉，导致启动报错，找了好久也不知道为啥，后面通过 <code>mysqld --console</code> 输出启动日志，才发现是报错信息中提到了 <code>[ERROR] [MY-000067] [Server] unknown variable &#39;default_authentication_plugin=mysql_native_password&#39;.</code> 目前的 MySQL 版本无法读取这个配置，可能是已经过时，注释掉之后正常启动</p><ul><li>之后连接到本机的 MySQL 进程第一件事修改密码 <code>alter user &#39;root&#39;@localhost identified by &#39;1&#39;</code></li></ul><h2 id="07-x2F-05"><a href="#07-x2F-05" class="headerlink" title="07&#x2F;05"></a>07&#x2F;05</h2><p>还是在修改业务上的一些东西以及原型图的绘制</p><p>你问我回家干什么了，抱歉，今天是周末！</p><h2 id="07-x2F-08"><a href="#07-x2F-08" class="headerlink" title="07&#x2F;08"></a>07&#x2F;08</h2><h3 id="斗胆升级IDEA2024"><a href="#斗胆升级IDEA2024" class="headerlink" title="斗胆升级IDEA2024"></a>斗胆升级IDEA2024</h3><p>主要是想用新版的 JDK，但是之前一直用的是祖传的 2021 版本，最多只能支持到13还是多少，反正17之后就检测不到对应的新的 JDK 了，加上想试一试新的 UI 风格 (VSCODE)，直接痛定思痛，卸载旧版！</p><p>这里用的是脚本激活，一键自动配置激活补丁</p><p>首先去官网的 other version 部分下载 2024.1.3 的版本</p><p>之后一路安装，安装好了以后先启动</p><p>第一次启动比较慢，不是没启动，只是启动很慢，等第一次弹窗出现后，点击 quit 不进行激活</p><p>然后进入 进入 <code>/jetbra</code> 补丁目录，再点击进入 <code>/scripts</code> 文件夹，双击执行 <code>install-current-user.vbs</code> 脚本</p><p>等个半分钟，出现 done 了之后才算是完成</p><blockquote><p>脚本会自动在环境变量 -&gt; 用户变量下添加了 <code>IDEA_VM_OPTIONS</code> 变量，变量值为 <code>/jetbra</code> 文件夹下的 <code>.vmoptions</code> 参数文件绝对路径，然后，脚本自动在 <code>idea.vmoptions</code> 文件中引用了补丁</p></blockquote><p>之后输入指定的激活码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">6G5NXCPJZB-eyJsaWNlbnNlSWQiOiI2RzVOWENQSlpCIiwibGljZW5zZWVOYW1lIjoic2lnbnVwIHNjb290ZXIiLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJQU0kiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBEQiIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUEMiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQV1MiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFJCIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMjA5MDJQU0FOMDAwMDA1IiwiaGFzaCI6IlRSSUFMOi0xMDc4MzkwNTY4IiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-SnRVlQQR1/9nxZ2AXsQ0seYwU5OjaiUMXrnQIIdNRvykzqQ0Q+vjXlmO7iAUwhwlsyfoMrLuvmLYwoD7fV8Mpz9Gs2gsTR8DfSHuAdvZlFENlIuFoIqyO8BneM9paD0yLxiqxy/WWuOqW6c1v9ubbfdT6z9UnzSUjPKlsjXfq9J2gcDALrv9E0RPTOZqKfnsg7PF0wNQ0/d00dy1k3zI+zJyTRpDxkCaGgijlY/LZ/wqd/kRfcbQuRzdJ/JXa3nj26rACqykKXaBH5thuvkTyySOpZwZMJVJyW7B7ro/hkFCljZug3K+bTw5VwySzJtDcQ9tDYuu0zSAeXrcv2qrOg==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU/Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8/COMrxRlZW5mfzo0xsK0dQGNH3UoG/9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBABqRoNGxAQct9dQUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD<br></code></pre></td></tr></table></figure><h2 id="07-x2F-09"><a href="#07-x2F-09" class="headerlink" title="07&#x2F;09"></a>07&#x2F;09</h2><h3 id="CRUD-需求远没有那么简单"><a href="#CRUD-需求远没有那么简单" class="headerlink" title="CRUD 需求远没有那么简单"></a>CRUD 需求远没有那么简单</h3><p>今天主要还是分析项目的需求，感觉实际行动起来会比以前接触到的需求复杂不少，并不是简单的 CRUD，同时 CRUD 也远没有想象中的那么简单</p><p>能把 CRUD 写得好，也是一种本事</p><p><strong>一名合格的高级程序员必须要具备抽象应用需求场景，快速建立实现需求模型的能力</strong>，显然我现在还需要在实际的生产项目中进行锻炼</p><h2 id="07-x2F-10"><a href="#07-x2F-10" class="headerlink" title="07&#x2F;10"></a>07&#x2F;10</h2><h3 id="如何优雅的设计表"><a href="#如何优雅的设计表" class="headerlink" title="如何优雅的设计表"></a>如何优雅的设计表</h3><p>今天学习了如何优雅的设计目录树层级表</p><p><del>后续有时间的话可能</del>会整理成为一个专题文档<del>吧</del></p><h3 id="似乎需要补一下-SQL-基础了"><a href="#似乎需要补一下-SQL-基础了" class="headerlink" title="似乎需要补一下 SQL 基础了"></a>似乎需要补一下 SQL 基础了</h3><p>今天写需求，猛然发现自己 SQL 知识差不多忘得一干二净了</p><p>是时候拿起之前的笔记和文档课程，系统性地再过一遍 SQL 基础知识了，一些联表查询语句似乎还不是很熟练，框架封装了那么多，对于实际的开发，到底是好是坏？索引数据结构，现阶段而言真的没有必要了吗？需要带着问题重新学习</p><h3 id="通义灵码确实好用"><a href="#通义灵码确实好用" class="headerlink" title="通义灵码确实好用"></a>通义灵码确实好用</h3><p>今天正式在项目中引入了通义灵码插件，颇为震撼</p><p>除开代码段的分析，自动生成注释，内置 GPT 问答外，这哥们还会自动补全</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefined6830811a052522d871aaa02eccd6442b.png"></p><p>我就敲了一个枚举的签名，这哥们直接给我写完了，当然大部分的数据可能还是不需要采纳的</p><h2 id="07-x2F-11"><a href="#07-x2F-11" class="headerlink" title="07&#x2F;11"></a>07&#x2F;11</h2><h3 id="一份项目关联两个仓库实现远程开发"><a href="#一份项目关联两个仓库实现远程开发" class="headerlink" title="一份项目关联两个仓库实现远程开发"></a>一份项目关联两个仓库实现远程开发</h3><p>最近的需求就是有的时候回家还要看代码，但是懒得回家还背一个电脑</p><p>回家直接用台式进行开发，那么笔记本和台式之间项目的开发进度同步就成了一个问题</p><p>每次下班之前都进行提交到公有的仓库显然是不现实，我采取的方案是：</p><ul><li><p>在公司内网的 GitLab 中再创建一个私有的个人仓库，对应在本地拉一个新的个人开发分支用于存放每一次的琐碎提交记录</p></li><li><p>项目新增远程关联，个人开发分支每次都推到个人仓库，不污染公共仓库</p></li><li><p>开发完毕需要合并 Commit 的话直接一个 Rebase 就完事</p></li><li><p>至于个人私有仓库积累的琐碎记录，也是一个 push –force 就可以覆盖</p></li></ul><p>首先新建一个仓库</p><p>之后在本地仓库中新增 remote 关联</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote add private xxxx <span class="hljs-comment"># 新增名为 private 的远程关联，当然也可以直接在 IDEA 中点</span><br></code></pre></td></tr></table></figure><p>之后可以查看配置信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">remote.origin.url= 公有仓库.git<br>remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*<br>branch.master.remote=origin<br>branch.master.merge=refs/heads/master<br>remote.private.url= 私有仓库.git<br>remote.private.fetch=+refs/heads/*:refs/remotes/private/*<br>branch.private-master.remote=private<br>branch.private-master.merge=refs/heads/master<br></code></pre></td></tr></table></figure><p>推送项目到私有的远程仓库，注意是 private 不是 origin ，别推错了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git push private master<br></code></pre></td></tr></table></figure><p>我们在本地开发环境针对 private 远程关联的 master 新拉一个分支 private-master，以后所有的琐碎提交都在这里进行</p><p>切换到新的本地分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout private-master<br></code></pre></td></tr></table></figure><p>尝试 update 同步远程的更新，但是报错 <code>couldn&#39;t find remote ref refs/heads/private-master</code></p><p>这个主要是因为<del>我们针对 private 远程拉的分支名称是 private-master 默认在更新的时候会同步 private&#x2F;private-master，但是 private 远程实际上并不存在这个分支，因此就报错了</del>没有切换到对应的 private-master 分支导致的，在 master 分支下的状态进行操作，就会报错</p><p>我们可以修改本地分支名称来解决，但是已经有 master 分支名称了不能重复，因此可以直接修改引用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout private/master <span class="hljs-comment">#一定要先切换到对应 private 远程的分支，别改错了</span><br>git push -u private private-master:master <span class="hljs-comment"># 推送的时候同时修改上游追踪的映射关系</span><br></code></pre></td></tr></table></figure><p>看来 Git 还是需要不断练习，不管再多的命令学习都是纸上谈兵，实际需求一来才是锻炼</p><h3 id="生日加班"><a href="#生日加班" class="headerlink" title="生日加班"></a>生日加班</h3><p>今天是我的新历生日</p><p>想着回家可以放松一会奖励自己打回电动</p><p>结果下午群里就通知要开始固定加班了XD</p><p>第一天加班体验还算不错，感觉上算是有高中晚自习那味了</p><p>差不多七点开始干活，到了九点差不多也就走了，高中晚自习差不多也是这个时间</p><p>后续一段时间估计会很忙，希望自己能坚持住吧</p><h2 id="07-x2F-12"><a href="#07-x2F-12" class="headerlink" title="07&#x2F;12"></a>07&#x2F;12</h2><h3 id="动手才是王道"><a href="#动手才是王道" class="headerlink" title="动手才是王道"></a>动手才是王道</h3><p>今天是周五</p><p>但是没有了周五的味道</p><p>下周开始要开启地狱加班模式了</p><p>只能说明天还得继续写代码，想想怎么处理业务</p><p>今天尝试动手试了一下之前一直觉得很复杂的业务逻辑，没想到一次就成了，都没有报错</p><p>果然还是动手尝试比坐在那边空想有用</p><h3 id="AI生产内容还是不太可信"><a href="#AI生产内容还是不太可信" class="headerlink" title="AI生产内容还是不太可信"></a>AI生产内容还是不太可信</h3><p>我让AI生产一些客观层面上的知识，例如查询指定类型数据库中所有的数据库表&#x2F;schema的简单SQL，他还是每次给出了不一样的答案</p><h3 id="Database-amp-Schema的概念"><a href="#Database-amp-Schema的概念" class="headerlink" title="Database&amp;Schema的概念"></a>Database&amp;Schema的概念</h3><p>今天开发业务设计到数据库和Schema的概念</p><p>由于之前一直使用的都是 MySQL，所以一直接触的都是数据库的概念</p><p>直到业务上用到了 Oracle PostgrelSQL 等关系型数据库之后才发现，其实  Database 和 Schema 的概念还是有很大的不同的</p><p>在以 MySQL 为代表的部分关系型数据库中，没有特别区分  Schema 和 Database 的概念，因此在 MySQL 中 Schema &#x3D; Database</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> DATABASE TEST;<br><span class="hljs-keyword">CREATE</span> SCHEMA TEST;<br>#在 MySQL 中是等价语句<br></code></pre></td></tr></table></figure><p>但是在 Oracle 等数据库中，Schema 是表的集合，Database 是 Schema 的集合</p><h2 id="0713"><a href="#0713" class="headerlink" title="0713"></a>0713</h2><p>给自己放了一天假</p><p><del>实际上是自己摸了一天鱼</del></p><h2 id="0715"><a href="#0715" class="headerlink" title="0715"></a>0715</h2><h3 id="如何开发一个新的需求"><a href="#如何开发一个新的需求" class="headerlink" title="如何开发一个新的需求"></a>如何开发一个新的需求</h3><p>在开发一个需求之前，首先需要先确认需求具体是什么，有哪些</p><p>确认需求之后就是根据产品的需求 <strong>在脑海中构建一套完整的业务流程</strong></p><p>之后拆解每一块业务流程（于业务流程中涉及到的数据，考虑是否需要入库，如果需要入库就需要一套完整的 MVC 如果不需要入库，可能也需要内存对应的实体信息映射）想一想在这个流程中，需要用到那些 PO 实体？</p><p>确认了 PO 实体的大致方向，就可以进行字段的设计，字段的设计一般不太可能一蹴而就，需要反复的修改和更新，需要保持一定的耐心；同时字段设计的法则可以遵循以下的一些技巧：</p><ul><li>产品原型中数据相关的查询条件（往往就是要设计一个字段）</li><li>表单填写的选项卡，维度</li></ul><p>之后基于 PO 设计 MVC 三层代码，核心的实现和开发都是在 Service 层进行</p><h2 id="0716"><a href="#0716" class="headerlink" title="0716"></a>0716</h2><h3 id="才搞懂JDBC"><a href="#才搞懂JDBC" class="headerlink" title="才搞懂JDBC"></a>才搞懂JDBC</h3><p>最近业务上需求和 Metadata 相关，有一说一知道今天才算了解到了什么是 JDBC 相关的一些知识</p><p>之前只是浅浅了解了一下，后面也就直接用框架了，没有再手写原生的 JDBC Connection 这些，今天才发现有些时候一些定制的需求还是不能太依赖框架，手写原生的JDBC之后封装，在管理维护上可能更为高效</p><p>在 JDBC 提供的各个接口中，各大数据库驱动都需要针对这个接口进行实现，提供对应数据源的信息，接口也定义了很多获取元数据的规范，这才是真正的面向接口编程</p><p><a href="https://blog.csdn.net/m0_37761437/article/details/110468944">Java中JDBC的超详细总结</a></p><h3 id="使用Map进行字段的封装"><a href="#使用Map进行字段的封装" class="headerlink" title="使用Map进行字段的封装"></a>使用Map进行字段的封装</h3><p>我们在开发 Service 的时候往往会需要返回多个字段信息，这种场景一般我们可以封装为特定的实体类，当然也可以直接返回 Map&lt;String,String&gt; 的方式来处理，其中key是字段名，value是字段值，之后在上游通过 Jackson 等库来解析转换为实体类</p><p>虽然个人不是很爱用这样的方式，更多的时候还是返回实体字段信息，但是在实际项目中也还是会出现，积累一下</p><h2 id="0717"><a href="#0717" class="headerlink" title="0717"></a>0717</h2><p>唯一不用加班的一天，回家爽爽摸鱼了属于是</p><h2 id="0718"><a href="#0718" class="headerlink" title="0718"></a>0718</h2><h3 id="被接口文档单防"><a href="#被接口文档单防" class="headerlink" title="被接口文档单防"></a>被接口文档单防</h3><p>写 DTO 的时候一定要记得第一步就随手加上 <code>@Data</code> 注解提供 Get 方法</p><p>因为框架会调用对应的 get set 方法进行字段解析，如果没有 get set 方法，那么反映在接口文档中，就是<strong>显示不出正确的请求参数字段</strong></p><h2 id="0722"><a href="#0722" class="headerlink" title="0722"></a>0722</h2><h3 id="记得写-Transactional-注解"><a href="#记得写-Transactional-注解" class="headerlink" title="记得写 @Transactional 注解"></a>记得写 @Transactional 注解</h3><h2 id="0723"><a href="#0723" class="headerlink" title="0723"></a>0723</h2><h3 id="Docker部署MySQL8"><a href="#Docker部署MySQL8" class="headerlink" title="Docker部署MySQL8"></a>Docker部署MySQL8</h3><p>本地装过一个 5.5的，环境不是很干净，尝试直接二进制文件部署，但是由于卸载残留等一些历史原因，失败了，所以急了直接跑容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name mysql8 -e MYSQL_ROOT_PASSWORD=1 -e MYSQL_ALLOW_EMPTY_PASSWORD=false -e MYSQL_USER=test -e MYSQL_PASSWORD=1 -e MYSQL_DATABASE=test-db -v /挂载本地的数据目录:/var/lib/mysql -p 3306:3306 -d mysql:镜像tag<br></code></pre></td></tr></table></figure><p>使用这样的方式可以快速拉起一个干净的 MySQL 同时映射到宿主主机和应用进行连接</p><h3 id="Docker部署Redis单点-SpringBoot最佳实践"><a href="#Docker部署Redis单点-SpringBoot最佳实践" class="headerlink" title="Docker部署Redis单点+SpringBoot最佳实践"></a>Docker部署Redis单点+SpringBoot最佳实践</h3><p>项目需要用到 Redis 来做数据缓存，减少 DB 频繁的读取压力</p><p>直接和 MySQL 一样本地拉一个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name ficp_redis -v c:/Users/28459/Desktop/PDS/redis_docker_data:/data -p 6379:6379 -d redis:latest<br></code></pre></td></tr></table></figure><p>之后通过 Another Redis Desktop Manager 客户端可以直接连接</p><ul><li><input disabled="" type="checkbox"> SpringBoot 整合 Redis 开发应用的最佳实践</li></ul><h3 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h3><p>回顾一下之前学习的 SQL 注入问题，其原理就是将 SQL 的查询条件参数以接口的方式暴露给客户端，由客户端程序进行编写之后在服务端进行 SQL 的拼接，可能会出现脏 SQL 的现象，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> xxx;<br></code></pre></td></tr></table></figure><p>这里的 xxx 我们交给用户进行填写，以前端参数传递</p><p>但是这只是一种理想的状态，保证了用户一定会传递合法的参数，但是如果用户传递的参数是 <strong>xxx and 1 &#x3D; 1</strong> 最终执行的 SQL 就会是如下的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> xxx <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>目前各大框架也都针对 SQL 注入进行了处理，例如经典的 JDBC 就提供了  PreparedStatement 接口来实现 SQL 注入的预防</p><ul><li><input disabled="" type="checkbox"> SQL注入的其他举例？</li><li><input disabled="" type="checkbox"> PreparedStatement 如何预防SQL注入？</li></ul><h3 id="SpringBean-注入方式"><a href="#SpringBean-注入方式" class="headerlink" title="SpringBean 注入方式"></a>SpringBean 注入方式</h3><p>今天写代码的时候，由于需要注入 Redis 的客户端实例 RedisTemplate </p><p>然后项目之前已经有了一个 Bean 的注入，一时之间没有发现这是 Bean 的注入方式，只能说 @AutoWired 和 CRUD 注解类害人不浅</p><ul><li>构造器注入</li><li>@Bean 方法名注入 bean 对象</li></ul><h2 id="0724"><a href="#0724" class="headerlink" title="0724"></a>0724</h2><h3 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h3><h2 id="0725"><a href="#0725" class="headerlink" title="0725"></a>0725</h2><h3 id="QueryDSL-SpringDataJPA-动态参数传递-模糊查询"><a href="#QueryDSL-SpringDataJPA-动态参数传递-模糊查询" class="headerlink" title="QueryDSL+SpringDataJPA 动态参数传递+模糊查询"></a>QueryDSL+SpringDataJPA 动态参数传递+模糊查询</h3><p>今天有个需求是前端动态传递参数并且后端进行模糊查询</p><p>这给我搞蒙了，本身对 JPA 就不是很熟悉，模糊查询确实直接在 Repository 中用 Like 关键字定义方法名称就能实现全自动查询</p><p>但是动态参数传递确实是第一次在 JPA 遇到，以前都从来没用过，整理了一下内容：</p><p>首先是在 Repository 位置继承 QuerydslPredicateExecutor 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MetadataRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;MetadataPO, Long&gt;,QuerydslPredicateExecutor&lt;MetadataPO&gt;&#123;&#125;<br></code></pre></td></tr></table></figure><p>之后在上游的 Service 方法中，对参数存在与否进行判断拼接，之后将拼接的对象转换为 Predicate 类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Page&lt;MetadataPO&gt; <span class="hljs-title function_">queryPageByDatabaseAndTableNameAndGroupId</span><span class="hljs-params">(String databaseName, String tableName, Long groupId, Pageable pageable)</span> &#123;<br><span class="hljs-type">QMetadataPO</span> <span class="hljs-variable">po</span> <span class="hljs-operator">=</span> QMetadataPO.metadataPO;<br><span class="hljs-type">BooleanBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BooleanBuilder</span>();<br><span class="hljs-keyword">if</span> (tableName != <span class="hljs-literal">null</span> &amp;&amp; !tableName.isEmpty())&#123;<br><span class="hljs-comment">//对模糊查询的表名下划线进行转义</span><br><span class="hljs-keyword">if</span> (tableName.contains(<span class="hljs-string">&quot;_&quot;</span>))&#123;<br>tableName = tableName.replaceAll(<span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-string">&quot;\\_&quot;</span>);<br>&#125;<br>builder.and(po.tableName.like(<span class="hljs-string">&quot;%&quot;</span> + tableName + <span class="hljs-string">&quot;%&quot;</span>));<br>&#125;<br><span class="hljs-keyword">if</span> (databaseName != <span class="hljs-literal">null</span> &amp;&amp; !databaseName.isEmpty())&#123;<br>builder.and(po.databaseName.eq(databaseName));<br>&#125;<br><span class="hljs-keyword">if</span> (groupId != <span class="hljs-literal">null</span>)&#123;<br>builder.and(po.groupIds.contains(groupId));<br>&#125;<br>       <span class="hljs-comment">//这里会直接调用传递 Predicate 参数</span><br><span class="hljs-keyword">return</span> metadataRepository.findAll(builder, pageable);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="软件工程专业的怎么能不学电工知识呢"><a href="#软件工程专业的怎么能不学电工知识呢" class="headerlink" title="软件工程专业的怎么能不学电工知识呢"></a>软件工程专业的怎么能不学电工知识呢</h3><p>心血来潮想把焊接知识学习一下</p><p>一直想自己动手把 x360 做一个 RHG3.0 的 mod ，但是苦于不会焊接一直没办法做</p><p>同时 Switch 的 modchip 也已经比较成熟，生态和价格都已经相对友好</p><p><a href="https://www.bilibili.com/video/BV1qr4y1J7bW">整合抽取了油管的 Soldering Tutorial 精华部分切片</a></p><p>后续可以考虑出一个文章记录</p>]]></content>
    
    
    <categories>
      
      <category>杂谈&amp;人生哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU 15-213|Machine Level Programming-Control</title>
    <link href="/2024/06/23/CMU-15-213-Machine-Level-Programming-Control/"/>
    <url>/2024/06/23/CMU-15-213-Machine-Level-Programming-Control/</url>
    
    <content type="html"><![CDATA[<h1 id="Condition-Codes"><a href="#Condition-Codes" class="headerlink" title="Condition Codes"></a>Condition Codes</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>处理器有处理状态的标识符，在我们现在的处理器架构中就<strong>用这个状态信息来控制程序的运行，实现流程控制</strong></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefined14611621119083.jpg"></p><p>状态码主要有四种，他们是实现程序运行或者流程控制最基本的条件，换句话说现在流程控制的执行本质上就是依据 <code>condition codes</code> 来进行的</p><p>我们需要注意的是这些寄存器：</p><ul><li>临时数据主要放在 rax 中</li><li>运行时栈的地址存储在 rsp 中</li><li>代码的控制点程序计数器PC的数据存储在 rip 中</li><li>目前测试的指令最终设置的条件存放在 CF,ZF,SF,OF 中</li></ul><h2 id="基本状态码"><a href="#基本状态码" class="headerlink" title="基本状态码"></a>基本状态码</h2><ul><li>CF Carry Flag,操作结果进位时会设置他为 1,<strong>对应无符号运算的数据溢出</strong></li><li>SF Sign Flag,操作结果为负数时会设置他为 1,对应<strong>二进制数据的负数</strong></li><li>ZF Zero Flag,<strong>操作的结果为 0 值</strong>的时候设置他为 1</li><li>OF Overflow Flag,操作结果溢出时会设置他为 1,<strong>对应有符号运算的数据溢出，例如两个正数相加得到负数，两个负数相加得到正数等</strong></li></ul><p>上面的四个基本状态码名称是<strong>在执行对应机器指令之后</strong>由处理器进行设置的，例如 <code>addq</code> </p><p>比如我们有一条类似于 <code>t = a + b</code> 的语句，在执行这个语句对应的汇编语句假设是 <code>addq src dest</code> </p><ul><li>如果 a b 都是无符号，然后超出位数了溢出了，这个时候就会自动设置CPU的 CF位 &#x3D; 1</li><li>如果 a b 都是有符号数，当 <code>a &lt; 0 &amp; b &lt; 0 &amp; t &gt; 0</code> 或者是 <code>a &gt; 0 &amp; b &gt; 0 &amp; t &lt; 0</code> 的时候，就会设置CPU的 OF位 &#x3D; 1</li></ul><p>对于大多数的指令而言，执行操作的时候都会自动设置这四个 Condition Code，我们称这种设置 Condition Code 的方式为隐式设置</p><p>但是需要注意的是 <code>leaq</code> 这个指令不会设置状态码</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>除了隐式设置 Condition Code 之外，我们还可以显式设置，主要有两个指令：</p><ul><li>cmp — compare 比较多个参数数据的值</li><li>test — 用于测试相同参数</li></ul><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmpq b,a # 等价于 a-b (注意顺序)<br></code></pre></td></tr></table></figure><p>相比于 <code>add</code> ,<code>sub</code> 这些会进行数据 <code>set destination</code> 的指令，<strong>cmp</strong> 只会进行比较，设置状态码，而不会 <code>set destination</code>.</p><blockquote><p>什么是 set destination?</p></blockquote><p>PPT 中很形象的进行了描述，对于汇编指令 <code>add b, a</code> 其语义可以简单理解为我们高级编程语言中的 <code>a += b</code> 也就是 <code>a = a + b</code>，这里进行了数据的赋值，对应处理器的 <code>set destination</code> 这个操作。</p><blockquote><p>补充</p></blockquote><p>教授提出了在 x86 系统中有两种不同的汇编语法顺序标准：</p><ul><li>intel &#x2F; Microsoft 在使用的，我们不用</li><li>Linux 采用的，我们用这个</li></ul><p>Linux 采用的标准是反过来的，正如上面的汇编代码，因此我们在心里需要特别关注计算转换一下。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221201175100064.png" alt="上面的代码状态位设置的情况"></p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">testq b,a # 等价于 a&amp;b (注意顺序)<br></code></pre></td></tr></table></figure><p>和 cmp 一样，同样也是设置状态码但是不会设置任何的 <code>destination</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">testq %rax,%rax<br></code></pre></td></tr></table></figure><p>一般我们是用<strong>两个相同的参数</strong>进行测试。</p><h2 id="SetX-Instructions"><a href="#SetX-Instructions" class="headerlink" title="SetX Instructions"></a>SetX Instructions</h2><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><p>上面其实都是在说状态码是如何得到的，那么状态码到底有什么用处呢？</p><p>教授介绍了一个 Set 指令，其作用在于 <strong>基于读取各种状态码的排列组合</strong> 来设置某个寄存器最低一位的  Byte 全为 0&#x2F;1(也就是在 64 位的系统中前面七个字节都不进行修改）。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204150841948.png" alt="助记表格"></p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>那么 <code>set</code> 指令到底有什么用处，或者说 <strong>状态码</strong> 的存在到底有什么意义，我们可以看如下的 c 代码和汇编代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gt</span> <span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span><br>&#123;<br>     <span class="hljs-keyword">return</span> x &gt; y;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们假设编译器根据寄存器分配算法得到的各个变量以及对应寄存器如下：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204151144563.png" alt="程序变量以及对应寄存器"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmpq %rsi, %rdi ; 比较 x:y 同时会设置状态码 这里等价于 x-y<br>setg %al ; 根据状态码，这里是当 x &gt; y 的时候设置 al 寄存器的最低一个字节全为1<br>movzbl %al, %eax ;由于 %al 引用的是 rax 寄存器最低一个字节的数据，我们需要设置其他七位高位字节都为0<br>ret ;返回到调用这段代码的地方<br></code></pre></td></tr></table></figure><p>对于 <code>movzbl %al, %eax</code> 这一段，教授进行了追加解释，<code>%eax</code> 引用的其实是 <code>rax</code> 寄存器的<strong>后 32 位</strong>也就是最后四个字节的数据，那么为什么说是设置其他七个字节都为 0 了呢(如何保证高位的 32 位呢)，这主要与我们 x86-64 <strong>设计规则</strong>有关，当指令操作的结果是 32 位数据的时候，会自动填充高位 32 位为0</p><h1 id="Conditional-Branch"><a href="#Conditional-Branch" class="headerlink" title="Conditional Branch"></a>Conditional Branch</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>上面一个部分通过介绍了状态码，以及如何基于状态码来设置寄存器的某一位结果，解读和实现汇编层面的<strong>比较</strong> <strong>comparsion</strong> <strong>操作</strong></p><p>但是其实更多的时候我们想要的是实现复杂的条件逻辑，那么这在最底层设计也和状态码有关系。</p><h2 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h2><h3 id="基本指令-1"><a href="#基本指令-1" class="headerlink" title="基本指令"></a>基本指令</h3><p>jmp 指令是实现条件逻辑的最简单最朴素的一种汇编处理方式。</p><p>和 <code>setX</code> 一样, <code>jmp</code> 也是<strong>基于不同状态码的排列组合</strong>来实现程序不同代码段的跳转逻辑。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204152321132.png" alt="jx助记表格"></p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">absdiff</span> <span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span><br>&#123;<br>     <span class="hljs-type">long</span> result;<br>     <span class="hljs-keyword">if</span> (x &gt; y)<br>     result = x-y;<br>     <span class="hljs-keyword">else</span><br>     result = y-x;<br>     <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设编译器通过寄存器分配算法得到了如下的表格</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204152550381.png" alt="程序变量和对应寄存器"></p><p>我们可以得到如下的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">absdiff:<br>cmpq %rsi, %rdi ; 首先进行比较，x-y 设置对应的状态码<br>     jle .L4  ;如果是小于等于，就跳转到 L4 标签下<br>     movq %rdi, %rax ;如果不是小于等于，说明 x 更大，先把 x 放到 rax 中准备返回<br>     subq %rsi, %rax ;x -= y<br>     ret<br>.L4: ;x &lt;= y<br>     movq %rsi, %rax ;说明 y 更大，先把 y 放到 rax 中准备返回<br>     subq %rdi, %rax ;y -= x<br>     ret<br></code></pre></td></tr></table></figure><h2 id="goto-expression-in-C"><a href="#goto-expression-in-C" class="headerlink" title="goto expression in C"></a>goto expression in C</h2><p>这部分主要介绍 <strong>c 中不怎么常用，但是有助于我们理解汇编代码逻辑顺序</strong>的一个特性：go to 表达式</p><p>我们把 c 代码用 goto 语句重写一遍就更好看懂了，实际上 goto 语句的作用也就是更加贴近低级编程语言</p><p>对于上述的求两数之差绝对值的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">absdiff</span> <span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span><br>&#123;<br>     <span class="hljs-type">long</span> result;<br>     <span class="hljs-keyword">if</span> (x &gt; y)<br>     result = x-y;<br>     <span class="hljs-keyword">else</span><br>     result = y-x;<br>     <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果用 <code>goto</code> 表达式改写，可以得到如下的结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">absdiff_j</span> <span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span><br>&#123;<br>     <span class="hljs-type">long</span> result;<br>     <span class="hljs-type">int</span> ntest = x &lt;= y;<br>     <span class="hljs-keyword">if</span> (ntest) <span class="hljs-keyword">goto</span> Else;<br>     result = x-y;<br>     <span class="hljs-keyword">goto</span> Done;<br>  Else:<br>     result = y-x;<br>  Done:<br>     <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 <code>goto Else</code> 其实就有点类似我们之前的 <code>jle</code></p><h2 id="Conditional-Move-amp-初探编译器流水线和分支预测机制"><a href="#Conditional-Move-amp-初探编译器流水线和分支预测机制" class="headerlink" title="Conditional Move &amp; 初探编译器流水线和分支预测机制"></a>Conditional Move &amp; 初探编译器流水线和分支预测机制</h2><h3 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h3><p>Conditional Move 不同于传统的 <code>jmp</code> 指令，他的核心思想在于 <strong>做所有的事情，直到最后才进行选择</strong></p><p>对应分支预测也就是把所有可能的情况全部枚举出来，在最后才进行选择</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204165033334.png" alt="用 goto 表达式来描述 conditional move 的核心逻辑"></p><blockquote><p>？为什么这么做</p></blockquote><p>教授进行了解释，实际上汇编出来的代码，并不是上述这样的，会采用另一种方法来加速分支语句的执行。因为这和编译器的分支预测有关系，关联 CPU 的流水线 (pipeline)机制</p><p>我们知道现在的 CPU 都是依靠流水线工作的，比方说执行一系列操作需要 ABCDE 五个步骤，那么在执行 A 的时候，实际上<strong>执行 B 所需的数据会在执行 A 的同时加载到寄存器中</strong>，这样运算器执行外 A，就可以立刻执行 B 而无须等待数据载入。</p><p>如果程序一直是顺序的，那么这个过程就可以一直进行下去，效率会很高。</p><p>但是一旦遇到分支，例如我们上面的例子，可能会出现 x 和 y 的值进入另一条分支的情况。那么就会导致执行完 A 下一步要执行的是 C。<strong>但是由于流水线机制的作用，此时寄存器中载入的数据是 B，这时候就要把流水线清空（因为后面载入的东西都错了），然后重新载入 C 所需要的数据，这就带来了很大的性能影响。</strong></p><p>为此人们常常用『分支预测』这一技术来解决（分支预测是编译器的另一个话题这里不展开），但是对于这类只需要判断一次的条件语句来说，其实有更好的方法，这就是教授说的 Conditional Move 方式</p><p>处理器有一条指令支持 <code>if(Test) Dest &lt;- Src</code> 的操作，也就是说可以<strong>不用跳转，利用条件代码来进行赋值</strong>，于是编译器在可能的时候会把上面的 goto 程序改成如下：也就是上图所描述的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">result = Then_Expr;<br>eval = Else_Expr;<br>nt = !Test;<br>if (nt) result = eval;<br>return result;<br></code></pre></td></tr></table></figure><p>具体的做法是：<strong>反正一共就两个分支，我都算出行不行</strong>，然后利用上面的条件指令来进行赋值，这样就完美避免了因为分支可能带来的性能问题（需要清空流水线）</p><p>像下面这样，同样 %rdi 中保存了参数 x，%rsi 中保存了参数 y，而 %rax 一般用来存储返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">absdiff:<br>     movq %rdi, %rax ; x<br>     subq %rsi, %rax ; 先求出 if 的 test 成功的情况: result = x-y<br>     movq %rsi, %rdx<br>     subq %rdi, %rdx ; 再求出 if 的 test 失败也就是 else 对应的情况: eval = y-x<br>     cmpq %rsi, %rdi ; 进行 test 对应的判断 x:y<br>     cmovle %rdx, %rax ; 如果是 else 的情况也就是x&lt;=y,就把之前计算好的情况直接移动到最终结果的寄存器中(result = eval)<br>     ret<br></code></pre></td></tr></table></figure><h3 id="正反面分析"><a href="#正反面分析" class="headerlink" title="正反面分析"></a>正反面分析</h3><p>当然 conditional move 也存在一些极端的效率低的情况，可以想象如果 <code>test</code> 和 <code>!test</code> 对应的情况都是很复杂的运算，或者是 <code>test</code> &#x2F; <code>!test</code> 容易出错，那么 conditional move 就不是编译器最佳的选择</p><p>此外设计指针操作的时候，由于两个分支都会被计算，因此会出现不期望的结果</p><p>最后一种就是如果分支中的计算是有副作用的，例如 <code>val = x &gt; 0 ? x*= 7 : x+= 3;</code>，这种情况下，因为都计算了同时都修改了 x 的值，那么最终这条语句执行完的 x 的值就不会再是我们期望的哪一个值了</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204165612878.png" alt="Conditional Move 的副作用"></p><h1 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h1><h2 id="如何理解Loops"><a href="#如何理解Loops" class="headerlink" title="如何理解Loops"></a>如何理解Loops</h2><p>Loops 本质上其实是 Conditional Branch 跳转的具体一个变体，本质上其实还是 <code>jx</code> 这些指令实现的。</p><h3 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h3><p>比如课件中一段经典的 <code>popcount</code> 代码，用于计算无符号整数中有多少位数据是1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">pcount_do</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x)</span> &#123;<br>     <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">do</span> &#123;<br>     result += x &amp; <span class="hljs-number">0x1</span>;<br>     x &gt;&gt;= <span class="hljs-number">1</span>;<br>     &#125; <span class="hljs-keyword">while</span> (x);<br>     <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其对应的 goto 表达式如下:(便于理解汇编代码，其实 goto 表达式下的和最终的汇编代码框架上大差不差了)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">pcount_goto</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x)</span> &#123;<br>     <span class="hljs-type">long</span> result = <span class="hljs-number">0</span>;<br>     loop:<br>          result += x &amp; <span class="hljs-number">0x1</span>;<br>          x &gt;&gt;= <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span>(x) <span class="hljs-keyword">goto</span> loop;<br>          <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movl $0, %eax ; result = 0<br>.L2:     ; loop:<br>     movq %rdi, %rdx ;rdi 存储的是x<br>     andl $1, %edx ; t = x &amp; 0x1<br>     addq %rdx, %rax ; result += t<br>     shrq %rdi     ; x &gt;&gt;= 1<br>     jne .L2       ; if (x) goto loop<br>     rep; ret<br></code></pre></td></tr></table></figure><p>所以我们可以得出如下的结论，针对 do while 语句，对应的汇编格式应该如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span>&#123;<br>     statement1;<br>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">case</span>);<br><span class="hljs-comment">//等价于</span><br>loop:<br>statement1;<br>     <span class="hljs-keyword">if</span>(<span class="hljs-keyword">case</span>)<br>          <span class="hljs-keyword">goto</span> loop;<br></code></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>针对 while 语句的转换，会直接进入到中间的 test 部分，如果不满足 tast case 就会直接顺序执行到 done 这一部分跳出循环，实际上一次也没有执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">case</span>)<br>     statement1;<br><span class="hljs-comment">//等价于</span><br>loop:<br>statement1;<br>test:<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">case</span>)<br>          <span class="hljs-keyword">goto</span> loop;<br>done:<br></code></pre></td></tr></table></figure><h3 id="GCC的-O1-优化"><a href="#GCC的-O1-优化" class="headerlink" title="GCC的 O1 优化"></a>GCC的 O1 优化</h3><p>值得一提的是，如果我们开启了编译器的 <code>-O1</code> 参数优化，那么编译器首先会将 while 语句翻译成 do while 语句，然后转换为对应的 goto 版本语句，最终 while 的汇编代码实际上就和 do while 的 goto 语句差不多了</p><blockquote><p>灵魂三问：</p><ul><li>什么是 O1 优化？</li><li>为什么需要 O1 优化，不这么优化可以吗？</li><li>还有没有更好的优化方式来实现等价或者类似的操作？</li></ul></blockquote><ul><li>什么是O1优化</li></ul><p>O1优化是 GCC 提供的多级优化方式中比较基础的一级优化方式。优化的内容主要侧重在流程控制，简化控制流，减少冗余代码等。</p><ul><li>为什么需要，不这么优化可以吗</li></ul><p>编译器的优化会改变代码的结构，默认情况下编译器是不会开启优化的，源代码是什么样，对应生成的汇编代码结构就是什么样。而开启优化后虽然不便于调试，但是性能方面提升了很多，优化级别越高性能的提升越大，在一些对性能要求严格的场景，例如实时嵌入式系统，大数据系统中，对于编译器的优化是十分需要的。</p><ul><li>还有没有更好的</li></ul><p>编译器优化等级还有更高的，代表更高的优化策略</p><p>此外还有**链接时优化 (LTO)<strong>，</strong>Profile-Guided Optimization (PGO)**等方式</p><h1 id="Switch-Statements"><a href="#Switch-Statements" class="headerlink" title="Switch Statements"></a>Switch Statements</h1><p>CPU 分支预测压力最大的一集</p><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p>需要关注的是我们 c 中的 switch 语句主要有三大特性</p><ul><li>可以存在多个标签匹配同一个 case 的情况(对应5&amp;6)</li><li>可以存在没有 break 进行 fallthrough 的情况(对应2)</li><li>可以存在缺少 case 的情况(对应4)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">switch_eg</span> <span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y, <span class="hljs-type">long</span> z)</span><br>&#123;<br>     <span class="hljs-type">long</span> w = <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">switch</span>(x) &#123;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>     w = y*z;<br>     <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>     w = y/z;<br>     <span class="hljs-comment">/* Fall Through */</span><br>     <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>     w += z;<br>     <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>     w -= z;<br>     <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">default</span>:<br>     w = <span class="hljs-number">2</span>;<br>     &#125;<br>     <span class="hljs-keyword">return</span> w;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="跳转表"><a href="#跳转表" class="headerlink" title="跳转表"></a>跳转表</h2><p>由于 switch case 的语句一次判断可能会有多种可能的路径，这个时候 CPU 的分支预测压力就会很大，为了解决这一个问题， switch 在底层实现采用了一个很重要的数据结构 <code>jump table</code></p><blockquote><p>插一嘴：我们可以发现在计算机体系结构中，采用表来进行解决问题的方式很常见，例如分页表，回表，虚函数，甚至是算法中的 DP 这些都用到了表来实现</p></blockquote><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204221334833.png" alt="switch底层的跳转表"></p><p>跳转表由编译器生成，汇编器进行填充，其中对于程序语句的 case 编号进行标号(比如图中的0 ~ n-1)，我们根据这个编号可以构建出跳转表(上图的紫色部分)。</p><p>其实这个数据结构就是<strong>数组的基本实现</strong>，之所以这么做就是为了可以根据数组的随机访问特性 (Array Indexing) 通过 <strong>jump table</strong> 以 O(1) 的时间复杂度来快速定位具体的代码 block 数据段。</p><h2 id="switch-case-的汇编"><a href="#switch-case-的汇编" class="headerlink" title="switch case 的汇编"></a>switch case 的汇编</h2><p>我们可以看到课件中针对 switch 这段语句的整体框架生成的汇编代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">switch_eg</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y, <span class="hljs-type">long</span> z)</span><br>&#123;<br>     <span class="hljs-type">long</span> w = <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">switch</span>(x) &#123;<br>          . . .<br>     &#125;<br>     <span class="hljs-keyword">return</span> w;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">switch_eg:<br>     movq %rdx, %rcx # rdx=1 rcx=w<br>     cmpq $6, %rdi # x:6<br>     ja .L8<br>     jmp *.L4(,%rdi,8) #goto *JTab[x]<br></code></pre></td></tr></table></figure><p>跳转表为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.section    .rodata<br>    .align 8<br>.L4:<br>    .quad   .L8 # x = 0<br>    .quad   .L3 # x = 1<br>    .quad   .L5 # x = 2<br>    .quad   .L9 # x = 3<br>    .quad   .L8 # x = 4<br>    .quad   .L7 # x = 5<br>    .quad   .L7 # x = 6<br></code></pre></td></tr></table></figure><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204222647217.png" alt="程序变量和对应寄存器"></p><p>之所以会将进行 case 比较的 x 和 6 进行比较是因为<strong>编译器在扫描了整段程序后，发现其实 case 的具体值的范围就落在 1~6 区间之间</strong>，因此此时会进行比较，通过比较来设置状态码。</p><p>但是这里的 <code>ja</code> 指令用的十分有说法， <code>ja</code> 是指 <code>jump above</code> ，和 <code>jump greater</code> 相比， ja 还考虑到了<strong>有符号负数</strong>的情况，如果 x 是一个负数的时候，通过 ja 进行比较，实际上比较的是 x 以无符号数形式来和 6 进行比较的，比较得到的结果其实是大于 6 的，直接跳到 default 的部分，而如果是 <code>jg</code> 则负数 x 是小于 6 的，那么还会进入 swich 体中错误的部分</p><p>因此课件中问的这个</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204223401279.png"></p><p>其实表示的范围就是 <code>(-∞,1]U(6.+∞]</code> ,可以说这个指令用的非常的巧妙，很严谨</p><h2 id="间接跳转"><a href="#间接跳转" class="headerlink" title="间接跳转"></a>间接跳转</h2><p>我们观察之前生成的汇编代码就可以发现，有一个带 <code>*</code> 的 jmp 指令，这就是间接跳转 <strong>indirect jump</strong>.</p><p>这里的意思其实就是通过间接跳转来以 O(1) 的时间复杂度根据 jump table 索引到具体的 case 段中。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204223818835.png" alt="直接跳转和间接跳转"></p><p>直接跳转 <code>jmp .L8</code>，就直接跳到 <code>.L8</code> 所在的标签，也就是 x &#x3D; 0</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204223846327.png" alt="具体 jump table 在程序中对应的 case "></p><p><code>jmp *.L4(,%rdi,8)</code> 那么就先找到 <code>.L4</code> 然后往后找 8 个字节（或 8 的倍数），于是就是 0~6 的范围</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>下面我们来分段进行分析，还记得我们之前说的 switch 语句的三个特性吗，其实一开始的 demo 就很好地包含了这三个特性，看下生成的汇编代码到底是如何处理的。</p><p>最简单的无特性block：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204224031508.png" alt="最简单的无特性block"></p><p>下面是编译器 gcc 进行特殊处理的逻辑图</p><h3 id="Fallthrough"><a href="#Fallthrough" class="headerlink" title="Fallthrough"></a>Fallthrough</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204224215904.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204224325557.png" alt="不写break的 fallthrough 情况"></p><h3 id="多Case组合"><a href="#多Case组合" class="headerlink" title="多Case组合"></a>多Case组合</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221204224844904.png" alt="多个 case 合在一起的情况"></p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU 15-213|Machine Level Programming-Basic</title>
    <link href="/2024/06/17/CMU-15-213-Machine-Level-Programming-Basic/"/>
    <url>/2024/06/17/CMU-15-213-Machine-Level-Programming-Basic/</url>
    
    <content type="html"><![CDATA[<h1 id="History"><a href="#History" class="headerlink" title="History"></a>History</h1><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>首先我们需要有一个基本的概念。</p><p>程序运行的本质其实是<strong>机器响应程序</strong>而<strong>执行的一个个指令</strong></p><p>主要可以分为这几种代码，我们需要有基本的概念</p><ul><li>源代码(Source code)：这个是我们用编程语言编写的<strong>程序源代码</strong></li><li>汇编代码(Assembly code)：编程语言的后端编译器Compiler会生成汇编代码。</li><li>目标代码(Object code)：二进制机器码</li></ul><h2 id="Intel-x86-Evolution"><a href="#Intel-x86-Evolution" class="headerlink" title="Intel x86 Evolution"></a>Intel x86 Evolution</h2><h3 id="CISC的由来"><a href="#CISC的由来" class="headerlink" title="CISC的由来"></a>CISC的由来</h3><p>以英特尔处理器为代表的计算机，是CISC(Complex Instruction set computer)。</p><p>与之对应的其实还有RISC(Reduce Instrction set computer)。</p><p>(其实一开始是没有CISC的，只是有了RISC之后，要贬低一下对方，才有了CISC XD)</p><h3 id="为什么叫X86"><a href="#为什么叫X86" class="headerlink" title="为什么叫X86"></a>为什么叫X86</h3><p>关于处理器发展的历史，之所以习惯性的叫X86，其实也是历史遗留问题，因为最早的一代处理器是8086，后续处理器编号结尾都以86结尾，因此就叫做X86处理器。</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221020212529638.png" style="zoom:67%;" /><h3 id="分水岭"><a href="#分水岭" class="headerlink" title="分水岭"></a>分水岭</h3><p>很关键的一处是在于2004年，Pentium 4E的型号，<strong>受限于处理器的功耗</strong>，Intel在2004起的处理器，<strong>不再增加时钟Clock的转速</strong>，因为发热量压不住，而是进行多核CPU的处理。</p><h3 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h3><p>CPU的指令很多，并且<strong>不同的CPU型号支持的指令不尽相同（每一代CPU都会有新的指令支持），而指令本身会影响程序的执行</strong>，只需要记住这一点即可。</p><h1 id="C-Assembly-amp-Machine-Code"><a href="#C-Assembly-amp-Machine-Code" class="headerlink" title="C Assembly &amp; Machine Code"></a>C Assembly &amp; Machine Code</h1><h2 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h2><p>Instruction Set Architecture</p><p>简单来说就是在处理器设计中<strong>需要理解或编写汇编&#x2F;机器代码的部分</strong>。</p><p>常见的ISA：</p><ul><li>Intel家的：x86, IA32, Itanium，X86-64</li><li>ARM架构（手机，MAC）</li></ul><h2 id="CPU-Memory-Architecture-Overview"><a href="#CPU-Memory-Architecture-Overview" class="headerlink" title="CPU-Memory Architecture Overview"></a>CPU-Memory Architecture Overview</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221020213553244.png" alt="image-20221020213553244"></p><p>图中出现的都很重要</p><p>CPU</p><ul><li>PC：Program Counter 程序计数器————用于指令寻址，CPU的操作可以概括为取址执行</li><li>Registers：寄存器————用于存储需要使用的数据，一般我们<strong>以名称来进行助记。</strong></li><li>状态码：最近一些程序指令的结果，常用于进行条件转移，实现代码分支</li></ul><p>Memory</p><ul><li>可以看作是一个很大的字节数组。</li><li>操作系统实现的这个<strong>虚拟内存</strong>，这使得每个程序<strong>看起来</strong>似乎是有自己的一块独立内存用于程序访，可以实现每个程序共享同一块物理内存。</li><li>CPU高速缓存？</li></ul><h2 id="Practice-c-code-to-object-code"><a href="#Practice-c-code-to-object-code" class="headerlink" title="Practice: c code to object code"></a>Practice: c code to object code</h2><p>这部分主要是熟悉一下gcc编译器的使用。</p><p>在正式的实践之前我们可以先看一下具体的代码，这个代码很典型，是最基础的求和并且存储到具体的一个值的案例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">long</span> <span class="hljs-title function_">plus</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span><br>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sumstore</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y, <span class="hljs-type">long</span> *dest)</span><br>&#123;<br>  <span class="hljs-type">long</span> t = plus(x, y);<br>  *dest = t;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-type">long</span> x = atoi(argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-type">long</span> y = atoi(argv[<span class="hljs-number">2</span>]);<br>  <span class="hljs-type">long</span> z;<br>  <span class="hljs-comment">//sumstore求和并且存值</span><br>  sumstore(x, y, &amp;z);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld + %ld --&gt; %ldd\n&quot;</span>, x, y, z);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -Og -S sum.c<br></code></pre></td></tr></table></figure><p><code>-O</code>参数表示 <code>optimise</code> 开启编译器的优化，而<code>-S</code>则表示 <code>stop</code> ，意思是说到了汇编代码就停止，只输出汇编代码（因为我们之前说了 <code>gcc</code> 编译器其实启动的是一系列的程序，不仅仅是生成汇编代码，同时还有生成二进制指令，linker 等程序。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221117133916143.png" alt="image-20221117133916143"></p><p>我们可以得到如下的汇编代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.file&quot;sum.c&quot;<br>.text<br>.globlplus<br>.typeplus, @function<br>plus:<br>.LFB39:<br>.cfi_startproc<br>endbr64<br>leaq(%rdi,%rsi), %rax<br>ret<br>.cfi_endproc<br>.LFE39:<br>.sizeplus, .-plus<br>.globlsumstore<br>.typesumstore, @function<br>sumstore:<br>.LFB40:<br>.cfi_startproc<br>endbr64<br>pushq%rbx<br>.cfi_def_cfa_offset 16<br>.cfi_offset 3, -16<br>movq%rdx, %rbx<br>callplus<br>movq%rax, (%rbx)<br>popq%rbx<br>.cfi_def_cfa_offset 8<br>ret<br>.cfi_endproc<br>.LFE40:<br>.sizesumstore, .-sumstore<br>.section.rodata.str1.1,&quot;aMS&quot;,@progbits,1<br>.LC0:<br>.string&quot;%ld + %ld --&gt; %ldd\n&quot;<br>.text<br>.globlmain<br>.typemain, @function<br>main:<br>.LFB41:<br>.cfi_startproc<br>endbr64<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>pushq%rbx<br>.cfi_def_cfa_offset 24<br>.cfi_offset 3, -24<br>subq$24, %rsp<br>.cfi_def_cfa_offset 48<br>movq%rsi, %rbp<br>movq%fs:40, %rax<br>movq%rax, 8(%rsp)<br>xorl%eax, %eax<br>movq8(%rsi), %rdi<br>movl$10, %edx<br>movl$0, %esi<br>callstrtol@PLT<br>movslq%eax, %rbx<br>movq16(%rbp), %rdi<br>movl$10, %edx<br>movl$0, %esi<br>callstrtol@PLT<br>movslq%eax, %rbp<br>movq%rsp, %rdx<br>movq%rbp, %rsi<br>movq%rbx, %rdi<br>callsumstore<br>movq(%rsp), %r8<br>movq%rbp, %rcx<br>movq%rbx, %rdx<br>leaq.LC0(%rip), %rsi<br>movl$2, %edi<br>movl$0, %eax<br>call__printf_chk@PLT<br>movq8(%rsp), %rax<br>subq%fs:40, %rax<br>jne.L7<br>movl$0, %eax<br>addq$24, %rsp<br>.cfi_remember_state<br>.cfi_def_cfa_offset 24<br>popq%rbx<br>.cfi_def_cfa_offset 16<br>popq%rbp<br>.cfi_def_cfa_offset 8<br>ret<br>.L7:<br>.cfi_restore_state<br>call__stack_chk_fail@PLT<br>.cfi_endproc<br>.LFE41:<br>.sizemain, .-main<br>.ident&quot;GCC: (Ubuntu 13.2.0-23ubuntu4) 13.2.0&quot;<br>.section.note.GNU-stack,&quot;&quot;,@progbits<br>.section.note.gnu.property,&quot;a&quot;<br>.align 8<br>.long1f - 0f<br>.long4f - 1f<br>.long5<br>0:<br>.string&quot;GNU&quot;<br>1:<br>.align 8<br>.long0xc0000002<br>.long3f - 2f<br>2:<br>.long0x3<br>3:<br>.align 8<br>4:<br></code></pre></td></tr></table></figure><p>可以看到其实还是有一些所谓是 <code>junk</code> 的数据的，这一部分主要是由于我们的编译器进行标识定位所产生的，其实核心只需要关注ppt上的那部分代码即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sumstore:<br>pushq%rbx<br>movq%r8, %rbx<br>callplus<br>movl%eax, (%rbx)<br>addq$32, %rsp<br>popq%rbx<br>ret<br></code></pre></td></tr></table></figure><h2 id="Assembly-Characteristic"><a href="#Assembly-Characteristic" class="headerlink" title="Assembly Characteristic"></a>Assembly Characteristic</h2><h3 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h3><p>这边主要简单声明一下汇编语言中的数据类型。</p><ul><li><p>Integer 整数类型，汇编中我们可以操作的整数数据大小很多 1&#x2F;2&#x2F;4&#x2F;8 字节的都有</p><ul><li>值得注意的是在各大编程语言中的指针 <code>pointer</code>，本质上其实也是<strong>汇编语言的一个整数类型的数据</strong>，因为指针类型本质上是存储地址的，地址数据就是内存中具体的整型数值</li></ul></li><li><p>Floating 浮点数类型，在机器级别中存储的比较特殊，使用的是另一组专用的寄存器</p></li></ul><p><strong>总结</strong></p><ul><li>Assembly Code 每一条指令可以说所做的都很有限，不像是 go&#x2F;java 的一些高级编程语言那样，可以一行代码做很多事情</li><li>同时汇编代码是没有 <code>Array</code>&#x2F;<code>struct </code>这样的数据类型的，因为他们<strong>本身实际上是各大编程语言的汇编器所构建的上层建筑</strong></li></ul><h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><p>汇编代码的操作其实是在 <strong>寄存器&#x2F;内存数据</strong> 中进行算数运算的</p><p>汇编代码的运算其实更多的是<strong>从内存中获取数据，存储到寄存器中，或是从寄存器读取数据存到内存</strong>中</p><h3 id="Object-Code"><a href="#Object-Code" class="headerlink" title="Object Code"></a>Object Code</h3><p>由汇编器根据汇编代码生成目标代码(Object Code)，都是二进制数据，之后需要由连接器进行连接(Link)装配运行时的静态代码库等</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实本质上可以看成是如下的流程，我们用最常见的 c 语言指针运算的代码来阐述 <code>movq</code> 这个指令的作用</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221023145020917.png" style="zoom:67%;" /><p><code>C代码中 *dest = t</code> 的意思很简单，是将 t 的值赋到 dest 指针所指向的内存区域中</p><p>在这里对应汇编代码，有两个寄存器，分别是 rax 和 rbx ，对应代码中的 <code>*dest = t</code>，其中， t 的值在 rax 寄存器中，因此 <code>%rax</code> 就表示从寄存器中获取 t 的值</p><p> <code>%rbx</code> 的意思就是获取 <code>rbx</code> 寄存器里存储的 dest 指针存储的地址，<code>(%rbx)</code> 就表示在内存中找到对应的值，也就是 <code>M[%rbx]</code>,在汇编代码中用小括号表示取地址</p><p>之所以要用 movq(Quad Word) 是因为整形数据都是 8 字节，对应是 4 个字(Word)，因此 movq 就表示通过汇编代码操作寄存器中的数据写入内存</p><p>之后这段汇编代码被保存为 3 个字节长度的指令，存放在内存中  <code>0x40059e</code> 的地址位置</p><h2 id="Disassemble"><a href="#Disassemble" class="headerlink" title="Disassemble"></a>Disassemble</h2><p>反汇编，很有意思的一个东西，其实早在我们开发应用的时候就接触过</p><p>比如IDEA(或者是JB全家桶的IDE)在导入依赖库的时候，有的时候我们是没有下载源码的，这个时候如果直接点进看没有本地源码的代码想看下实现逻辑，IDEA就会反汇编出原来的代码。但是我们常常会发现反汇编出来的变量名都是错乱的，比如<code>var1,var2</code>诸如此类的</p><p>这是因为反汇编仅仅只会计算 obj 代码的字节个数来得到结果，汇编的变量不可恢复，导致汇编反推源码的变量名也是不可恢复的</p><p><strong>为什么反汇编后的变量名等都和源码不一样呢</strong></p><p>这主要是因为在源码经过编译之后生成的汇编代码后，实际上变量名对于编译器是不关心的，他只会生成对应在哪一个 <strong>寄存器</strong> 中，而我们再根据这个汇编代码生成二进制的 <strong>object code</strong> 的时候实际上寄存器都是特定的，就那么多，因此对应的字节确实是可以反推，但是原先源码的变量名是不可以反推得到</p><h3 id="反汇编工具"><a href="#反汇编工具" class="headerlink" title="反汇编工具"></a>反汇编工具</h3><ul><li><code>objdump -d (assembly code name)</code></li><li><code>gdb (assembly code name)</code></li></ul><h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>教授还说到了之前的课件中因为插入了<code>Word</code>执行文件的反汇编代码，收到了网友的谴责XD，这是因为在用户许可中一般都要求用户不能反汇编程序（当然也阻止不了你）</p><h1 id="Assembly-Basics"><a href="#Assembly-Basics" class="headerlink" title="Assembly Basics"></a>Assembly Basics</h1><h2 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h2><p>首先我们需要有一个基本的概念。</p><p>寄存器本质上其实是CPU中用来<strong>暂存指令，数据的一个存储单元</strong>，我们一般喜欢用名称的方式来对其进行记忆。</p><p>在PPT中列出了 8086 寄存器</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221023155421732.png" alt="image-20221023155421732" style="zoom:67%;" /><p>其中rsp比较特殊，是<code>stack pointer</code>。</p><p>无论是32位还是64位都可以访问低位（reference low-order bytes)，可以是低4字节，低2字节和低1字节。</p><h3 id="向下兼容"><a href="#向下兼容" class="headerlink" title="向下兼容"></a>向下兼容</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240618111024587.png"></p><p>其实这个图看的更加方便一点，我们可以看到图上对应不同的颜色以及不同的寄存器名称，黄色部分是 16 位寄存器，也就是 16 位处理器 8086 的设计，然后绿色部分是 32 位寄存器，给 32 位处理器使用，而蓝色部分是为 64 位处理器设计的。</p><p>这样的设计保证了向下兼容，也就是几十年前转为 16 位处理器开发的软件，如今也能在 64 位处理器上进行运行，因为寄存器中低位仍然保留</p><h3 id="History-1"><a href="#History-1" class="headerlink" title="History"></a>History</h3><p>值得注意的是在x86之前的IA32指令集架构中，只有8个寄存器，而x86-64是有16个寄存器，相较于传统的 IA32 架构扩大了一倍寄存器的数量。</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221023155821553.png" alt="image-20221023155821553" style="zoom:67%;" /><p>虽然说这里给出了各个寄存器的名字帮助记忆，但是其实这是之前的版本了，<strong>现在用什么寄存器和名字没有关系</strong>，只需要知道寄存器的名字是<strong>历史遗留问题</strong>即可。</p><h3 id="Moving-Data"><a href="#Moving-Data" class="headerlink" title="Moving Data"></a>Moving Data</h3><p>一个很常见的经典指令<code>movq</code>（这里这个 q 是 quadword，对应64位）。</p><p>它支持很多操作量(operand)。</p><ul><li>Immediate<ul><li>这个是指常量数据，比如某个常量地址&#x2F;数值。</li></ul></li><li>Register<ul><li>操作量可以是寄存器，这个比较常见。</li></ul></li><li>Memory<ul><li>操作量还是可以内存地址，但是具体在寻址的时候存在两个模型，具体的寻址模式可以参见 [Simple Memory Addressing Modes](##Simple Memory Addressing Modes) 以及 [Compelete Memory Addressing Modes](#Compelete Memory Addressing Modes)</li></ul></li></ul><h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h3><p>一些和 <code>movq</code> 相关的指令组合</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221023160759106.png" alt="image-20221023160759106" style="zoom:67%;" /><p>从上面的代码可以知道，其实<strong>寄存器中的数据完全可以看作是高级编程语言所编写程序中的 <code>tmp</code> 变量</strong></p><h2 id="Simple-Memory-Addressing-Modes"><a href="#Simple-Memory-Addressing-Modes" class="headerlink" title="Simple Memory Addressing Modes"></a>Simple Memory Addressing Modes</h2><h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h3><p>最基本的寻址模式，通过一个括号。</p><p><code>(%rdx)</code> 表示的是<strong>我们不关心 rdx 这个寄存器中的具体内容，直接就把他当作他存储了一段内存的地址</strong>，然后通过这个地址访问内存的数据。</p><p>说起来其实就等价于 c 中的指针寻址(referencing)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">temp = *p;<br></code></pre></td></tr></table></figure><p>我们假设 temp 在编译器执行后得到的寄存器名称为 <code>rdx</code> ，而原始 p 指针的地址存储于 <code>rax</code> 寄存器，这段其实就等价于:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq (%rax) , %rdx<br></code></pre></td></tr></table></figure><p>再来看一个基本的例子，以著名的 swap 函数为例</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">long</span> *p,<span class="hljs-type">long</span> *q)</span><br>&#123;<br>     <span class="hljs-type">long</span> i = *p;<br>     <span class="hljs-type">long</span> j = *q;<br>     *p = j;<br>     *q = i;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们假设编译器在进行 <strong>寄存器分配算法</strong> 之后得到每个数据对应的寄存器如下表：</p><table><thead><tr><th>Register</th><th>Value</th></tr></thead><tbody><tr><td>%rdi</td><td>p</td></tr><tr><td>%rsi</td><td>q</td></tr><tr><td>%rax</td><td>i</td></tr><tr><td>%rdx</td><td>j</td></tr></tbody></table><p>则每一行的代码其实可以等价如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#long i = *p;<br>movq (%rdi),%rax<br>#long j = *q;<br>movq (%rsi),%rdx<br>#*p = j;<br>movq %rdx,(%rdi)<br>#q = i;<br>movq %rax,(%rsi)<br></code></pre></td></tr></table></figure><p>具体的图例如下</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221117163034794.png" style="zoom:50%;" /><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221117163106148.png" style="zoom:50%;" /><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221117163125339.png" style="zoom:50%;" /><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221117163136343.png" style="zoom:50%;" /><h3 id="Displacement-D-R"><a href="#Displacement-D-R" class="headerlink" title="Displacement  D(R)"></a>Displacement  D(R)</h3><p>偏移，存在一个偏移常量D。</p><p>常见的一个表示的形式就是 <code>某个数(%rdx)</code> ，表示的是对 rdx 这个寄存器内的地址进行偏移运算（具体运算就是加上这个数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq 8(%rbp),%rdx<br></code></pre></td></tr></table></figure><p>以 <code>%rbp</code> 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 <code>%rdx</code> 中</p><h2 id="Compelete-Memory-Addressing-Modes"><a href="#Compelete-Memory-Addressing-Modes" class="headerlink" title="Compelete Memory Addressing Modes"></a>Compelete Memory Addressing Modes</h2><p>最常见的就是在进行 <strong>数组引用</strong> 的时候。</p><p>具体的寻址相关符号定义如下：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221117163217290.png"></p><p>其中的 Rb 其实就是一个基地址，对应我们数组的首个元素的地址，也叫做国内说的<strong>基址寄存器</strong></p><p>而 Ri 则是存储具体元素在哪一个索引，对应的其实是我们数组元素的下标</p><p>S 则与数组的元素有关，之所以是 1|2|4|8 其实就是对应<strong>数组存储的不同数据类型所占据的字节长度</strong>(比如 int 是 4 个字节的长度)。</p><p>而 PPT 中也给出了一些基本的表示形式和运算规则：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221119200226254.png"></p><p>上述的表达式<strong>不能死板的认为是一种只能用于内存地址的寻址方式，而是汇编语言通用的一种计算模板</strong></p><p>实际上，它计算的只是一个整数值，可以用于多种目的</p><p>这种计算模板可以用于各种需要整数运算的场景，不局限于内存地址</p><h2 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h2><p><code>lea = load effctive address</code></p><h3 id="uses"><a href="#uses" class="headerlink" title="uses"></a>uses</h3><p>顾名思义其实就是加载内存地址，之所以会出现这个汇编的 operator 其主要的出现场景有两个：</p><p>1)就是我们 C 中的 ampersand 运算符 &amp; 的汇编层面的对应，用来取地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p = &amp;arr[i];<br></code></pre></td></tr></table></figure><p>2)许多 c 语言的编译器也很喜欢用 lea 去进行算数上的运算，等价于常数乘法</p><p>当使用 lea 进行算数运算的时候，  leaq src dest 等价于将 src 的地址&#x2F;值和 dest进行相加之后存储到 dest 所指向的寄存器中</p><p>这个第二点可以说有点违背直觉， <code>leaq</code> 通常用于计算内存地址，但它<strong>只是将一个计算结果存储在目标寄存器中。这个计算结果并不一定要用作内存地址，可以是任何需要的整数结果</strong>。这样，我们可以利用 <code>leaq</code> 指令进行一些高效的算术运算</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>课件中举出了如下的例子，这里就是利用 lea 进行算数运算上的优化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">m12</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span><br>&#123;<br>     <span class="hljs-keyword">return</span> x*<span class="hljs-number">12</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码在进行翻译解释后编译器得到的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">leaq (%rdi,%rdi,2), %rax; #上面提到带 Scale 的寻址模式，等价于 x+x*2 -&gt; %rax<br>salq $2 ,%rax; #等价于返回 x&lt;&lt;2也就是乘以4的结果，这里的 $2 是一个直接值，汇编中的常量都需要一个$来标识<br></code></pre></td></tr></table></figure><h2 id="Arithmetic-Operations"><a href="#Arithmetic-Operations" class="headerlink" title="Arithmetic Operations"></a>Arithmetic Operations</h2><p>教授还给出了其他一些常用的算数运算的操作符。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221119205107592.png" alt="加减乘除左右移"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221119205114071.png" alt="自增自减取反"></p><p>他们都有一个规律就是都以 <code>operation src dest</code> 的格式，有点类似我们高级编程语言中的 x+&#x3D;y 这样的简写形式，<strong>因为 x+&#x3D;y 其实就是 将 x 和 y 的值进行相加，之后又存储到了 x 中。</strong></p><p>和 x+&#x3D;y 类似， leaq src dest 也是将 src 的地址&#x2F;值和 dest进行相加之后存储到 dest 所指向的寄存器中。</p><h2 id="Arithmetic-Expression-Example"><a href="#Arithmetic-Expression-Example" class="headerlink" title="Arithmetic Expression Example"></a>Arithmetic Expression Example</h2><p>教授给出了如下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">arith</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y, <span class="hljs-type">long</span> z)</span><br>&#123;<br>     <span class="hljs-type">long</span> t1 = x+y;<br>     <span class="hljs-type">long</span> t2 = z+t1;<br>     <span class="hljs-type">long</span> t3 = x+<span class="hljs-number">4</span>;<br>     <span class="hljs-type">long</span> t4 = y * <span class="hljs-number">48</span>;<br>     <span class="hljs-type">long</span> t5 = t3 + t4;<br>     <span class="hljs-type">long</span> rval = t2 * t5;<br>     <span class="hljs-keyword">return</span> rval;<br>&#125;<br></code></pre></td></tr></table></figure><p>要求我们可以看得懂哪些部分对应 c 中的代码即可，不要求你会写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">arith:<br>     leaq (%rdi,%rsi), %rax<br>     addq %rdx, %rax<br>     leaq (%rsi,%rsi,2), %rdx<br>     salq $4, %rdx<br>     leaq 4(%rdi,%rdx), %rcx<br>     imulq %rcx, %rax<br>     ret<br></code></pre></td></tr></table></figure><p>所以对应的各个变量以及寄存器表格如下</p><table><thead><tr><th>Arguments</th><th>Registers</th></tr></thead><tbody><tr><td>x</td><td>%rdi</td></tr><tr><td>y</td><td>%rsi</td></tr><tr><td>z</td><td>%rdx</td></tr><tr><td>t1,t2,rval</td><td>%rax</td></tr><tr><td>t4</td><td>%rdx</td></tr><tr><td>t5</td><td>%rcx</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quartz|定时任务</title>
    <link href="/2024/06/14/Quartz-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2024/06/14/Quartz-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="应用场景-amp-组件"><a href="#应用场景-amp-组件" class="headerlink" title="应用场景&amp;组件"></a>应用场景&amp;组件</h1><p>实际开发中定时任务场景十分常见</p><ul><li>每日跑批，日初日终结算</li><li>30分钟未支付取消订单</li></ul><p>在 Quartz 中有三个很重要的组件&amp;概念</p><ul><li>Job 描述定时任务要做什么，<strong>做什么</strong></li><li>JobDetail 定时任务的元数据信息，例如配置定时任务的名字，群组之类</li><li>Trigger 定时任务如何触发，<strong>什么时候做</strong>（常见的结合Spring的有 Cron 表达式，Cron Trigger）</li><li>Scheduler <strong>任务调度、组织编排</strong>，什么时候做什么</li></ul><p>Quartz的逻辑架构如下</p><p><img src="/../../../../Pictures/Markdown_Pic/Quartz-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/91b3dfeeb5b84277bef72ab9f79838a1.png"></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EDA</tag>
      
      <tag>定时任务</tag>
      
      <tag>Quartz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C|Pointer</title>
    <link href="/2024/06/09/C-Pointer/"/>
    <url>/2024/06/09/C-Pointer/</url>
    
    <content type="html"><![CDATA[<h1 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Linked list element */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELE</span> &#123;</span><br><span class="hljs-type">char</span> *value;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELE</span> *<span class="hljs-title">next</span>;</span><br>&#125; <span class="hljs-type">list_ele_t</span>;<br></code></pre></td></tr></table></figure><p>这里通过 <code>typedef</code> 关键字来定义了一个结构体，并且起了一个别名叫做 <code>list_ele_t</code></p><p>这样以后我们有两种方式来创建这个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELE</span> *<span class="hljs-title">e1</span>;</span><br><span class="hljs-type">list_ele_t</span> *e2;<br></code></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针本质上是一个变量，他是存储着另一个变量（指针所指变量）的内存地址</p><p>指针本身占用内存，用于保存地址值</p><p>我们以一个 Hello World 程序来举例说明，就以之前 typedef 的链表结构为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/* 定义链表元素结构体 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELE</span> &#123;</span><br>    <span class="hljs-type">char</span> *value;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELE</span> *<span class="hljs-title">next</span>;</span><br>&#125; <span class="hljs-type">list_ele_t</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* 创建第一个链表元素 */</span><br>    <span class="hljs-type">list_ele_t</span> *first = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">list_ele_t</span>));<br>    first-&gt;value = strdup(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    first-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 创建第二个链表元素并链接到第一个元素 */</span><br>    <span class="hljs-type">list_ele_t</span> *second = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">list_ele_t</span>));<br>    second-&gt;value = strdup(<span class="hljs-string">&quot;World&quot;</span>);<br>    second-&gt;next = <span class="hljs-literal">NULL</span>;<br>    first-&gt;next = second;<br><br>    <span class="hljs-comment">/* 打印链表中的值 */</span><br>    <span class="hljs-type">list_ele_t</span> *current = first;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, current-&gt;value);<br>        current = current-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">/* 释放内存 */</span><br>    <span class="hljs-built_in">free</span>(first-&gt;value);<br>    <span class="hljs-built_in">free</span>(first);<br>    <span class="hljs-built_in">free</span>(second-&gt;value);<br>    <span class="hljs-built_in">free</span>(second);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">list_ele_t</span> *first = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">list_ele_t</span>));<br></code></pre></td></tr></table></figure><p>这里的 <code>list_ele_t *first</code> 实际上是声明了一个指针变量 <code>first</code>，它的类型是 <code>list_ele_t *</code></p><p>意思是 <code>first</code> 是一个指向 <code>list_ele_t</code> 类型数据的指针</p><p>所以实际上 <code>first</code> 这个指针存储的是一个 <code>list_ele_t</code> 类型数据的内存地址。</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git|Git Playground</title>
    <link href="/2024/06/07/Git-Git-Playground/"/>
    <url>/2024/06/07/Git-Git-Playground/</url>
    
    <content type="html"><![CDATA[<h1 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h1><h2 id="分离HEAD"><a href="#分离HEAD" class="headerlink" title="分离HEAD"></a>分离HEAD</h2><p>一些基础的Git操作直接跳过，下面讲述更常见但是稍微复杂的 HEAD 相关的知识</p><p>Git 中 HEAD 指向的是当前本地版本的代码提交记录，通过 <code>git checkout</code> 来进行变更</p><p>一旦输入后本地的代码版本就会切换到对应提交记录的版本</p><p>对于提交记录的哈希值，我们可以用 <code>git log</code> 来进行查看</p><p>如果出现了当前 HEAD 指向的提交和 master 指向的提交不一致的情况，就是分离 HEAD 的状态</p><h2 id="相对移动"><a href="#相对移动" class="headerlink" title="相对移动"></a>相对移动</h2><p>Git 中指定提交记录的哈希值有点麻烦，我们可以用 <code>^</code> 或者是 <code>~num</code> 的方式来进行相对移动，例如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout main^<br>git checkout main~2<br>git checkout HEAD^^ <span class="hljs-comment">#除了用分支的哈希，分支名称外，也可以以 HEAD 作为相对移动的参照物，这句话的意思是将 HEAD 移动到上上个提交记录</span><br></code></pre></td></tr></table></figure><h2 id="强制移动分支"><a href="#强制移动分支" class="headerlink" title="强制移动分支"></a>强制移动分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch -f main HEAD^<br></code></pre></td></tr></table></figure><p>意思是将 main 分支强制移动到当前 checkout 指向的前一个提交记录</p><h1 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h1><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git  reset"></a>git  reset</h2><p>回滚提交版本到指定提交记录位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reset HEAD^<br></code></pre></td></tr></table></figure><p>这种就是回退到前一次提交记录，保留本地工作区的代码</p><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>回滚提交版本，针对远程分支有用</p><p>并不会直接删除提交记录，而是新增一个新的 commit 其中内容包含了旧版本的所有信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git revert HEAD<br></code></pre></td></tr></table></figure><h1 id="IDEA-pull-两种方式"><a href="#IDEA-pull-两种方式" class="headerlink" title="IDEA pull 两种方式"></a>IDEA pull 两种方式</h1><p>昨天准备提交代码，看到有更新就拉了一下，结果由于之前的提交修改了大部分包的结构位置，导致我拉完 IDEA 直接把我之前的工作历史记录给删除了XD</p><p>后面了解发现其实 IDEA 有两种更新代码的方式，分别对应 merge 和 rebase </p><p>假设我们现在<strong>基于之前的最新</strong>提交记录上开发，然后主线 master 还是有其他人在同时进行开发新的功能，来看下两种不同的情况</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240614094504312.png" alt="image-20240614094504312"></p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>merge会创建一个新的提交记录，包含了其他人开发新功能的所有记录（如图上最后一个）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout feature<br><span class="hljs-comment">#当前在 feature 分支线，我们想要把 main 的工作记录同步到当前工作分支上</span><br>git merge main <br></code></pre></td></tr></table></figure><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240614094716781.png" alt="image-20240614094716781"></p><p>那么Feature所指向的提交记录就同时具备了其他人在同一时间开发的记录、以及自己本地进行的修改</p><p>我们可以发现 Merge 本身是一种非破坏性的操作，无论是自己工作的提交线还是别人的提交线都没有收到破坏</p><p>但是缺点就是会产生很多没有意义的 Merge Commit 记录，如果分支数量一多或者是分支的更新非常频繁，就会导致 commit 信息难以维护</p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>最早使用rebase主要是当初在开源社区提交代码的时候为了合并多个 commit 记录为一个 commit</p><p>实际上 rebase 也可以实现代码的合并</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout feature<br>git rebase main<br></code></pre></td></tr></table></figure><p>使用 rebase 相当于<strong>重新设置了当前分支包含的所有新提交的基准点</strong></p><p><img src="/../../../../Pictures/Markdown_Pic/Git-Git-Playground/image-20240614095121942.png" alt="image-20240614095121942"></p><p>例如上图就是把我们之前的开发线上修改的内容重新设置基准设置为了 main 后面</p><p>这样的操作会导致公共分支上的其他人受到影响，因为你这样的操作会导致原先没同步的人，基于最后一个蓝色提交的提交基准发生变化</p><h2 id="rebase的黄金法则"><a href="#rebase的黄金法则" class="headerlink" title="rebase的黄金法则"></a>rebase的黄金法则</h2><blockquote><p>The golden rule of <code>git rebase</code> is to never use it on <em>public</em> branches.</p></blockquote><p>上面是在 feature 分支上，把 feature 的 base 设置为了 main 后</p><p>加入反过来是在 main 分支上，设置 main 的 base 为 feature，那影响就大了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout main<br>git rebase feature<br></code></pre></td></tr></table></figure><p><img src="/../../../../Pictures/Markdown_Pic/Git-Git-Playground/image-20240614095651786.png" alt="image-20240614095651786"></p><p>这一个操作直接导致其他人基于 main 的操作直接毁了，因此在公共开发的分支（例如 main 分支等）千万不能用 <code>rebase master</code> 这样的指令</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发常识技巧</title>
    <link href="/2024/05/29/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%AF%86%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/05/29/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%AF%86%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="DO-x2F-BO-x2F-DTO-x2F-VO"><a href="#DO-x2F-BO-x2F-DTO-x2F-VO" class="headerlink" title="DO&#x2F;BO&#x2F;DTO&#x2F;VO"></a>DO&#x2F;BO&#x2F;DTO&#x2F;VO</h1><h2 id="DO-x3D-PO"><a href="#DO-x3D-PO" class="headerlink" title="DO &#x3D; PO"></a>DO &#x3D; PO</h2><p>都是表示持久化对象的实体类，Persistent Object 和 Data Object</p><p>如果持久层是关系型数据库，那么，<strong>数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性</strong>。通过 DAO 层向上传输数据源对象</p><h2 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h2><p>又叫做 Data Transfer Object</p><p>业务上传输的数据对象，</p><p>例如一张数据库表有50个字段，那么PO就有50个属性，但是我们在远程服务或者页面显示只需要10个字段。这时就没有必要传输所有的字段，而是用10个属性的DTO来进行传递</p><h2 id="BO"><a href="#BO" class="headerlink" title="BO"></a>BO</h2><p>业务对象，具体是指由Service层内封装的临时业务逻辑的对象</p><p>通过调用 DAO 方法 , 结合 PO、VO 进行业务操作。 一个BO对象可以包括多个PO对象</p><p>除了基本的 get set 方法，BO本身也会包含很多针对自身数据进行计算的方法</p><h2 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h2><p>View Object</p><p>页面展示用的数据对象</p><h2 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h2><p>以一个最常见的用户注册场景，引出分层设计的模式</p><p>现在我们有一张用户表，包含 id name email password</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PO = DO 和数据源交互的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserPO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-comment">// getters and setters</span><br>&#125;<br><br><span class="hljs-comment">// BO 包含一些业务操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 业务逻辑处理</span><br>        <span class="hljs-comment">// 转换为 PO 保存到数据库</span><br>        <span class="hljs-type">UserPO</span> <span class="hljs-variable">userPO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserPO</span>();<br>        userPO.setName(<span class="hljs-built_in">this</span>.name);<br>        userPO.setEmail(<span class="hljs-built_in">this</span>.email);<br>        <span class="hljs-comment">// 保存 userPO 到数据库</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// getters and setters</span><br>&#125;<br><br><span class="hljs-comment">// DTO 有一个用户注册请求，需要传输用户的基本信息和密码，这个时候 id 就不需要了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDTO</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-comment">// getters and setters</span><br>&#125;<br><br><br><span class="hljs-comment">// VO 前端展示，这个时候 password 就不需要传输了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserVO</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-comment">// getters and setters</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><p>JDK7 引入的新特性，其作用是简化try catch</p><p>例如下面这一段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(configFile)) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> IOUtils.toString(inputStream, StandardCharsets.UTF_8);<br>    config = GsonUtil.parseObject(json, ServerConfig.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>try</code>块执行完毕后，无论是否出现异常，都会自动关闭<code>inputStream</code>资源。</p><ol><li><strong>自动关闭资源</strong>：<ul><li>任何在<code>try</code>块中声明的资源都会在<code>try</code>块结束后自动关闭。这相当于在<code>finally</code>块中调用了资源的<code>close()</code>方法。</li><li>这简化了代码，使得资源管理更加安全和便捷，防止因忘记关闭资源而导致资源泄露。</li></ul></li><li><strong>可选的异常处理</strong>：<ul><li>即使<code>try</code>块中的代码抛出异常，资源仍然会被自动关闭。</li><li>如果需要处理异常，可以在<code>try-with-resources</code>块后添加<code>catch</code>块来捕获和处理异常。</li></ul></li></ol><h1 id="业务上如何进行调试"><a href="#业务上如何进行调试" class="headerlink" title="业务上如何进行调试"></a>业务上如何进行调试</h1><p>针对业务接口调试，我们主要就是从接口进入，然后看接口输出参数，出问题的字段，找到有没有被正确赋值（要么没赋值，要么错误赋值导致的）然后看下业务方法在哪里赋值合适</p><p>页面上一些接口不清楚在哪里的，有两种方式来定位：</p><ul><li>问前端接口调用的是哪一个，取数怎么取的参数</li><li>全局搜索页面上的关键字，有文档注释的就会自动定位到核心接口</li></ul><h1 id="QueryDSL"><a href="#QueryDSL" class="headerlink" title="QueryDSL"></a>QueryDSL</h1><h2 id="动态参数解析"><a href="#动态参数解析" class="headerlink" title="动态参数解析"></a>动态参数解析</h2><p>可以使用 Predicate 参数来绑定实体类信息进行动态参数类型传递，不需要手动进行解析</p><p>当然在实体类中还是需要进行额外的配置和映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@QuerydslPredicate(root = Tast.class)</span> Predicate predicate<br></code></pre></td></tr></table></figure><p>这里就绑定了 Tast 这个类的实体信息，之后前端传递的，和实体类中<strong>直接包含或者是通过复杂数据类型组合的方式实现的间接包含</strong>的数据类型，都会被自动解析和传递</p><h2 id="代码自动生成"><a href="#代码自动生成" class="headerlink" title="代码自动生成"></a>代码自动生成</h2><p>QueryDSL 会根据我们的实体类生成一组与之对应的查询类型。这些类型通常以 <code>Q</code> 开头，并且包含了一些静态字段和方法，用于帮助构建查询</p><p>这些自动生成的 java 代码都会放在 <code>build/generated/sources/annotationProcessor/java/main</code> 目录下而不是自己编写的源代码目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;ItemHistory&gt; <span class="hljs-title function_">queryByItemId</span><span class="hljs-params">(Long itemId)</span> &#123;<br>     <span class="hljs-comment">//用代码API映射sql的判断</span><br>    <span class="hljs-type">BooleanExpression</span> <span class="hljs-variable">booleanExpression</span> <span class="hljs-operator">=</span> QItemHistory.itemHistory.itemId.eq(itemId);<br>     <span class="hljs-comment">//查询指定id的记录并根据 version 字段降序</span><br>    <span class="hljs-keyword">return</span> (List&lt;ItemHistory&gt;) itemHistoryRepository.findAll(booleanExpression, Sort.by(Sort.Direction.DESC, <span class="hljs-string">&quot;version&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Embedded-和-Transient"><a href="#Embedded-和-Transient" class="headerlink" title="@Embedded 和 @Transient"></a>@Embedded 和 @Transient</h1><p>这两个都是用于 SpringData JPA 中实体类上的注解</p><p>其中 <code>@Embedded</code> 注解用于将一个可嵌入的复杂数据类型 作为实体的一部分进行持久化。它表示该属性是一个嵌入类型，将其所有字段嵌入到拥有它的实体表中</p><p>而 <code>@Transient</code> 注解用于标记某个字段<strong>不需要持久化到数据库中</strong>。被标记的字段在ORM框架中会被忽略，不会在数据库表中生成对应的列，也不会在持久化操作中进行存取</p><h1 id="异常抛出和处理"><a href="#异常抛出和处理" class="headerlink" title="异常抛出和处理"></a>异常抛出和处理</h1><h2 id="异常的处理时机"><a href="#异常的处理时机" class="headerlink" title="异常的处理时机"></a>异常的处理时机</h2><p>在工具方法中 <strong>不要 catch 处理异常并返回某种默认值</strong>，不然会导致处理逻辑调用工具方法的时候不好直接定位 BUG，要的话就直接抛出</p><p>例如下面这种就是不被允许的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">twoDecimalRetain</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span> &amp;&amp; !str.isEmpty()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">decimalResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(str);<br>            decimalResult = decimalResult.setScale(<span class="hljs-number">2</span>, RoundingMode.HALF_UP);<br>            <span class="hljs-keyword">return</span> decimalResult.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0.00&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0.00&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>出了 BUG 是不好直接定位的，因为这里任何异常或者是非法值都会返回 0 值，前端数据反而还有值，而且大概率和数据库的不一致，这样肯定就 BUG 了，不好排查</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发技巧</tag>
      
      <tag>开发规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka|Introduction</title>
    <link href="/2024/05/28/Kafka-Introduction/"/>
    <url>/2024/05/28/Kafka-Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://kafka.apachecn.org/1/">Kafka 中文翻译</a></p><p><a href="https://stackoverflow.com/questions/48834927/the-input-line-is-too-long-when-starting-kafka">java - The input line is too long when starting kafka - Stack Overflow</a></p><h1 id="基本功能-amp-概念"><a href="#基本功能-amp-概念" class="headerlink" title="基本功能&amp;概念"></a>基本功能&amp;概念</h1><h2 id="提供的功能"><a href="#提供的功能" class="headerlink" title="提供的功能"></a>提供的功能</h2><p>Kafka作为流事件处理平台，其提供了强大的事件处理功能：</p><ul><li><strong>发布和订阅</strong>事件流，以及从其他的系统平台持续导入和导出数据</li><li><strong>存储</strong>事件流</li><li>针对当前发生和已经发生的事件流进行<strong>回顾和处理</strong></li></ul><h2 id="组成架构"><a href="#组成架构" class="headerlink" title="组成架构"></a>组成架构</h2><p>Kafka可以部署在集群或者是单机节点，主要包括客户端和服务端</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>负责存储和传输事件流，也分为两种节点：</p><ul><li>存储节点，又叫做 Broker，存储事件流</li><li>剩下的节点运行 Kafka Connect <strong>对接外部数据进行事件流处理过程中的导入和导出</strong></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端帮助编写可以处理大量数据的应用程序和微服务</p><p>Java&#x2F;Scala 提供了直接的客户端和更高级别的 Stream API库</p><p>同时也可以用 REST API 作为客户端来调用</p><h1 id="术语概念"><a href="#术语概念" class="headerlink" title="术语概念"></a>术语概念</h1><h2 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h2><p>Kafka 中一个事件(Event)的基本组成如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">Event key: <span class="hljs-string">&quot;Alice&quot;</span><br>Event value: <span class="hljs-string">&quot;Made a payment of $200 to Bob&quot;</span><br>Event timestamp: <span class="hljs-string">&quot;Jun. 25, 2020 at 2:06 p.m.&quot;</span><br></code></pre></td></tr></table></figure><p>除了基本的 KV 之外还要包含时间戳信息以及可选的元数据标头</p><h2 id="发布订阅-amp-生产者消费者"><a href="#发布订阅-amp-生产者消费者" class="headerlink" title="发布订阅&amp;生产者消费者"></a>发布订阅&amp;生产者消费者</h2><p>在 Kafka 中，生产者是<strong>发布</strong>事件的客户端（写入），消费者是<strong>订阅</strong>事件的客户端（读取和处理）</p><p>生产者和消费者互相解耦并且互相透明，不知道对方的存在</p><p>这也是实现异步解耦以及事件驱动架构的核心，无论是生产者还是消费者都不需要等待对方，就可以进行自己对应的操作</p><h2 id="主题Topic"><a href="#主题Topic" class="headerlink" title="主题Topic"></a>主题Topic</h2><p>主题 Topic 是事件 Event 的集合，一个 Topic 可以有0个1个或者多个的订阅者以及0个1个或者多个的发布者</p><p>此外不同于传统的消息队列，<strong>Kafka中事件被消费之后不会删除</strong>，我们可以针对每一个 Topic 来设置事件的过期时间，因此可以实现事件的回查</p><h2 id="分区Partition"><a href="#分区Partition" class="headerlink" title="分区Partition"></a>分区Partition</h2><p>主题是分区的，这也是构建分布式系统可靠性、可扩展性的一个经典思想</p><p>通过将一个 Topic 分成多个 Partition，Kafka 实现了水平扩展（Scalability）。多个 Partition 可以分布在不同的 Broker 节点上，从而提高并行处理能力</p><p>也就是说一个大的 Topic <strong>在逻辑上分为多个 Partition</strong>，同时这些 Partition 在逻辑上包含多个 Eevnts，每一个 Partition 会存在 Replicatioin，Replication 会存在于多个 Broker 节点上，这是实现分布式系统中高可用需求的最常见的一种方式</p><p>具体的 Partition Bucket 分配逻辑其实是基于事件 Event 的 key 来分配，事件在发布的时候会附上一个 offset 来表示在 Partition Bucket 中的具体位置</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240528172053687.png" alt="Event|Topic|Partition"></p><p>同时 Kafka 保证<strong>给定分区的任何消费者，将始终按照与写入事件一致的顺序来消费事件</strong></p><blockquote><p>总结：</p><ul><li>分区：可扩展性，并发请求</li><li>副本：高可用</li></ul></blockquote><h1 id="重要架构概念"><a href="#重要架构概念" class="headerlink" title="重要架构概念"></a>重要架构概念</h1><h2 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h2><p>由于消息比较多，因此一个 topic 下的消息可能需要多个消费者来进行消费</p><p>同时由于 Kafka 中，只需写入一次消息，可以支持任意多的应用读取这个消息。因此通常而言，我们不同的系统应用，会配置不同的消费者组，来消费同一个 topic 下的消息，从而<strong>实现每个应用都能读到全量消息</strong></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/v2-7979e474d2e58b3ae2b195a9b3a8853e_r.jpg" alt="不同消费组消费同一个 topic "></p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>用一张图来概括 kafka 的整体架构就是</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/v2-60bd008ce076bd51b93ce4f46ae190d0_720w.webp" alt="img"></p><p>其中：</p><ul><li>Producer 和 Consumer 不必多说了，其实就是各种客户端应用程序来调用 Kafka 对外暴露接口的 API 发送和拉取消息</li><li>Broker：可以理解为<strong>独立的 Kafka 实例</strong>。多个 Kafka Broker 组成一个 Kafka Cluster</li><li>Topic：是多个消息的集合，一般来说<strong>一堆需要被一个（或者多个）应用消费的消息所构成的集合就是 Topic</strong></li><li>Partition：队列，一个 Topic下可以包含多个 Partiion，多个 Partition 数据不会重复。<strong>Partition的存在提高了并发能力</strong></li><li>Replica：可以看到在图中，不同 Broker 服务下，相同 Topic 里，存在相同的 Partition，这是 Kafka 实现高可用的一种思想；<strong>分区存在多个副本，生产的消息会发送到 Broker 的 Leader Replica 上，由 Followers 在 Kafka 内部进行同步</strong></li></ul><h1 id="部署实践"><a href="#部署实践" class="headerlink" title="部署实践"></a>部署实践</h1><h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><p>Kafka 的部署需要 ZooKeeper 的依赖，好在最新版本已经内置了 Zookeeper 的启动方式，一行命令即可</p><p>值得注意的是，旧版的 Kafka 对 ZK 强依赖，后面新版本中实现了基于 Raft 的分布式共识协调方式来替换 ZK</p><p>官网下载的 release 包含 <code>.sh</code> 的 Linux 部署方式以及在 <code>\bin\windows</code> 的 <code>.bat</code> 部署方式，结合实际生产环境和测试环境来部署即可</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">.\zookeeper-server-<span class="hljs-built_in">start</span>.bat ..\..\config\zookeeper.properties<br></code></pre></td></tr></table></figure><blockquote><p>在启动 bat 脚本的时候报错：<strong>The input line is too long. The syntax of the command is incorrect.</strong> 这是因为官方给的下载包解压出来之后是类似 <code>kafka_2.11-1.0.0</code> 这样的目录，重命名为 <code>kafka</code> 即可解决问题</p></blockquote><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240529092631644.png"></p><p>启动 Zookeeper 之后启动 Kafka Server</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">.\kafka-server-<span class="hljs-built_in">start</span>.bat ..\..\config\server.properties<br></code></pre></td></tr></table></figure><h2 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h2><p>部署 Kafka 单机节点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker pull apache/kafka:3.7.0<br>$ docker run -p 9092:9092 apache/kafka:3.7.0<br></code></pre></td></tr></table></figure><h1 id="实践测试"><a href="#实践测试" class="headerlink" title="实践测试"></a>实践测试</h1><h2 id="创建-Topic"><a href="#创建-Topic" class="headerlink" title="创建 Topic"></a>创建 Topic</h2><p>在我们之前的基本概念中提到了，Kafka 作为一个事件流处理的平台，其所定义的事件主要包含：<strong>付款交易、手机的地理位置更新、发货订单、传感器测量 来自物联网设备或医疗设备的消息</strong></p><p>而这些事件都被存储和维护在一个 主题 Topic 中，事件类似于文件而主题类似文件夹</p><p>我们通过官方提供的命令行工具来作为客户端</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bat">.\kafka-topics.bat --create --topic quickstart-events --bootstrap-server localhost:<span class="hljs-number">9092</span><br>Created topic quickstart-events.<br></code></pre></td></tr></table></figure><p>这一段命令向 Kafka 服务端发送创建新 Topic 的请求，其中 <code>--topic</code> 指定了主题名称，<code>--bootstrap-server</code> 指定了服务端地址</p><p>我们还可以查询主题的详细分区信息，可以看到一些分区个数，复制因子等</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240529093646528.png"></p><p>具体参数设置可以 <code>--help</code> 一下</p><h2 id="发布和订阅事件"><a href="#发布和订阅事件" class="headerlink" title="发布和订阅事件"></a>发布和订阅事件</h2><p>客户端发布的事件会被 Broker 持久化存储</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240529094018695.png"></p><p>通过控制台命令启动交互式的客户端来发布记录，默认每一行都是一个 Event 记录</p><p>同时我们打开消费者进程，可以看到事件几乎是同时被消费的：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240529094403038.png" alt="发布"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240529094423895.png" alt="订阅"></p><p>同时正如之前所说，即使我们重新启动一个新的订阅者进程，之前发布的事件也能被按顺序读取出来（发布的顺序），不同于传统的消息队列，Kafka采取的是持久化存储</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EDA</tag>
      
      <tag>Distribued System</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Groovy</title>
    <link href="/2024/05/28/Groovy/"/>
    <url>/2024/05/28/Groovy/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="IDEA集成"><a href="#IDEA集成" class="headerlink" title="IDEA集成"></a>IDEA集成</h2><p>可以安装 Groovy 的 Plugin 起到代码高亮以及类标注的辅助作用</p><p>在 Maven 中只需要引入一个依赖即可开始开发 Groovy 脚本程序</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.groovy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>groovy<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="令牌"><a href="#令牌" class="headerlink" title="令牌"></a>令牌</h2><p>在 Groovy 中令牌可以是一个关键字、标识符，常量、符号或者是字符串</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">println(<span class="hljs-string">&quot;Hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>上述的语法中就包含了两个令牌，一个是 println 关键字，另一个则是 Hello 字符串</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Groovy 中标识符的概念和 Java 中大致类似，要求：</p><p>以字母，美元或下划线开头，<strong>不能以数字开头</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br><span class="hljs-keyword">def</span> x = <span class="hljs-number">5</span><br><span class="hljs-keyword">def</span> $x = <span class="hljs-number">5</span><br><span class="hljs-keyword">def</span> _x = <span class="hljs-number">5</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常见语法"><a href="#常见语法" class="headerlink" title="常见语法"></a>常见语法</h1><h2 id="动态声明"><a href="#动态声明" class="headerlink" title="动态声明"></a>动态声明</h2><p>在之前的例子中我们也可以看到</p><p>Groovy 的标识符声明除了类似于 Java 的静态声明方式之外，还有着不同于 Java 有点类似于 Python 等的动态声明方式，是通过 <code>def</code> 关键字来声明</p><p>动态声明的方式意味着编译器<strong>不会像静态声明方式那样在编译期就检查操作是否符合类型支持范围</strong>，而是会在运行时决定变量的类型，编译期变量的类型有可能会发生改变</p><h2 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h2><p>Groovy 文档中提到的一些关键字</p><table><thead><tr><th>as</th><th>assert</th><th>break</th><th>case</th></tr></thead><tbody><tr><td>catch</td><td>class</td><td>const</td><td>continue</td></tr><tr><td>def</td><td>default</td><td>do</td><td>else</td></tr><tr><td>enum</td><td>extends</td><td>false</td><td>Finally</td></tr><tr><td>for</td><td>goto</td><td>if</td><td>implements</td></tr><tr><td>import</td><td>in</td><td>instanceof</td><td>interface</td></tr><tr><td>new</td><td>pull</td><td>package</td><td>return</td></tr><tr><td>super</td><td>switch</td><td>this</td><td>throw</td></tr><tr><td>throws</td><td>trait</td><td>true</td><td>try</td></tr><tr><td>while</td><td></td><td></td><td></td></tr></tbody></table><h2 id="可以不加分号"><a href="#可以不加分号" class="headerlink" title="可以不加分号"></a>可以不加分号</h2><p>不同于 java 的硬性要求， groovy 中开发者可以不加分号，仅仅以换行来分割每一行的内容</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br><span class="hljs-keyword">def</span> x = <span class="hljs-number">5</span><br>println(x)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><ul><li>for-in 遍历 List</li><li>for-in 遍历数值范围</li><li>for-in 遍历 Map</li></ul><p>和 Java 大体类似，但是 Groovy 还更早支持了 <code>for-in</code> 这种遍历  List 的方式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br><span class="hljs-type">int</span> [] arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> arr)&#123; <span class="hljs-comment">//甚至还包含了自动类型推断</span><br>println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时 for-in 也可以用于 <code>1..5</code> 这样的循环范围声明方式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>)&#123;<br>println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>甚至还天生支持 Map</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>Map&lt;String,Integer&gt; map = [<span class="hljs-string">&quot;A&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;B&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;C&quot;</span>:<span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> map)&#123;<br>println(i.key + <span class="hljs-string">&quot; = &quot;</span> + i.value)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h1><ul><li>Groovy 中的方法是通过返回值类型或者是 <code>def</code> 关键字来定义的</li><li>传递参数的时候不需要显式声明类型，会自己推断</li><li>默认参数需要放在参数列表的最后面指定</li></ul><p>支持 <code>def</code> 声明或者是传统方式声明</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>print(sum(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;2&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> sum(a, b) &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p> 如果没有值传递给参数的方法，则使用缺省值</p><p>如果同时出现使用非默认和默认参数，则必须注意，默认参数应在参数列表的末尾定义。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>print(sum(<span class="hljs-number">1</span>))<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> sum(a, b = <span class="hljs-number">6</span>) &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>groovy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git|GitLab</title>
    <link href="/2024/05/28/Git-GitLab/"/>
    <url>/2024/05/28/Git-GitLab/</url>
    
    <content type="html"><![CDATA[<h1 id="账户配置"><a href="#账户配置" class="headerlink" title="账户配置"></a>账户配置</h1><p>首先需要保证配置好公司发给你的邮箱和账号，不能用自己私人的</p><p>那样子百分百是没有权限 access denied</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;username&quot;</span><br>$ git config --global user.email <span class="hljs-string">&quot;分配的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>设置完了可以再检查一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git config --list<br></code></pre></td></tr></table></figure><h1 id="创建-ssh-key"><a href="#创建-ssh-key" class="headerlink" title="创建 ssh key"></a>创建 ssh key</h1><p>这里的配置其实和 github 类似</p><p>都是需要在本机创建一个 ssh key </p><p>将这个 ssh key 在线绑定到 GitLab 的系统上</p><p>之后拉代码的时候通过比对 ssh key 来判断是否具有权限（猜测 ssh key 的生成算法就是基于用户名和邮箱的，因此如果在之前第一步配置账户的时候配置错了 git 全局账户信息，那么 ssh key 就会验证失败，账户不匹配就没有权限）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;分配的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>三个回车后找到生成好的 ssh key，文件名为  <code>ssh_rsa.pub</code></p><p>复制内容到自己的 GitLab 账户的 Settings 配置中</p><p>这样就算是我们本机的设备与 GitLab 做好了绑定</p><h1 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路"></a>总结思路</h1><p>一般来说公司的代码托管都是采取 GitLab 部署在内网环境，外网无法直接访问</p><p>可以简单粗暴的理解为，GitLab 就是一个单机部署和公司团队离线使用的 Github，更为私人和商业化</p><p>我们在能够访问内网的环境下（公司网络或者是挂公司代理）拉取部署在内网环境的仓库代码</p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitlab</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程</title>
    <link href="/2024/05/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>函数式编程是一种编程思想，并且被很多当今主流的编程语言所纳入实现对应的 库和API 供开发者调用</p><p><strong>大部分语言都支持的函数式编程三套件：Map、Reduce、Filter</strong></p><p>同时在分布式系统课程的第一节 MapReduce 中也经由 Map 和 Reduce 函数的实现中提到了一些函数式编程的思想</p><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>函数式编程的核心思想是描述 <strong>做什么</strong> 而不是 怎么做</p><p>在函数式编程中，函数被视为第一类对象，<strong>可以作为参数传递给其他函数，也可以从其他函数返回</strong></p><p>例如下面这段 Java 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lambda 表达式作为参数传递给函数</span><br>List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>numbers.forEach(number -&gt; System.out.println(number));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lambda 表达式作为返回值</span><br>Function&lt;Integer, Integer&gt; square = x -&gt; x * x;<br>System.out.println(square.apply(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 25</span><br></code></pre></td></tr></table></figure><p>通过 Function 接口实例化了一个不同寻常意义的<strong>函数</strong>，这个函数接收输入并且输出输入的平方</p><p>JDK8 中引入了 Function 这个<strong>函数式接口</strong>，引入了函数<strong>对象</strong>，可以说是用面向对象的方式来处理函数式编程的核心</p><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>函数式编程的其中一个核心概念是纯函数</p><p>纯函数的意思是：</p><ul><li>输出的结果只和输入参数有关</li><li>函数没有任何副作用（这里的副作用是指<strong>不修改除了函数之外的任何变量</strong>）</li></ul><p>纯函数举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaTest</span> &#123;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pureFunctionAddOne</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br><span class="hljs-keyword">return</span> num+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">notPureFunctionAddOne</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>idx += num+<span class="hljs-number">1</span>; <span class="hljs-comment">//修改了其他变量，有副作用</span><br><span class="hljs-keyword">return</span> idx; <span class="hljs-comment">//输出不仅仅之和输入有关</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;T, R&gt; &#123;<br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;<br>     <br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="hljs-title function_">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> V, ? extends T&gt; before)</span> &#123;<br>        Objects.requireNonNull(before);<br>        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> R, ? extends V&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="hljs-title function_">identity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在 Function 接口中只有一个抽象方法，剩下的都是这种<strong>有且只有一个抽象方法的接口叫做函数式接口</strong></p><p>这里的 <code>@FunctionalInterface</code> 起到了一个标注作用，针对这个注解修饰的接口，编译器会强制检查该接口是否满足函数式接口的要求：“<strong>确实有且仅有一个抽象方法</strong>”，否则将会报错。</p><blockquote><p>即使不使用该注解，只要一个接口满足函数式接口的要求，那它仍然是一个函数式接口，使用起来都一样。该注解只起到标记接口，指示编译器对其进行检查的作用</p></blockquote><h1 id="其他的函数式接口"><a href="#其他的函数式接口" class="headerlink" title="其他的函数式接口"></a>其他的函数式接口</h1><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>最常见的以及最核心的函数式接口：<code>java.util.function.Function</code>，<code>Function</code> 接口表示一个接受单个参数并返回单个值的函数（方法）</p><p>在上面的例子中我们也提到过，这里再看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Lambda 表达式作为返回值</span><br>Function&lt;Integer, Integer&gt; square = x -&gt; x * x; <span class="hljs-comment">//接收单个参数 x 并返回单个值 x*x</span><br>System.out.println(square.apply(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 25</span><br></code></pre></td></tr></table></figure><p>这里的 Lambda表达式就是相当于一个匿名实现类，相当于是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareFunction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Function</span>&lt;Integer,Integer&gt;&#123;<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(Integer x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x*x;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>          Function&lt;Integer,Integer&gt; square = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SquareFunction</span>();<br>    System.out.println(square.apply(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 25</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>有点类似 Map Reduce 中提到的 Map 和 Reduce 函数了</p><p>JDK8 Stream API 中的 map 方是接收一个参数，并返回一个值的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stream.map((value) -&gt; value.toUpperCase())<br></code></pre></td></tr></table></figure><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><h2 id="缓存查询"><a href="#缓存查询" class="headerlink" title="缓存查询"></a>缓存查询</h2><p>实现一个通用的缓存模板。查询一个值，先找缓存，找到则返回，没找到通过接口获取，结果保存到缓存后返回</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Programming Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Whisper|Quick Start</title>
    <link href="/2024/05/09/Whisper-Quick-Start/"/>
    <url>/2024/05/09/Whisper-Quick-Start/</url>
    
    <content type="html"><![CDATA[<p>AI小白，由于最近有个英语&#x2F;西班牙语录音转记的需求，因此选择 Whisper 开源模型，记录一下折腾的过程</p><p>本地部署的硬件环境：</p><ul><li>CPU：Ryzen 5600</li><li>GPU：RTX 3060Ti</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://zhuanlan.zhihu.com/p/595691785">开源免费离线语音识别神器whisper如何安装</a></p><p><a href="https://discuss.pytorch.org/t/error-loading-lib-site-packages-torch-lib-shm-dll-or-one-of-its-dependencie/201695">Error loading “\lib\site-packages\torch\lib\shm.dll” or one of its dependencie - PyTorch Forums</a></p><h1 id="Environments"><a href="#Environments" class="headerlink" title="Environments"></a>Environments</h1><p>部署所需要的软件环境如下：</p><p>OS：Win11</p><p>Pytorch 2.2.2 CUDA 11.6</p><p>Python 3.9</p><p>Ffmpeg</p><p>Git</p><h1 id="Ffmpeg"><a href="#Ffmpeg" class="headerlink" title="Ffmpeg"></a>Ffmpeg</h1><p>下载最新的 ffmpeg release 追加环境变量</p><p><a href="https://github.com/BtbN/FFmpeg-Builds/releases">Releases · BtbN&#x2F;FFmpeg-Builds</a></p><h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><p>需要根据对应的 Python 版本选择对应的 Pytorch 版本 <a href="https://pytorch.org/get-started/previous-versions/">Previous PyTorch Versions | PyTorch</a></p><p>这里用最新的2.3会报错不知道为什么，已经保证了对应 Python 版本是3.8+(3.9)，但是运行 Whisper 的时候还是报错：</p><p><code>Error loading “\lib\site-packages\torch\lib\shm.dll” or one of its dependencies</code></p><p>pip 卸载 2.3 版本的 Pytorch 后重新安装 2.2.2 的成功运行</p><h1 id="Whisper"><a href="#Whisper" class="headerlink" title="Whisper"></a>Whisper</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install git+https://github.com/openai/whisper.git<br>pip install --upgrade --no-deps --force-reinstall git+https://github.com/openai/whisper.git<br></code></pre></td></tr></table></figure><p>Whisper支持的模型如下：</p><table><thead><tr><th>Size</th><th>Parameters</th><th>English-only model</th><th>Multilingual model</th><th>Required VRAM</th><th>Relative speed</th></tr></thead><tbody><tr><td>tiny</td><td>39 M</td><td><code>tiny.en</code></td><td><code>tiny</code></td><td>~1 GB</td><td>~32x</td></tr><tr><td>base</td><td>74 M</td><td><code>base.en</code></td><td><code>base</code></td><td>~1 GB</td><td>~16x</td></tr><tr><td>small</td><td>244 M</td><td><code>small.en</code></td><td><code>small</code></td><td>~2 GB</td><td>~6x</td></tr><tr><td>medium</td><td>769 M</td><td><code>medium.en</code></td><td><code>medium</code></td><td>~5 GB</td><td>~2x</td></tr><tr><td>large</td><td>1550 M</td><td>N&#x2F;A</td><td><code>large</code></td><td>~10 GB</td><td>1x</td></tr></tbody></table><p>默认是 small，这里显存还够用就选用 medium 模型来跑，亲测15分钟左右的英文录音转写大约花费2-4分钟</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">whisper audio.mp3 --model medium<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Whisper</tag>
      
      <tag>OpenAI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏札记|开始做游戏笔记</title>
    <link href="/2024/05/08/%E6%B8%B8%E6%88%8F%E6%9C%AD%E8%AE%B0-%E5%BC%80%E5%A7%8B%E5%81%9A%E6%B8%B8%E6%88%8F%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/08/%E6%B8%B8%E6%88%8F%E6%9C%AD%E8%AE%B0-%E5%BC%80%E5%A7%8B%E5%81%9A%E6%B8%B8%E6%88%8F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="从复盘记录到知识固化"><a href="#从复盘记录到知识固化" class="headerlink" title="从复盘记录到知识固化"></a>从复盘记录到知识固化</h1><blockquote><p>本文心得主要来自 <strong>Lunaticmosfet</strong> 的 <a href="https://www.bilibili.com/video/BV1MP4y1279Y">怀旧电台#14 的游戏笔记部分</a></p></blockquote><p>人类是一个善于记忆但是同时也善于遗忘的动物</p><p>游戏其实本质上和书和电影一样都值得细细品味，我们玩过的很多游戏，有的时候玩过就放掉了，虽然看似没什么问题，但是从游戏中体会到的高峰体验的闪光记忆却没有被留存下来，加之现实生活中的琐事缠身，属于游戏的体验和记忆很快就会被大脑所遗忘</p><p>如果在游戏的过程中进行记录，在每次玩游戏之后的一段时间以及通关之后进行复盘和编写 Review，那么就能最大程度发挥游戏作为第九艺术的作用</p><p>采取笔记札记的方式，可以进一步加深这些知识在大脑中的固化，让我们玩游戏的时候不仅是在打发时间，而是真正能获得游戏的乐趣。此外，在记录的同时本身也是一件充满乐趣的事情。同时，对游戏进行笔记记录，也能更好的让我们审视这个游戏，提升自己的游戏审美和判别能力</p><h1 id="游戏笔记的三种方式"><a href="#游戏笔记的三种方式" class="headerlink" title="游戏笔记的三种方式"></a>游戏笔记的三种方式</h1><p>在游玩的过程中进行笔记记录，多少都会影响沉浸感，影响不那么大的，主要有三种方式：</p><ul><li>截图</li><li>录像</li><li>录音</li></ul><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>截图这个方式是最简单的一种</p><p>但是能记录的信息往往有限</p><p>此外如果在游戏中特别的沉浸专注或者是忙不过来（比如boss战）的话，往往可能会错过截图的实机</p><h2 id="录像"><a href="#录像" class="headerlink" title="录像"></a>录像</h2><p>这种方式能记录的信息最多</p><p>但是通常情况下可能我们也不怎么看录像，在长流程视频中寻找高光时刻往往也较为困难</p><p>可以考虑结合录音的方式进行</p><h2 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h2><p>将录音和录像结合起来</p><p>在游玩的过程中产生出的自发的吐槽或者是感悟，往往也充当了高峰游戏体验的标记点</p><hr><p>在复盘的时候基于上述三种方式进行游戏笔记的记录，可以让我们在<strong>第一时间</strong>将自己一手的游戏体验以知识固化的方式留存在记忆中</p><h1 id="游戏笔记的主要内容"><a href="#游戏笔记的主要内容" class="headerlink" title="游戏笔记的主要内容"></a>游戏笔记的主要内容</h1><p>这里主要以 RPG 游戏为例，但是个人认为从第七世代开始，随着游戏开发的规模和内容体量的上升，不少的游戏就算不明显包含 RPG 的要素，也能够适用如下的法则</p><h2 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h2><p>游戏剧情中关键人物的信息，身份</p><p>你对这个人物的态度和看法，如果让你用简单几句话概括这个人物会如何描述</p><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>往往和人物有关</p><p>每一次复盘可以尝试记录游戏剧情的关键走向</p><h2 id="玩法-amp-系统"><a href="#玩法-amp-系统" class="headerlink" title="玩法&amp;系统"></a>玩法&amp;系统</h2><p>这部分的内容可能不那么容易产出</p><p>对于某些带有解密要素的游戏，也可以进行解密的攻略内容编写</p><p>初期可以尝试以杂志小编的身份编写游戏中关键关卡&#x2F;流程的破关攻略</p><p><strong>在之后游玩的过程中，循序渐进的对整个游戏核心玩法系统有了更深入的了解，尝试赏析游戏系统和用户体验交互设计的精妙之处</strong></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.824|Introduction</title>
    <link href="/2024/04/25/MIT6-824-Introduction/"/>
    <url>/2024/04/25/MIT6-824-Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="课程关注的内容"><a href="#课程关注的内容" class="headerlink" title="课程关注的内容"></a>课程关注的内容</h2><p>课程主要关注两个部分的内容：</p><ul><li>性能</li><li>容错 Fault Tolerance</li></ul><h2 id="分布式系统的抽象"><a href="#分布式系统的抽象" class="headerlink" title="分布式系统的抽象"></a>分布式系统的抽象</h2><p>这门课程讲述的都是基础架构的东西，我们针对基础架构的研究一般是包含：</p><ul><li>存储（分布式存储服务）</li><li>通信（一般都是用现成的通信模型）</li><li>计算（MapReduce 分布式计算模型）</li></ul><p>其中分布式系统的一个核心抽象目标就是：<strong>对外提供服务接口并且极大程度隐藏分布式的特性</strong>，简单来说就是：</p><p>从应用程序的角度来看，整个系统是一个非分布式的系统，就像一个文件系统或者一个大家知道如何编程的普通系统，并且有一个非常简单的模型语句。但是实际上又是一个有极高的性能和容错性的分布式系统</p><p>在学习这门课程的过程中我们会逐步体会到研究者在这一个抽象目标上所做出的努力</p><h2 id="构建分布式应用程序的常用工具"><a href="#构建分布式应用程序的常用工具" class="headerlink" title="构建分布式应用程序的常用工具"></a>构建分布式应用程序的常用工具</h2><ul><li>RPC：掩盖了我们是基于不可靠的网络进行通信的这一个事实</li><li>线程：实际上是提供给开发者操作多核心CPU的一个手段</li><li>Concurrency Control：分布式领域中常常需要解决的问题</li></ul><p>上述这些实现思想会在课程中出现，我们也会在许多论文中看到，同时也是我们在课程的实验中需要不断去关注和处理的</p><h1 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>这里说的可扩展性和我们日常讨论的软件可扩展性还是有一些细微区别的</p><p>并不是我们说的代码可扩展易于维护或者说是SPI这种组件化的开发方式便于扩展功能</p><p>而是说我们从一台计算机系统扩展到十台分布式计算机系统后，可以获得原先十倍的工作量&#x2F;十分之一的处理相同任务的时间，也就是十倍的<strong>系统吞吐量</strong>，这样的设计角度如果可以实现的话将会是十分强大的，因为我们只需要花钱来购买一定数量的计算机，相比较于花钱来聘请程序员进行软件的重构以优化性能而言，这种方式最为简单粗暴以及强大。</p><p>但是实际上在现实应用中这种情况也需要一定程度上的系统设计来确保性能的扩展提升。</p><blockquote><p>只要单台web服务器没有给数据库带来太多的压力，你可以在出现问题前添加很多web服务器，但是这种可扩展性并不是无限的。很可能在某个时间点你有了10台，20台，甚至100台web服务器，它们都在和同一个数据库通信。现在，数据库突然成为了瓶颈，并且增加更多的web服务器都无济于事了。所以很少有可以通过无限增加计算机来获取完整的可扩展性的场景。因为在某个临界点，你在系统中添加计算机的位置将不再是瓶颈了。在我们的例子中，如果你有了很多的web服务器，那么瓶颈就会转移到了别的地方，这里是从web服务器移到了数据库。</p></blockquote><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240425153146274.png" alt="DB成为系统的瓶颈了，因此需要对DB进行拆分重构构建分布式存储"></p><p>总结：在扩展性方面，我们希望能够实现随随意增加分布式系统中计算机的数目来实现等倍数的系统吞吐量，但是在实际应用中往往有多种因素的干扰（如上面的图例）因此需要进行合理的架构设计来确保扩容对于系统性能的提升</p><h1 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h1><p>容错性主要的目标主要有以下，实现的难度分别递减：</p><ul><li>可用性：系统某节点宕机但是还有副本继续提供服务</li><li>可恢复性：系统节点都宕机了，在恢复的期间内不能接受请求，但是在恢复之后仍能继续工作，并且<strong>在系统恢复前后数据仍然保持正确性</strong></li></ul><p>因此可以说 可用性的容错性&gt;可恢复性</p><p>并且，一个好的具备可用性的系统，也需要具备可恢复性，因为<strong>可用的系统仅仅是在一定的故障范围内才可用，如果故障太多，可用系统也会停止工作，停止一切响应。但是当足够的故障被修复之后，系统还是需要能继续工作</strong></p><h3 id="实现容错性的工具"><a href="#实现容错性的工具" class="headerlink" title="实现容错性的工具"></a>实现容错性的工具</h3><ul><li>采用非易失性存储：但是要避免大量读写场景，因为硬盘的写入还需要考虑转动机械臂等因素，频繁写入对性能有影响</li><li>主从复制：引入一个副本实现容错，但是<strong>副本之间的数据同步（副本管理）</strong>，drift out of sync 也是一个很棘手的问题（Lab2就需要实现一个主从复制的分布式系统模型来实现容错性）</li></ul><h1 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h1><p>以一个最简单的 KV 存储为例</p><p>假设服务器有两个副本，那么他们都有一个key-value表单，两个表单中key 1对应的值都是20</p><p>现在某个客户端发送了一个put请求，并希望将key 1改成值21。这里或许是KV服务里面的一个计数器。这个put请求发送给了第一台服务器</p><p>之后客户端的同一个请求会发送给第二台服务器，<strong>因为相同的put请求需要发送给两个副本，这样这两个副本才能保持同步</strong>。但是就在客户端准备给第二台服务器发送相同请求时，这个客户端故障了，可能是电源故障或者操作系统的bug之类的</p><p>这种情况不是我们想看到的，我们发送了一个put请求，更新了一个副本的值是21，但是另一个副本的值仍然是20</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240425162642980.png"></p><p>因此针对 KV 的 put 和 get 操作，很显然我们需要定义一些特殊的规则来实现分布式系统中的一致性，这种被定义规则的一致性，我们分为强一致性和弱一致性</p><h2 id="强一致性和弱一致性"><a href="#强一致性和弱一致性" class="headerlink" title="强一致性和弱一致性"></a>强一致性和弱一致性</h2><h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>需要<strong>牺牲性能</strong>来实现，因为强一致性的实现需要系统中<strong>节点进行频繁的通信</strong></p><p>以上述的 KV 存储为例，强一致性的实现规则可以是：每次的 GET 读取操作读取<strong>最近一次的 PUT 操作的数据</strong></p><p>具体的实现可以是：客户端轮询系统中所有的副本，比对数据的 PUT 修改时间，选择最近的一个数据作为最终的结果，这样的场景需要大量的通信，对性能造成巨大的开销</p><p>因此就引出了弱一致性</p><h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>弱一致性不保证不会读到旧数据，在上述的 KV 存储例子中，就是有可能会读取到旧的那个值为 20 的数据</p><p>在构建距离较远，系统一致性需求不强的场景下可以考虑采用弱一致性的实现</p><h3 id="尽可能避免使用强一致性的设计-amp-弱一致性也不差"><a href="#尽可能避免使用强一致性的设计-amp-弱一致性也不差" class="headerlink" title="尽可能避免使用强一致性的设计 &amp; 弱一致性也不差"></a>尽可能避免使用强一致性的设计 &amp; 弱一致性也不差</h3><p>在上面我们也提过了，强一致性的设计可能会影响系统的性能</p><p>因为分布式系统中的副本往往都不可能部署在一个机架甚至是一个机房内，因为如果实在同一个数据中心中，往往可能一挂就是都挂了，因此我们的数据副本往往会部署在多个距离很远的数据中心，随便一个通信也是超远距离的数据包传输，最少也需要几十毫秒的响应时间，<strong>现在的处理器每秒可以执行数十亿条指令，等待几十毫秒会大大影响系统的处理速度</strong></p><p>此外，在学术界以及实际应用中，有大量关于构建弱一致性保证的研究，弱一致性并不代表不一致，我们可以增加许多的约束和规则来实现弱一致性的数据保证</p><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h2 id="分布式计算任务框架需求"><a href="#分布式计算任务框架需求" class="headerlink" title="分布式计算任务框架需求"></a>分布式计算任务框架需求</h2><p>最早的时候其实是 Google 提出的一个用于解决自己建立全网网页索引需求的一个实现方案</p><p>由于全网的网页索引太多了是TB级别的海量数据，如果单机处理则需要很长的运行时间</p><p>谷歌希望能够将这些构建索引的计算任务分配到海量的计算机上进行操作，虽然当时他们完全可以编写专用的分布式系统软件来实现这一点，但是谷歌更希望能够构建出一个更为通用的分布式应用框架，让<strong>使用者无需关心具体的分布式底层通信等逻辑，只需要提供 map 和 reduce 函数</strong>，就能够将自己的分布式计算需求分配到多个计算机系统上，能够进行任意的数据分析，例如排序，网络索引器，链接分析器以及任何的运算</p><blockquote><p>使用 MapReduce 框架的工程师 只需要实现应用程序的核心，就能将应用程序运行在数千台计算机上，而<strong>不用考虑如何将运算工作分发到数千台计算机，如何组织这些计算机，如何移动数据，如何处理故障</strong>等等这些细节</p></blockquote><h2 id="MapReduce实现思路"><a href="#MapReduce实现思路" class="headerlink" title="MapReduce实现思路"></a>MapReduce实现思路</h2><p>MapReduce 分布式任务处理框架的核心实现思路就是，给用户提供编写 Map 和 Reduce 函数的接口</p><p>Google MapReduce 所执行的分布式计算会<strong>以一组键值对作为输入，输出另一组键值对，用户则通过编写 Map 函数和 Reduce 函数来指定所要进行的计算</strong></p><p>这也是函数式编程的一种应用实践</p><h2 id="MapReduce工作流程"><a href="#MapReduce工作流程" class="headerlink" title="MapReduce工作流程"></a>MapReduce工作流程</h2><p>MapReduce 的核心包含几个概念：</p><ul><li>Map Function</li><li>Intermidiate</li><li>Reduce Function</li></ul><p>我们以最简单的 Word Cound 为例来解释这些概念</p><p>假设我们海量的文档被抽象分为三个文档，他们分别包含内容：</p><ul><li>ab</li><li>b</li><li>ac</li></ul><p>Map 函数会以文件作为输入，类似的三个文档经过 Map 函数后的中间值也就是论文中说到的 Intermidiate Output 如下图</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240509151724247.png"></p><p>在之后，Map输出的所有中间变量的 key 会被作为唯一标识进行 <strong>收集</strong>，进而作为一个 list 传入 Reduce 函数中作为 Reduce 函数的输入</p><p>也就是说 Map 产生的中间变量中有几个不同的 key ，就会进行几次的 Reduce 操作</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240509152230492.png" alt="image-20240509152230492"></p><p>（需要注意的是这里的收集应当是由框架完成的，在分布式的网络环境中进行收集）</p><p>为了便于理解，下面我们讨论 Map  和 Reduce 函数的伪代码实现</p><h2 id="Map函数实现"><a href="#Map函数实现" class="headerlink" title="Map函数实现"></a>Map函数实现</h2><p>Map 函数的定义在上面的例子中第一个文档，Map的入参是：Map(file1name,”ab”)，而Map的输出则是 (a,1) (b,1)</p><p>key 为文件名，当然这个我们并不关心</p><p>value 为文件内容值 </p><p>我们关心的实现可以用如下代码概括</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Map(k,v):<br>     <span class="hljs-comment"># split into words</span><br>     <span class="hljs-keyword">for</span> each word w:<br>          emit(w,<span class="hljs-string">&quot;1&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Reduce函数实现"><a href="#Reduce函数实现" class="headerlink" title="Reduce函数实现"></a>Reduce函数实现</h2><p>Reduce 函数的入参是中间量中某一个 key（也就是字母）对应的所有实例（就算只出现了一次也要被统计）</p><p>在上面的例子中，Reduce 的入参为： <code>Reduce(&quot;a&quot;,[1,1]) Reduce(&quot;b&quot;,[1,1]) Reduce(&quot;c&quot;,[1]) </code></p><p>在这个简单的 WordCount 例子中，我们<strong>假定所有输入的内容字幕出现都不重复，因此每一个 Map key 对应的 value 都只会是1</strong></p><p>因此在 Reduce 函数中只需要计算入参的 list 的长度即可快速得出答案了，因为<strong>不重复字母的情况下默认每一个 list 元素对应的内容都是1</strong></p><p>因此 Reduce 的实现思路大致如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Reduce(k,v):<br>     emit(<span class="hljs-built_in">len</span>(v))<br></code></pre></td></tr></table></figure><h2 id="Master-amp-Worker-流程细节"><a href="#Master-amp-Worker-流程细节" class="headerlink" title="Master &amp; Worker 流程细节"></a>Master &amp; Worker 流程细节</h2><h3 id="Map批处理"><a href="#Map批处理" class="headerlink" title="Map批处理"></a>Map批处理</h3><p>在论文中提到了 MR 框架中的 Matser 和 Worker 节点，其中 Master 节点知道客户端请求中的总文件数量</p><p>在整个 Map Reduce 的过程中，Master 节点根据文件的输入总数，分配任务到 worker 节点</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/v2-add6b28c0c1632fe764271b8ad7b14fb_720w.webp" alt="论文中的MR过程图"></p><p>如果有1000台服务器，就会有1000个 worker 节点，<strong>之后 Master 节点将 Map 函数分发到不同的 worker</strong>。所以，它会向 worker 服务器发送一条消息说，请对这个输入文件执行 Map 函数吧，因此就会进行 1000 次的 Map 函数调用。</p><p><strong>worker进程还需要实现emit</strong>，每次Map函数调用emit，worker进程就会将数据写入到<strong>本地磁盘的文件</strong>中。所以，Map函数中调用emit的效果是在worker的本地磁盘上创建文件，这些文件包含了当前worker的Map函数生成的所有的key和value，也就是中间数据</p><h3 id="中间量分发"><a href="#中间量分发" class="headerlink" title="中间量分发"></a>中间量分发</h3><p>在进行Reduce过程之前，每一个worker节点会接收到 Master 节点的一个开始Reduce数据收集的指令</p><p>每一个 workder 节点都会向MapReduce集群中剩下的所有节点发消息，请求获取所有 key &#x3D; xxx 的中间数据，并发送给这个worker节点</p><h3 id="数据存储-amp-网络吞吐"><a href="#数据存储-amp-网络吞吐" class="headerlink" title="数据存储&amp;网络吞吐"></a>数据存储&amp;网络吞吐</h3><p>在前面的 Map 过程中我们提到了 worker 节点会将数据存储在本地磁盘中，但是对于海量的数据，我们更希望借助一个网络文件系统来便于数据的收发。</p><p>论文中提到的实现方式是 GFS(Google File System) 网络共享存储服务</p><p>GFS会运行在每一个 worker 节点的物理服务器上，并且针对需要进行 MapReduce 处理的大文件，已经在输入阶段被 GFS 平均分配到不同的 worker 节点上了，以一块一块的方式存储</p><p>因此对于 1000 台服务器，就会有 1000 个 worker 节点，总输入的海量数据就会被分为 1&#x2F;1000 在每一个 worker 节点上进行处理</p><p>但是这样也就存在一定的问题，那就是海量的网络开销</p><p>假设所有的输入都被分配到了 GFS 节点上，那么一开始 worker 节点为了获取输入，需要通过集群间的网络（一般都不会在内部网络）来向 GFS 请求分块数据，读取到本地进行 Map 处理。最坏的情况，假设 Map 任务和数据块都对不上，是完全 “混乱的” 。如果总输入是 10TB 的数据，那么这一次的 MapReduce 操作就会需要 10TB 的网络开销，这是不能被接受的</p><p>Google 为了解决这一个问题，<strong>设置集群中所有节点都运行 GFS 和 MapReduce任务</strong>。 <strong>Matser 节点在分配 Map 任务的时候，会去寻找集群中所有节点里，对应这个 Map 任务的数据块所在的 worker 节点，将这个任务分配给这个 worker 节点</strong>，这样在读取输入的时候，每一个 worker 节点获取到的  Map 任务所需的数据块都在本地，从而避免了网络开销</p><p>因此，获取 Map 输入的数据不需要网络通信，本地获取即可，Master 节点保证。产生中间数据也不需要网络通信，保存在本地 GFS 上。但是中间数据分发到不同的 Reduce Worker 节点的时候还是需要网络通信开销。</p><h2 id="数据Shuffle洗牌"><a href="#数据Shuffle洗牌" class="headerlink" title="数据Shuffle洗牌"></a>数据Shuffle洗牌</h2><p>正如上文所说，Reduce Worker 节点在开始之前会先收集中间数据</p><p>这些中间数据最初是 Map Worker 产生的一行一行的数据</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240518151825011.png"></p><p>但是最终在网络通信后成为了在 Reduce Worker 节点的一列一列的具有相同 key 的数据进行输入</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240518151916100.png"></p><p>论文中将这一个过程称之为 Shuffle （数据清洗&#x2F;洗牌）</p><blockquote><p>在之前描述的 MapReduce 的过程中，Reduce Worker 需要一直要等到所有的数据都获取到了才会进行 Reduce 处理，这是一种批量处理。我们也可以让 Reduce Worker 尝试通过 Stream 流水线的方式获取输入数据</p></blockquote><p>我们分析这一个阶段，就会发现有大量的网络通信</p><p>在一些场景中，Reduce 的输出结果可能会非常巨大，比如排序，比如网页索引器</p><p>10TB的输入对应的是10TB的输出</p><p>同时为了提高性能并保留容错性，数据会有2-3份副本</p><p>这意味着，不论你写什么，你总是需要通过网络将一份 Reduce 的结果数据拷贝写到2-3台服务器上</p><p>所以，这里会有大量的网络通信，这里的网络通信，是2004年限制 MapReduce 的瓶颈</p><p>而现在，在现代数据中心中，root交换机比过去快了很多</p><p>一个典型的现代数据中心网络，会有很多的root交换机而不是一个交换机（spine-leaf架构）</p><p>每个机架交换机都与每个root交换机相连，网络流量在多个root交换机之间做负载分担，所以，现代数据中心网络吞吐比之当年 Google 提出 MapReduce 的时候可以说是大多了</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240518152617090.png" alt="多交换机架构示意图"></p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT</tag>
      
      <tag>Distributed System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU 15-213|Overview &amp; Bits Representation</title>
    <link href="/2024/04/22/CMU-15-213-Overview-Bits-Representation/"/>
    <url>/2024/04/22/CMU-15-213-Overview-Bits-Representation/</url>
    
    <content type="html"><![CDATA[<h1 id="冯诺依曼架构"><a href="#冯诺依曼架构" class="headerlink" title="冯诺依曼架构"></a>冯诺依曼架构</h1><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>最经典的计算机架构，包含五个重要组成部分</p><ul><li>存储器</li><li>控制器</li><li>运算器</li><li>输入</li><li>输出</li></ul><p>现在的计算机也基本是基于这个架构的，只是运算器和控制器统一交由 CPU 来进行处理。</p><p>但是和冯诺依曼体系结构对应的当年还有一个叫做<strong>哈佛结构</strong>的：它和冯诺依曼架构最大的区别在于<strong>能够同时访问数据和指令</strong>，虽然哈佛结构很快就黯然退场了，但是如今在移动端市场流行的 ARM 架构也是由此演变而来。</p><h2 id="设计缺陷"><a href="#设计缺陷" class="headerlink" title="设计缺陷"></a>设计缺陷</h2><p>可以说如今计算机系统出现的诸多不稳定，是在冯诺依曼架构<strong>设计之初就注定的</strong>。</p><p>缓存溢出可以执行攻击者预订好的程序（游戏机设备的 jailbreak 有些就来自于此）</p><blockquote><p>甚至采用 <strong>返回导向编程</strong> 的堆栈溢出攻击，在出现之后长达十多年里，主流操作系统都毫无防范之力</p></blockquote><p>在 CSAPP 的实验中，我们将会亲自体验一番漏洞攻击，黑客模拟器XD</p><h2 id="这门课程的必要性"><a href="#这门课程的必要性" class="headerlink" title="这门课程的必要性"></a>这门课程的必要性</h2><p>程序的执行不仅仅是编写代码这么简单，代码写的好并不代表最终的执行就会正常。</p><p>我们对于一个事物的认知决定了如何更好的利用这个事物。</p><p>程序的执行除了代码本身，还需要结合内存，缓存，运算器等等部件，同时编译器，计算机系统的其他概念也会影响程序的最终执行，这门课程可以让我们从里到外的理解程序到底是如何执行的，这样才能写出更好更高效的代码。</p><h1 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h1><h2 id="无符号和有符号"><a href="#无符号和有符号" class="headerlink" title="无符号和有符号"></a>无符号和有符号</h2><p>他们所能表示的数之间的关系可以直观的看下图：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240424175947431.png"></p><p>这里其实有一种偏移 bias 的感觉，那就是如果讨论表示范围，对于同一个二进制的数据，有符号和无符号数据范围存在一定的 bias</p><p>目前主流的编程语言，默认都是有符号数，为了便于保存负数，但是 c 提供了无符号的声明形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a_signed_number = <span class="hljs-number">-15213</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a_unsigned_number = <span class="hljs-number">15213U</span>;<br></code></pre></td></tr></table></figure><h3 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h3><p>无符号数和有符号数在计算机的底层硬件表示中都是二进制存在的，只是计算机<strong>针对我们理解的无符号和有符号</strong>，<strong>解释的方式不同</strong></p><p>因此转换操作本身并不会改变二进制数据的实际内容，改变的只是<strong>计算机解释当前数值的方式</strong></p><p>在进行互相转换的时候需注意：如果同时出现有符号和无符号的运算&#x2F;比较，计算机在解释的时候会<strong>统一转化为无符号</strong>来进行解析</p><h3 id="运算和溢出"><a href="#运算和溢出" class="headerlink" title="运算和溢出"></a>运算和溢出</h3><p>无论是无符号数还是有符号数，一旦用来表示数值的最高位发生了进位&#x2F;超出了表达形式&#x2F;改变了符号位，就会发生<strong>溢出</strong></p><h4 id="无符号数溢出"><a href="#无符号数溢出" class="headerlink" title="无符号数溢出"></a>无符号数溢出</h4><p>实际上是 mod 操作，因为无符号本身并不需要牺牲一个 bit 的位置来表示符号，因此如果超出数据范围了，例如 3 bit 下， 110+111 &#x3D; 6+7 &#x3D; 13 &#x3D; 1101 ，但是由于只能存储三位，因此实际存储的数据只有 101 因此最终结果实际上只有 13%8 &#x3D; 5</p><h4 id="有符号数溢出"><a href="#有符号数溢出" class="headerlink" title="有符号数溢出"></a>有符号数溢出</h4><p>分为正溢出和负溢出两种</p><p>还是以 3 bit 举例，对于有符号数能表示的范围应当是 -4 ~ 3，以 011+010 &#x3D; 3+2 &#x3D; 5 &#x3D; 101，但是在二进制的解释下最终结果是 -4+1 &#x3D;-3，这种情况就是正溢出（<strong>我们认为的5超出了能表示的范围，虽然 bit 位数没有超出，但是有符号数解释的最高位符号位收到了影响，溢出为了负数</strong>）</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数的IEEE存储形式定义</p><h3 id="规范化值"><a href="#规范化值" class="headerlink" title="规范化值"></a>规范化值</h3><p>M默认心里有一个1，这个1不需要实际的编码位置，只需要默认心里记住</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在碎片化时代重拾注意力</title>
    <link href="/2024/04/06/%E5%9C%A8%E7%A2%8E%E7%89%87%E5%8C%96%E6%97%B6%E4%BB%A3%E9%87%8D%E6%8B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B/"/>
    <url>/2024/04/06/%E5%9C%A8%E7%A2%8E%E7%89%87%E5%8C%96%E6%97%B6%E4%BB%A3%E9%87%8D%E6%8B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.bilibili.com/video/BV14q421P7Yw">本文是 Lunaticmosfet 大佬在注意力专题中针对当前时代注意力话题的一个讨论，当作笔记心得记录同时固化学习到的方法论</a></p><h1 id="福格行为模型"><a href="#福格行为模型" class="headerlink" title="福格行为模型"></a>福格行为模型</h1><p>我们将注意力转移的过程通过一些数学表达式来刻画</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240406121023607.png"></p><p><strong>很多时候我们实际上是从一个当下自认为比较有意义的事情中，转移到一个不那么有意义的事情做去</strong></p><p>这似乎听起来不那么可能，但是实际上确实常常发生，例如经常在工作中时不时就刷手机去了，点一个外卖，点着点着就玩手机和别人聊天刷短视频去了</p><p>著名的行为设计理论:福格模型可以解释这一个现象</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240406121313783.png" alt="福格模型"></p><p>动机是执行行为的欲望，能力是做这个行为的执行能力，而提示则是指引你做出行为的一个<strong>确定的信号</strong></p><p>当动机、能力和提示同时出现的时候，行为就会发生</p><h1 id="基于福格模型的注意力转移模型"><a href="#基于福格模型的注意力转移模型" class="headerlink" title="基于福格模型的注意力转移模型"></a>基于福格模型的注意力转移模型</h1><p>为了更具体的体现出福格模型中各个变量对于行为的影响，我们假设：P的值是一个确定的信号，非0即1</p><p>那么变量λ我们可以这么刻画</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240406121715245.png"></p><h2 id="消除短效活动提示Pj"><a href="#消除短效活动提示Pj" class="headerlink" title="消除短效活动提示Pj"></a>消除短效活动提示Pj</h2><h3 id="原因分析：相当常见的场景"><a href="#原因分析：相当常见的场景" class="headerlink" title="原因分析：相当常见的场景"></a>原因分析：相当常见的场景</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240406122032135.png"></p><p>在不知不觉间，时间就被送入了黑洞，实际上这些东西你并不一定需要，更多的也是资本主义为你创造出的需求</p><p>具体关于设备需求以及消费观的讨论，可以参见<a href="https://www.bilibili.com/video/BV1Y642137Tc">这一期</a></p><h3 id="解决方案1：集中查看社交网络内容"><a href="#解决方案1：集中查看社交网络内容" class="headerlink" title="解决方案1：集中查看社交网络内容"></a>解决方案1：集中查看社交网络内容</h3><p>没有人会认为你一定需要守着一个随机出现通知的东西</p><p><strong>赛博酒馆并不会因为一个人的退场而变得不那么热闹，也不会因为一个人的入场而以他为主体</strong></p><p>可以考虑每天安排固定的时间集中观看社交网络的时间线上的信息</p><p>比较难处理的可能是工作上的信息，但是<strong>实际上这些看似紧急的，需要你立刻做出回复的信息也不需要立刻回复</strong>，因为真有急事直接找你了</p><p>同时如果自己的工作是经常需要<strong>必须放下手上正在专注的事情去立刻回复信息</strong>的话，那么可能对于自己未来职业发展有一定的局限性和影响</p><p>因此想要成为职业领域的拔尖成员，必须要具备长效专注在一件事情的能力，这也是<strong>构筑不可替代性的关键</strong></p><h3 id="解决方案2：避免现实试听提示"><a href="#解决方案2：避免现实试听提示" class="headerlink" title="解决方案2：避免现实试听提示"></a>解决方案2：避免现实试听提示</h3><p>在执行工作之前，桌面上哪些会扰乱思绪的东西尽量整理（比如 手柄，手办</p><p>在选择 BGM 的时候也不要去听哪些会引起内心波澜的游戏音乐</p><h2 id="减少短效活动的能力Aj"><a href="#减少短效活动的能力Aj" class="headerlink" title="减少短效活动的能力Aj"></a>减少短效活动的能力Aj</h2><p>旅途中 &#x3D; 断电断网，掌机启动！</p><h3 id="解决方案1：卸载"><a href="#解决方案1：卸载" class="headerlink" title="解决方案1：卸载"></a>解决方案1：卸载</h3><p>卸载哪些会影响你去做短效活动的上瘾的 app</p><h3 id="解决方案2：寻找环境"><a href="#解决方案2：寻找环境" class="headerlink" title="解决方案2：寻找环境"></a>解决方案2：寻找环境</h3><p>社会工作人士类似会去<strong>图书馆，星巴克</strong>这类的地方，为的就是环境带来的氛围，在这样的环境下，我们很难去刷手机打游戏让思绪随意飞扬</p><h2 id="减少短效活动的动机Mj"><a href="#减少短效活动的动机Mj" class="headerlink" title="减少短效活动的动机Mj"></a>减少短效活动的动机Mj</h2><p>实际上这部分还是之前说的<a href="https://www.bilibili.com/video/BV1UN411p7sp">这一期</a></p><ul><li>随机性带来的注意力涣散</li><li>时效性带来的海量无效信息</li><li>碎片性带来的必然遗忘</li></ul><h3 id="互联网生意的本质"><a href="#互联网生意的本质" class="headerlink" title="互联网生意的本质"></a>互联网生意的本质</h3><p>争夺注意力资源，个性化推送，看广告盈利</p><p>现在的很多 app 在设计之初就是为了让你上瘾</p><h3 id="监控资本主义"><a href="#监控资本主义" class="headerlink" title="监控资本主义"></a>监控资本主义</h3><p>企业对个人信息进行收集和商品化</p><p>寻找注意力的薄弱点</p><p>将争夺的注意力的资源贩卖给广告商</p><h3 id="不是抬头而是埋头"><a href="#不是抬头而是埋头" class="headerlink" title="不是抬头而是埋头"></a>不是抬头而是埋头</h3><p>和社交网络的斯金纳箱解绑</p><p>埋头专注一段时间，世界才会变化，才能自我提升，对世界也有更多的了解</p><h2 id="双线程长效活动-amp-RSS"><a href="#双线程长效活动-amp-RSS" class="headerlink" title="双线程长效活动 &amp; RSS"></a>双线程长效活动 &amp; RSS</h2><p>也可以尝试进行双线程的长效活动，例如专注工作项目结束后，专注学习新的 CS 基础课</p><p>推荐一些 RSS 聚合信息应用：</p><ul><li>Inoreader</li><li>Rss Hub</li></ul><p>也可以尝试视频网站自带的稍后再看功能</p>]]></content>
    
    
    <categories>
      
      <category>杂谈&amp;人生哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>夜读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cemu | Quick Start Guide</title>
    <link href="/2024/04/03/Cemu-Quick-Start-Guide/"/>
    <url>/2024/04/03/Cemu-Quick-Start-Guide/</url>
    
    <content type="html"><![CDATA[<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="运行前配置"><a href="#运行前配置" class="headerlink" title="运行前配置"></a>运行前配置</h2><p>去 cemu 官网下载最新的 Release 包解压运行</p><p>在开始运行之前，需要一些准备：</p><ol><li>右键单击 Cemu .exe</li><li>点击<code>属性</code></li><li>导航到选项卡<code>兼容</code></li><li>启用选项“禁用全屏优化”</li><li>点击<code>更改高 DPI 设置</code></li></ol><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240403143229348.png"></p><p>设置这些选项是为了帮助避免各种 Windows 版本和显示分辨率上的问题。也就是说，这些选项中的一个或多个并非对于每个人都是必需的，但如果不设置它们可能会导致一些问题</p><h2 id="启动初始化"><a href="#启动初始化" class="headerlink" title="启动初始化"></a>启动初始化</h2><ol><li>双击 Cemu 应用程序</li><li>现在，您将看到 Cemu 快速入门指南</li><li>首先是确定“<a href="https://cemu.cfw.guide/faq/#what-is-the-mlc01-folder">mlc01</a>”(主要是用来存储用户存档以及 dlc 安装档案等)的存储位置，默认就是在 Cemu 的根目录下，我是直接用默认，方便管理</li><li>将“游戏路径”字段留空</li><li>点击“<a href="https://cemu.cfw.guide/faq/#what-are-community-graphics-packs">下载社区图形包</a>“</li><li>点击下一步</li></ol><p>社区图形包提供了大部分游戏的图形增强，并且都是模拟器社区测试过的，基本不会有什么恶性问题</p><p>我们也可以自定义增强补丁，后面的 <a href="#%E6%B1%89%E5%8C%96%E8%A1%A5%E4%B8%81">汉化补丁</a> 中也会进行强调</p><h1 id="手柄配置"><a href="#手柄配置" class="headerlink" title="手柄配置"></a>手柄配置</h1><p>Cemu 支持手柄的体感控制，只需要在手柄设置中将手柄的 API 选择为 SDL API 即可适配体感控制</p><p>我这里使用的是 Switch Pro 手柄，亲测是完全正常的</p><blockquote><p>需要注意如果想要使用体感，模拟 WiiU 手柄则必须选择 <code>WiiU Gamepad</code> 因为只有 Gamepad 才有体感， WiiU Pro 手柄是没有体感的，即使你使用的手柄支持体感，被模拟的手柄如果不是 Gamepad 就不会有体感的效果</p></blockquote><p>后面就是一些正常的按键匹配了，我只分别用 Xbox 和 Switch Pro 手柄测试了 <code>XIput</code> 和 <code>SDL</code> 这两个 API，都是正常使用</p><h1 id="安装游戏"><a href="#安装游戏" class="headerlink" title="安装游戏"></a>安装游戏</h1><h2 id="游戏格式"><a href="#游戏格式" class="headerlink" title="游戏格式"></a>游戏格式</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240403144514829.png"></p><ul><li>WUD：实机可以直接安装的，是加密过的游戏格式，直接从光盘 Dump 出来的，模拟器需要解密才能使用</li><li>WUP格式：也是一种加密文件格式，特征是有很多.h3，.app的文件，直接从黑商店&#x2F;WiiU USB Helper 下载的格式</li><li>RPX：由 WUP 格式解密而来的格式，通常由code，content，meta三个文件夹组成，也叫loadiine格式，<strong>模拟器可以直接使用的格式</strong></li></ul><h2 id="游戏导入"><a href="#游戏导入" class="headerlink" title="游戏导入"></a>游戏导入</h2><ol><li>在顶部栏上，单击 <code>文件</code> -&gt; <code>安装档案、升级档或DLC</code></li><li>打开您要安装的游戏、更新或 DLC 的文件夹</li><li><strong>打开文件夹，然后选择 meta 文件夹即可，到这就行了</strong></li><li>Cemu 会自动安装导入</li></ol><h1 id="汉化补丁"><a href="#汉化补丁" class="headerlink" title="汉化补丁"></a>汉化补丁</h1><p>模拟器的汉化和实机不一样</p><p>实机可以通过脚本汉化或是将汉化补丁放在 SD 卡指定位置通过运行 SD Cafine  外挂汉化(我用的这一种)</p><p>但是汉化组发布的汉化补丁只有部分游戏可以支持实机的外挂汉化（例如：幻影异闻录可以运行日版光盘外挂汉化补丁，但是塞尔达风之杖和黄昏公主均无法外挂），而模拟器可以无视这些约束</p><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><p>Cemu 的汉化补丁基于 Cemu 的社区图形插件实现（你没看错，汉化补丁需要在图形插件中加载</p><p>首先找到汉化组发布的汉化补丁，大部分都以 content 命名，内部子目录因游戏而异</p><p>在 content 同级目录下创建 rules.txt 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">[Definition]<br>titleIds = 000500001019C800<br>name = CHS<br>path = <span class="hljs-string">&quot;The Legend of Zelda: Twilight Princess HD/Language/CHS&quot;</span><br>description = Note: Chinese Language Patch Made by ACG Group<br>version = 3<br></code></pre></td></tr></table></figure><p>其中 titleIds 指定汉化补丁对应的游戏 id ，不知道游戏 id 请去<a href="https://wiiubrew.org/wiki/Title_database">这里</a>查找</p><blockquote><p>注意：同一个游戏的日版和美版的 title id 不同，需要注意汉化组在发布的时候说明的汉化补丁适用哪一个版本的游戏本体</p></blockquote><p>name 指定这个补丁具体名称，想写什么都可以，这里便于管理取名 CHS</p><p>path 指定这个补丁在 Cemu 的图形插件菜单中的位置，以上述配置为例，最终会在 <code>The Legend of Zelda: Twilight Princess HD</code> 下的 <code>Language</code> 目录下的 <code>CHS</code> 中找到</p><p>description 指定插件补丁具体的描述</p><p>编写完成后将 content 目录以及 <code>rules.txt</code> 打包放入一个便于记忆名称的目录下，以我的为例，最终的目录树结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">└─The Legend of Zelda Wind Waker HD_CHS<br>    └─content<br>        └─res<br>            ├─Fontjp<br>            ├─Msgjp<br>            └─Object<br>    └─rules.txt<br></code></pre></td></tr></table></figure><p>最后将目录丢到  <code>Cemu\graphicPacks</code> 目录下</p><p>最终的目录树如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">├─graphicPacks<br>   ├─The Legend of Zelda Twilight Princess HD_CHS<br>     └─content<br>         └─res<br>             ├─Fontjp<br>             ├─Msgjp<br>             └─Object<br>     └─rules.txt<br></code></pre></td></tr></table></figure><h2 id="启用补丁"><a href="#启用补丁" class="headerlink" title="启用补丁"></a>启用补丁</h2><p>选中游戏，右键 编辑图形插件，可以看到插件就是在之前的 <code>rules.txt</code> 配置文件中描述的一样</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240403150630394.png"></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cemu</tag>
      
      <tag>Wii U</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xenia | Quick Start Guide</title>
    <link href="/2024/03/27/Xenia-Quick-Start-Guide/"/>
    <url>/2024/03/27/Xenia-Quick-Start-Guide/</url>
    
    <content type="html"><![CDATA[<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://github.com/xenia-canary/xenia-canary/releases">Releases · xenia-canary&#x2F;xenia-canary</a></p><p>Xenia 分为两个版本，一个是稳定版 master 另一个是 最新的持续更新版canary（几乎每天都在更新，需要注意的是 Canary 和 Master 是分开两个仓库进行管理的，不是分支关系）</p><blockquote><p>Xenia Canary is a fork of Xenia with changes not present in master that may or may not fix games.</p></blockquote><p>直接下载解压，得到一个 exe 文件即可</p><p>如果下载的是老版本的 Xenia，在运行游戏的时候提示存档找不到或者存储设备报错，请在 exe 文件目录同级下创建 <code>portable.txt</code> 文件</p><p>这里也推荐无论如何在运行之前都在 exe 同级目录下创建 <code>portable.txt</code> 文件，这样以后所有的系统存档都会放置在 <code>Xenia安装目录\content</code> 而不是 <code>C:\Documents\xenia\content</code></p><p>初次运行后什么也不用管直接关闭，会发现目录下多出了一个 <code>toml</code> 系统配置文件，以后所有的配置都在这里手动进行修改</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>游戏这块自己寻找备份</p><p>xbox360就算不进行破解也是可以直接备份正版游戏的，<a href="https://github.com/xenia-project/xenia/wiki/Quickstart#how-to-rip-games">具体操作见</a></p><p>需要注意的是 Xenia 只能运行 ISO 文件的游戏，大部分直接备份的格式都是 GOD 格式，因此需要 GOD2ISO 来进行转换</p><p><a href="https://github.com/raburton/god2iso/releases">Releases · raburton&#x2F;god2iso</a></p><p>具体使用也很简单，不需要选择所有的 GOD 内容，只需要选择 GOD 文件夹内同级的那个文件即可</p><p>启动游戏后可以看到游戏的编号，名称 以及模拟器 build 版本，我这里使用的是最新的 Canary Build</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/c5d6d0597855d2117d96c12fa3d76a91.png"></p><h1 id="Apply-Game-Patches"><a href="#Apply-Game-Patches" class="headerlink" title="Apply Game Patches"></a>Apply Game Patches</h1><p><a href="https://github.com/xenia-canary/game-patches">GitHub - xenia-canary&#x2F;game-patches: Game patches for the Xenia emulator</a></p><p>下载其中的 patches 文件夹，解压到同级目录</p><p>解压后具体的目录树如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">└─── Xenia Canary<br>    |  ...<br>    │  xenia_canary.exe<br>    |  ...<br>    └─── patches<br>            ...<br>            584111F7 - Minecraft (XBLA, TU0).patch.toml<br>            ...<br></code></pre></td></tr></table></figure><p>具体的使用方法，在 Xenia 的全局配置文件中，确保 <code>enable_patches = true</code> 后，进到对应需要开启补丁的游戏配置文件中，默认每一项补丁都是 <code>false</code> 关闭状态，这个时候选择想要开启的直接改为 <code>true</code> 即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">[[patch]]<br>    name = <span class="hljs-string">&quot;60 FPS&quot;</span><br>    desc = <span class="hljs-string">&quot;Description&quot;</span><br>    author = <span class="hljs-string">&quot;Author&quot;</span><br>    is_enabled = <span class="hljs-literal">false</span> <span class="hljs-comment">#这里改为 true 就是开启了</span><br><br>    [[patch.be8]]<br>        address = 0x<span class="hljs-comment">########</span><br>        value = 0x<span class="hljs-comment">##</span><br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=382YN-Ql_VI">Xenia Quick Start</a></p><p><a href="https://www.youtube.com/watch?v=kqlIqOdrLUY">如何开启补丁</a></p><p><a href="https://www.youtube.com/watch?v=m9R5nax95os">战争机器 60 帧补丁</a></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Xenia</tag>
      
      <tag>xbox360</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PS3|DualShock3 on PC</title>
    <link href="/2024/03/22/PS3-DualShock3-on-PC/"/>
    <url>/2024/03/22/PS3-DualShock3-on-PC/</url>
    
    <content type="html"><![CDATA[<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><p>DualShock3（后文简称 DS3 ）本身和 PS3 主机的连接就是基于蓝牙协议的，理论上来说其实是可以直接通过蓝牙和电脑进行连接的</p><p>但是不推荐直接通过这样的方式进行连接，会导致后续无法再通过第三方软件的协议进行连接</p><p>由于没有 PS1 和 PS2 手柄的电脑转接方案，因此 DS3 在 PC 上游玩 PS1 和 PS2 模拟器的游戏时</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Controller</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Julia</title>
    <link href="/2024/03/09/Julia/"/>
    <url>/2024/03/09/Julia/</url>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="Julia-安装"><a href="#Julia-安装" class="headerlink" title="Julia 安装"></a>Julia 安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">winget install julia -s msstore<br></code></pre></td></tr></table></figure><p>这种方式默认不会直接安装 julia 本体，而是安装 <code>juliaup</code> 管理工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看 julia 当前安装状态 </span><br>juliaup status <span class="hljs-comment">#可以看到并未安装</span><br> Default  Channel  Version  Update<br>-----------------------------------<br><span class="hljs-comment"># 查看可以安装的版本</span><br>juliaup list<br> Channel            Version<br>----------------------------------------------------<br> 0                  0.7.0+0.x64.w64.mingw32<br> 0.7                0.7.0+0.x64.w64.mingw32<br> 0.7.0              0.7.0+0.x64.w64.mingw32<br> 0.7.0~x64          0.7.0+0.x64.w64.mingw32<br> 0.7.0~x86          0.7.0+0.x86.w64.mingw32<br> 0.7~x64            0.7.0+0.x64.w64.mingw32<br> <br> <span class="hljs-comment"># 安装</span><br> julia add <span class="hljs-string">&#x27;1.10&#x27;</span><br></code></pre></td></tr></table></figure><p>之后安装好了就可以直接通过 julia 命令运行了</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240309231947971.png"></p><h2 id="Pluto-安装"><a href="#Pluto-安装" class="headerlink" title="Pluto 安装"></a>Pluto 安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#先进入 Julia</span><br>julia<br><span class="hljs-comment">#安装 Pluto.jl 所有的包和依赖，静待下载完毕</span><br>using Pkg<br>Pkg.add(<span class="hljs-string">&quot;Pluto&quot;</span>)<br><span class="hljs-comment">#启动Pluto</span><br>using Pluto<br><span class="hljs-comment">#得到如下信息</span><br>┌ Info:<br>│   Welcome to Pluto v0.19.40 🎈<br>│   Start a notebook server using:<br>│<br>│ julia&gt; Pluto.run()<br>│<br>│   Have a look at the FAQ:<br>│   https://github.com/fonsp/Pluto.jl/wiki<br><span class="hljs-comment">#启动</span><br>Pluto.run()<br></code></pre></td></tr></table></figure><p>此时会在默认浏览器中启动一个很漂亮的前端，这里就可以编写代码了</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240309232637165.png"></p><p>在终端中也可以看到对应的 INFO 以及 DEBUG 信息</p><h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><p>创建新的或者是打开已有的 notebook 后，选择这个加号插入新的代码块</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240310184114265.png"></p><p>之后就可以在代码段里编写代码了</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Julia</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tales of Eternia | 攻略心得</title>
    <link href="/2024/03/09/Tales-of-Eternia-%E6%94%BB%E7%95%A5%E5%BF%83%E5%BE%97/"/>
    <url>/2024/03/09/Tales-of-Eternia-%E6%94%BB%E7%95%A5%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="战斗相关"><a href="#战斗相关" class="headerlink" title="战斗相关"></a>战斗相关</h1><h2 id="手动和半自动"><a href="#手动和半自动" class="headerlink" title="手动和半自动"></a>手动和半自动</h2><p>手动模式的战斗操作比较灵活，防御需要自己防御，不再有自动防御，移动也是全靠自己来移动</p><p>此外战斗施法也是有全自动，手动和半自动，可以在Δ菜单中进行选择</p><h2 id="号令"><a href="#号令" class="headerlink" title="号令"></a>号令</h2><p>号令可以对<strong>全体同伴</strong>进行战斗策略指示</p><ul><li><p>比如敌人太强来听我的</p></li><li><p>或者敌人太简单，使用 TP 有点浪费</p></li></ul><p><strong>只对这一场战斗生效</strong>，并且旧的号令会被新的号令所替换</p><h3 id="作战"><a href="#作战" class="headerlink" title="作战"></a>作战</h3><p>作战位于Δ菜单中的一个单独板块，可以指定每个角色的作战策略</p><p>并且在 技·术 板块中，按下 🟦可以选择不用某个技能</p><p>这样<strong>可以保证队友一定能放出某个技能</strong></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列可以在菜单中进行选择，合适的队列有助于战斗</p><p>在战斗中按下 <code>L1</code> 可以快速变更队列</p><p>此外，按下<code>L1</code>+↓ 可以集合队列，按住就是原地不动</p><p>按下<code>L1</code>+↑ 可以控制队列跳跃</p><p>但是这些控制对于<strong>正在施法</strong>的队友而言都是无效的</p><h2 id="武器选择"><a href="#武器选择" class="headerlink" title="武器选择"></a>武器选择</h2><p>斧斩击(平A)伤害高</p><p>枪突刺(↓+O)伤害高</p><p>剑各项都很均衡</p><h3 id="战斗的连击心得"><a href="#战斗的连击心得" class="headerlink" title="战斗的连击心得"></a>战斗的连击心得</h3><p>对于主角而言，斩击——突刺——上挑 这一套下来可以进行3次连击的连招</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PS1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多设备同步hexo实现</title>
    <link href="/2024/03/09/%E5%A4%9A%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5hexo%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/03/09/%E5%A4%9A%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5hexo%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>考虑到后面上班以及回家办公可能需要记录一些东西</p><p>但是家里主要是台式机，笔记本可能会直接放公司，因此需要 <strong>在多台设备上实现 hexo 笔记的同步</strong></p><p>实现的思路也很简单，由于 hexo 部署到 github page 的时候是已经生成好了的静态页面，因此想要实现同步需要找个地方同步源文件</p><p>看了一下网上的说法是搞个新的分支，我寻思既然都新分支了，也不要放在 public 的仓库了，直接开个新仓库不就得了 XD</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>具体实现其实就是创建一个新的仓库，这里顺便也刚好复习一下新环境的 git | github | hexo 配置</p><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>首先去官网下载和安装好 git 下一步进行配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">//1、设置用户名和邮箱<br>git config --global user.name &#x27;用户名&#x27;<br>git config --global user.email &#x27;邮箱&#x27;<br>//2、查看设置的用户名与邮箱<br>git config --global user.name<br>git config --global user.email<br>//3、生成gitlab上配置的ssh公钥：<br>ssh-keygen -t rsa -C &#x27;邮箱&#x27;<br></code></pre></td></tr></table></figure><p>注意⚠️：输入命令后，三个连续的回车，表示默认存储位置、密码为空、确认密码</p><p>进入默认存储位置 (C&#x2F;用户&#x2F;当前用户名称&#x2F;.ssh目录)下，用记事本打开 <code>id_rsa.pub</code> 文件，并全选复制里面的内容到 github 的主页设置里，在 SSH 中加入即可</p><h2 id="git-提交"><a href="#git-提交" class="headerlink" title="git 提交"></a>git 提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">/*初始化一个新的Git仓库,<br>并将当前目录下的所有文件添加到Git的暂存区，最后提交到本地仓库，<br>并附上一条提交信息&quot;项目构建&quot;<br>*/<br>git init<br>git add .<br>git commit -m &quot;项目构建&quot;<br><br>/*这个命令是用来重命名当前所在的分支为&quot;main&quot;。<br>很多人创建仓库是默认分支为master,但2020年10月github官网要求要使用main，据说是为了避免政治正确的元素，彩棉场の回忆XD<br>这是因为很多人安装git的时候没有选择默认为main,而是选择默认为master<br>*/<br>git branch -M main<br><br>//先查看是否存在运程仓库(你的github仓库，git有了这个才知道往哪上传，一般返回两条命令)<br>git remote -v<br><br>//如果有且正确直接推送就好，仓库不对想换成别的就先删除再添加；如果没有就直接执行第二条来添加<br>git remote remove origin<br>git remote add origin git@github.com:你自己的用户名/你自己的仓库名.git<br><br>/*推送你的代码到远程仓库的&quot;main&quot;分支（-u 选项是 --set-upstream 的简写，<br>本地的 main 分支就会与远程仓库 origin 上的 main 分支建立起跟踪关系。<br>这意味着，以后你在该本地分支上执行 git pull、git push、git status 等命令时，<br>Git 会默认使用这个远程分支。）<br>*/<br>git push -u origin main<br><br><br>针对之后的每一次修改提交<br>//添加修改到暂存区<br>git add .<br>//提交修改到本地仓库<br>git commit -m &quot;描述你的修改&quot;<br>//推送到远程仓库<br>git push origin main<br></code></pre></td></tr></table></figure><p>在之前的旧设备上，新建仓库，关联远程仓库，推送到远程仓库即可 </p><h2 id="Node-Hexo"><a href="#Node-Hexo" class="headerlink" title="Node| Hexo"></a>Node| Hexo</h2><p>由于 Hexo 是基于 node.js 的，因此先去官网安装 Node 全套配件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br>git clone //之前新建的远程仓库blog<br>cd blog<br>npm install //根据packge.json安装依赖<br></code></pre></td></tr></table></figure><h2 id="之后的操作"><a href="#之后的操作" class="headerlink" title="之后的操作"></a>之后的操作</h2><p>之后的操作其实就是不管在那一台设备上，部署了新的文章的时候都要先 git 拉一下看看有没有更新，推送一下然后再 hexo 部署</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/weixin_52520066/article/details/135580965">2024代码上传到github,详细解释命令-CSDN博客</a></p><p><a href="https://blog.csdn.net/ChaoticNg/article/details/108337356">git入门：初始化、拉取项目、提交代码_git初始化-CSDN博客</a></p><p><a href="https://xuexuan.site/2021/02/04/hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5/">hexo博客多设备同步 | 薛轩的个人博客 (xuexuan.site)</a></p>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RetroArch | CRT shaders &amp; Bazels</title>
    <link href="/2024/03/07/RetroArch-CRT-shaders-Bazels/"/>
    <url>/2024/03/07/RetroArch-CRT-shaders-Bazels/</url>
    
    <content type="html"><![CDATA[<h1 id="RA基础教程"><a href="#RA基础教程" class="headerlink" title="RA基础教程"></a>RA基础教程</h1><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><p>1）一台能上网的电脑，<strong>最好</strong>有独显，在开启 crt shader 的时候最主要的就是显卡在渲染扫描线，后面的截图都是在 3060ti 下渲染出来的，可以参考一下</p><p>2）<strong>推荐</strong>：在显示分辨率为 4K 分辨率以上进行食用，因为<strong>更高的分辨率可以在图形后处理方面实现更多像素点上的扫面线渲染，效果更加接近 CRT 实际的效果</strong>（甚至更好）</p><hr><p>Retroarch (后文简称 RA ) 作为一个强大的模拟器前端，可以部署在多个平台，功能强大，自带快进，CRT着色器滤镜，成就系统，甚至还能联机。但是使用起来可以说不是那么好上手，所以自己也记录一下</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>去官网下载解压，选择你要的版本</p><p><a href="https://www.retroarch.com/index.php?page=platforms">RetroArch</a></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240309112611189.png"></p><p>不推荐 steam 直接下载，因为为了上架 steam 商店，很多模拟器核心缺失下载不到</p><p>点开后第一件事情先调中文</p><p><code>Settings-User-Language : Simplified Chinese</code></p><h2 id="下载核心"><a href="#下载核心" class="headerlink" title="下载核心"></a>下载核心</h2><p>RA 中的核心其实就是模拟器本体，RA 作为前端管理多个核心</p><p><code>菜单-在线更新-核心下载-选择你想要的模拟器核心</code></p><h2 id="配置BIOS"><a href="#配置BIOS" class="headerlink" title="配置BIOS"></a>配置BIOS</h2><p>模拟器运行所必须的 BIOS 默认放在 retroarch&#x2F;system 文件夹下</p><p>部分需要额外配置的（如 PS2 模拟器 BIOS 参见官方文档）<a href="https://docs.libretro.com/library/pcsx2/#other-required-files-and-directories">PS2模拟器其他一些需要的文件</a></p><h2 id="游戏导入"><a href="#游戏导入" class="headerlink" title="游戏导入"></a>游戏导入</h2><p>准备好游戏 ROM </p><p>选择菜单的 导入-手动扫描</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240309110313549.png"></p><p>这里说一下系统名称，这里的系统名称简单来说就是合集名称，在系统名称里可以选择对应平台名称来作为合集名称，比如 Sony-Playstation</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240309110651322.png"></p><p>最后点最下方的开始扫描即可</p><p>扫描之后就可以在菜单中看到之前选择的合集名称以及所对应的游戏列表</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240309110528138.png"></p><h1 id="RA自带的shaders-overlay"><a href="#RA自带的shaders-overlay" class="headerlink" title="RA自带的shaders+overlay"></a>RA自带的shaders+overlay</h1><p>RA其实是有自带 shader 以及 overlays 的，具体的效果其实也不差</p><p>这里简单说一下如何使用自带的 overlay + shader</p><p><code>RA 主菜单-在线更新-更新遮罩-更新 Slang 着色器</code></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240307173653541.png"></p><p>更新下载完毕之后，通过 <code>主页设置-驱动-视频</code> 中确认一下当前 RA 使用的图形后端 API 是哪一种（后面用的上），我一直用的是 vulkan</p><p>之后进入游戏内 F1 呼出主菜单，拉到最下方选择你想要的 shaders 以及 overlays 即可</p><h2 id="Shaders"><a href="#Shaders" class="headerlink" title="Shaders"></a>Shaders</h2><p>选择 overlays 注意需要根据自己 RA 所使用的后端图形 API 来进行选择，openGL 的选择 glsl 目录下的，vulkan 选择 slang 目录下的</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240307173237796.png"></p><p>shaders里 对于硬件较好的朋友首推 <code>crt-royale</code> ，仿真效果极好，参数细节可以进行调整</p><p>具体的 Shaders 这一块参数以及选用，可以参考 <a href="https://www.bilibili.com/read/cv3065212">Lunamos 大佬的文章</a></p><p>如果硬件渲染压力过大，推荐降低使用分辨率或者是换用配置需求更低的 shaders</p><h2 id="Overlays"><a href="#Overlays" class="headerlink" title="Overlays"></a>Overlays</h2><p><code>F1-遮罩-遮罩预设</code></p><p>之后进文件夹选择你想要的屏幕遮罩</p><p>在遮住大黑边的同时还能起到装饰效果，甚至有的遮罩带有触摸效果，鼠标点击遮罩的图标 可以直接映射到手柄动作</p><p>配合上面选择的 shaders 效果更佳</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240307173904227.png"></p><p>这里我嫌懒用的核显笔记本截图，配置带不动 <code>crt-royale</code> 因此选择了效果差一点的预设 <code>crt-easymode</code>，效果其实也不错，凑合够用</p><h1 id="使用-MEGA-Bazel-实现-CRT-滤镜-反射边框"><a href="#使用-MEGA-Bazel-实现-CRT-滤镜-反射边框" class="headerlink" title="使用 MEGA Bazel 实现 CRT 滤镜+反射边框"></a>使用 MEGA Bazel 实现 CRT 滤镜+反射边框</h1><h2 id="材料准备-1"><a href="#材料准备-1" class="headerlink" title="材料准备"></a>材料准备</h2><p><code>RA 菜单-在线更新-更新 Slang 着色器</code></p><p>去 github 下载最新的 release， 第一个是适配各种游戏主机的电视边框，另一个是各种老电视的背景边框</p><ul><li><a href="https://github.com/Duimon/Duimon-Mega-Bezel/releases/">Releases · Duimon&#x2F;Duimon-Mega-Bezel</a></li><li><a href="https://github.com/soqueroeu/Soqueroeu-TV-Backgrounds_V2.0">soqueroeu&#x2F;Soqueroeu-TV-Backgrounds_V2.0</a></li></ul><p>解压压缩包内容到 <code>retroarch/shaders</code> 目录下</p><h2 id="修改-RA-配置"><a href="#修改-RA-配置" class="headerlink" title="修改 RA 配置"></a>修改 RA 配置</h2><p>打开 RA 菜单</p><p><code>设置-界面-显示高级设置：开</code></p><p><code>设置-视频-缩放-宽高比：全双工，整数缩放：关</code></p><p><code>设置-视频-输出-屏幕旋转：正常</code></p><p><code>设置-核心-允许旋转：关闭</code></p><h2 id="游戏内开启"><a href="#游戏内开启" class="headerlink" title="游戏内开启"></a>游戏内开启</h2><p>至此所有配置已经结束，进游戏内还是按下 F1 呼出主菜单，拉到最下方选择 着色器，可以看到刚刚解压好的两个文件夹</p><p>Duimon-Mega-Bezel 涵盖了很多主机的老电视效果以及 CRT 扫描线滤镜</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RetroArch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PS1|レガイア伝説 攻略</title>
    <link href="/2024/02/29/PS1-%E3%83%AC%E3%82%AC%E3%82%A4%E3%82%A2%E4%BC%9D%E8%AA%AC-%E5%89%A7%E6%83%85%E5%B0%8F%E8%AF%B4/"/>
    <url>/2024/02/29/PS1-%E3%83%AC%E3%82%AC%E3%82%A4%E3%82%A2%E4%BC%9D%E8%AA%AC-%E5%89%A7%E6%83%85%E5%B0%8F%E8%AF%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="流程攻略"><a href="#流程攻略" class="headerlink" title="流程攻略"></a>流程攻略</h1><h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><p>  天、地、海．．．．．神在創造了天地萬物於這個世界後，便創造了用來支配這個世界的人類．．．</p><p>　神雖然賜予人類高度的智慧，但是在人類的肉體不如其它生物的情況下，擁有智慧的人類開始對於自己的未來感到不安！</p><p>　為了消除與其它生物的不平之處，人類利用自己的智慧開始補抓被稱為「獸」的生物來做為人類的左右手．．．</p><p>　果然此舉使人類的生活起了重大的變化也更加鞏固人類是支配者的權力，但是．．這種看似和平的生活卻沒維持多久．．</p><p>　一天、不知從何而來的霧氣瀰漫在這整個世界，在濃霧的壟罩下習日聽從人類命令的「獸」竟對人類展開一連串的攻擊，<br>也開始進入了人類歷史上所謂的黑暗時代．．．</p><p>  而故事就由一個靠海的小村莊リム．エルム開始展開了～～</p><p>【リム．エルム村】</p><p>  明天就是成為正式獵人的日子了，ヴァン（Ｗｅｎ）來到他最喜歡的創世樹前，接著到海邊跟トツド學武術，照著他所講的一步一步照做即可學到一項新技能，對於村人的道賀及美麗的メイ姊還要幫自己做一套獵人的服裝，Ｗｅｎ更告訴自己明天的試練一定要成功才不會辜負村人的好意．．．</p><p>  ＰＳ：在創世樹旁有此村的地圖<br>    ヴァン的家─與父親ヴァル及妹妹ネネ居住的家<br>    リブロ與メイ的家─獵人リブロ和他女兒メイ居住的家<br>記憶的像─在洞窟中有可供記憶的像<br>  創世樹─種植在村子中央的大樹</p><p>  到壁外狩獵的獵人都回來了，但是メイ姊的父親リブロ卻不幸遇害了，在安慰メイ姊後便回家休息．．但在晚上一個自稱是ゼトㄧ的人竟率領「獸」破壞壁使得霧也漫進了這個村子！</p><p>  先到メイ的家帶メイ到自己家中後來到創世樹前，在摸了創世術後聽到聖獸メㄧタ的聲音，メㄧタ說想要消除霧就要靠人得心，接著得到可吸收獸之力的腕輪，回家後集合村人來到創世樹前果然藉著眾人之心與創世樹結合的力量消除了霧．．．</p><p>  次日在舉行了簡單但不失隆重的葬禮後，三副棺木就順著海水的波浪緩緩漂向那傳說中的安息之地ノアル谷．．．．</p><p>　而村長則要Ｗｅｎ前往バイロン寺院將此事告訴メイ在那工做的母親エイミ，不過已經１０年沒有エイミ的消息了．．希望バイロン寺院沒遭到破壞才好，不然メイ真是太可憐了．．</p><p>【回復之泉】</p><p>  離開村子往左來到回復之泉邊見到獵人們，由レザム口中得知他是奉了ドルク王的命令來此調查霧入侵事件的使者，現在此地的霧雖已經消失不過ドルク王城卻被霧給包圍住了．．</p><p>　由其它的獵人口中得知往北過河後再一直往東北前進就可以到達バイロン寺院，但是河流上遊的水門鑰匙是在ドルク王手中，看來得先到北邊的ドルク王城跟ドルク王拿水門鑰匙了！</p><p>【ドルク城】</p><p>  到左邊的房中取得旭日之鍵（注意閃著亮光的地方）然後再用旭日之鍵打開中央房間的門上樓．．</p><p>  上樓後到右邊的房中取得雷光之鍵（注意閃著亮光的地方）然後再用雷光之鍵打開中央房間的門上樓（記得看書櫃的書）</p><p>  上樓後到右邊的房中取得星辰之鍵（注意閃著亮光的地方）由右邊書櫃的書可知在ドルク城北方的リクロア山頂上有一棵創世樹，而左邊書櫃的書可知在霧出現前所發生的一些怪事，然後再用星辰之鍵打開中央房間的門上樓．．</p><p>  上樓後到下邊的中央的大廳，在右邊的房間可以休息，而在左邊房間可見到ドルク王Ⅲ世所寫的親筆信及取得山門之鍵，至於被關起來的怪物就是ドルク王本人，因為水門之鍵就懸掛在他的脖子上，由他的親筆信來看可能是被怪物化了．．用山門之鍵開門後即可來到ドルク城的後山．．．</p><p>  往前走到リクロア山後メㄧタ忽然感應到在前方不遠的地方有聖獸存在，同時也感應到Ｗｅｎ的同伴也在那．．．</p><p>【ふきだまりの洞窟】</p><p>  與好友テルマ（狼）生活在一起的諾雅（ノア）在惡夢驚醒後便跟著テルマ往前走，途中テルマ忽說要試驗諾雅的成度，便問在霧出現後對於那兩種生物影響（當然是「獸」與人間）再往前走テルマ又問要利用什麼來消除霧（當然是創世樹了）至於離此地最近的一棵創世樹又是在那裡呢？（リクロア山）</p><p>  打了幾隻洞中的小怪物後再與テルマ交談就可準備吃飯了，不過此時霧竟漫進這個了原本與外界隔絕的洞窟，テルマ一看不對便要諾雅快經由洞口前往創世樹所在的リクロア山！</p><p>【リクロア山】</p><p>  來到洞窟打倒石頭人時洞窟崩塌了，來到山頂過然看到創世樹，但是這時ゼトㄧ出現在上空．．而他還召喚出カルバヌス來攻擊テルマ及諾雅，正當危急時Ｗｅｎ與メㄧタ趕到了．．</p><p>　在Ｗｅｎ與諾雅的合力之下終於順利打倒了カルバヌス，藉著リクロア山創世樹的覺醒不但消除了鄰近的霧讓ドルク城中的人們恢復正常，也使得メㄧタ的力量提升了．．</p><p>  在將聖獸的力量交給諾雅後テルマ便拖著沉重的步伐離開此地，諾雅本想追上前去但是メㄧタ告知狼是一種會自己前往安息之處的生物後，諾雅便跟著Ｗｅｎ回到ドルク城．．．</p><p>【ドルク城】</p><p>  回到ドルク城後ドルク王Ⅲ世得知Ｗｅｎ旅行的目的是為了前往バイロン寺院找將メイ的母親エイミ，於是他便將可打開水門的水門之鍵交給Ｗｅｎ．同時ドルク王Ⅲ世還請Ｗｅｎ及諾雅如果可以的話就消除全部的霧解救這世界上的所有人類！</p><p>  由城中的人口中得知在這個大陸上一共有四棵創世樹，除了在リム．エルム村及リクロア山的兩棵創世樹以外，另兩顆創世樹分別是在バイロン寺院及北之森．．而在東北方的盆地有個被稱為霧之巢的地方，據說霧最早就是從那個地方流出來再漫延到其它地區的．．在廣場有許多攤販，只要好好回答諾雅所問的問題就可以得到一些道具．．</p><p>【バイロン寺院】</p><p>  往東北走來到洞窟中扳動開關便可進入バイロン寺院，在見過住持ゾッブ老後走到樓上便見到一名酷似メイ的婦人興匆匆地跑了過來，那位婦女果然是メイ的母親エイミ！</p><p>　看著エイミ高興見到Ｗｅｎ的模樣，實在不知道要如何開口告訴她リブロ所發生的事．．看來只好等晚上再告訴她了．．</p><p>  見過ゾッブ老後宴會也開始了，不過エイミ在得知リブロ已經離開人世之後便掩著臉哭哭啼啼地跑回房中．．</p><p>  由ソンギ口中得知在此地確實有創世樹的存在，不過正確的所在地只有ゾッブ老才知道，而另一位大禪師則是因父母俱喪命於「獸」之手，所以他總是以厭惡的態度對待Ｗｅｎ等人！</p><p>　接著ゾッブ老知道了エイミ難過的原因，於是他便請Ｗｅｎ務必保護エイミ平安地回到リム．エルム村．．</p><p>　之後ゾッブ也順便請Ｗｅｎ讓沉睡於此的創世樹覺醒，但是連他也不確定創世樹是在西北方的西ヴォズ樹林中還是在東北<br>方的東ヴォズ樹林之中，於是決定兩批人馬分開尋找．．</p><p>　原本想前往位於東北方的東ヴォズ樹林，但是ソンギ卻持反對意見，只好到西北方的西ヴォズ樹林了．．．</p><p>　在ソンギ帶著一些人前往東北方的東ヴォズ樹林後，Ｗｅｎ這一邊便和大禪師─凱拉一起前往西北方的西ヴォズ樹林．．</p><p>【西北方的西ヴォズ樹林】</p><p>  將開寶箱撿到的肥草水澆在河邊的ハシワタリ的小樹苗上，沒多久這株ハシワタリ便長大了．．（超級肥料嗎？）</p><p>  來到深處見到的竟是枯死的創世樹，不過也拿到了聖獸卵，但此時從バイロン寺院所在的地點卻傳來巨響及火光．．</p><p>【バイロン寺院】</p><p>  趕回來後卻發現霧已經漫進バイロン寺院之中，找到エイミ時卻發現她已經受到霧的影響而被怪物化了，據テルマ所說的知道想要讓她恢復的話就要讓東ヴォズ樹林中的創世樹覺醒，</p><p>　見到ゾッブ老後得知是ソンギ率領「獸」攻進此地，來到通往東ヴォズ的門前找到凱拉，而他也打算找ソンギ問清到底是發生什麼事，於是一夥人便前往東北方的東ヴォズ樹林．．</p><p>【東北方的東ヴォズ樹林】</p><p>  用在樹林中撿到的碎草のこづち可以將水晶草給剪掉，一直來到深處果然看見創世樹，不過當Ｗｅｎ準備使創世樹覺醒的時候，獲得力量而心性大變的ソンギ出現了，由於之前與凱拉的約定，只好不干預他們兩人之間的決鬥．．</p><p>　但凱拉並不是獲得獸之力的ソンギ對手，在ソンギ離開後也讓創世樹覺醒了，同時藉著三棵創世樹的力量使得霧之巢的力量大為降低，之後凱拉也繼承了聖獸オズマ的力量．．接著回到バイロン寺院休息後後接下來要做的便是到霧之巢．．</p><p>【霧之巢】</p><p>  進入霧之巢利用電梯來到ゼトㄧ的穴居城，途中將ソンギ打跑了後就可到底層，在那將ゼトㄧ打倒後三人便合力終於將製造霧來污染ドルク王國的霧之巢給破壞掉了．．</p><p>  回到バイロン寺院後為了追蹤ソンギ的下落及解救カリスト皇國的人民，三人決定一起前往北方的セブクス群島．．</p><p>【風タ老の洞窟】</p><p>  往北首先來到風タ老所住的洞窟，扳動左邊房中的機關就可將右邊的門打開，之後走到更裡面可來到水タ婆住的地方．．</p><p>【水タ婆の洞窟】</p><p>　住宿於此的時候會在夢中聽到ハリィ的聲音，ハリィ告知眾人在セブクス群島的中央有個很古老的古都─オクタム．．</p><p>  從夢中醒過來後發覺三人都做了相同的夢，由小孩子口中得知出了洞窟往西北走可到達有不可思議大樹的ジェレミの町，而右上角的少女則告知她的母親曾告訴她傳說在セブクス群島住著ハリィ（ときの獸神）但她並不曉得什麼是オクタム．．</p><p>【ジェレミの町】</p><p>  離開洞窟往西北前進果然來到有空中庭園的ジェレミの町，不過這個地方已經是怪物橫行的地方了．．<br>　在鎮中央的告示牌標示著：　</p><p>北─空中庭園<br>東─よらず屋<br>北西─ジェレミ觀光ホテル</p><p>  進入北邊的空中庭園，當來到四角都有升降梯的地方時，在此進入左上便可到樓上打開高速電梯的動力，而利用左下的電<br>梯到樓上再往下走出去便可來到空中庭園．．</p><p>　不料居然有隻「獸」セキアス正在啃噬著創世樹的力量，將它打倒後便可讓創世樹覺醒也使得ジェレミの町重見光明．．</p><p>  搭高速電梯來到樓下見到鎮長後慶祝大會也開始了，休息一晚由村人口中得知在鎮上住著一位叫ザラン的寶石職人，此外<br>在北邊的かなた山也有一棵創世樹．．</p><p>　來到左下的房子見到心事重重的ザラン，一問之下才知他的妻子ユア以及兒子ペペ都在ウィドナ，所以便託Ｗｅｎ將一封信帶到ウィドナ交給他的妻兒，離開ジェレミの町之後往北走便可以到達世界第一的保養聖地─ウィドナ（風車鎮）</p><p>【ウィドナ】</p><p>  在鎮上花錢便可跟此地的導遊打聽到オクタム及ハリィ的一些情報，除了得知オクタム就位於ウィドナ北邊以外，也可以知道ハリィ是供奉在オクタム的レム神殿中的神明．．．<br>  在鎮上可聽到孩子唱歌：<br>星は　　靜かに泣いてます<br>月は　さやかに笑いてます<br>夢の小舟　浮かベたち<br>銀河の海を  わたります<br>ほら、　ごらん<br>あれが　トㄧンの門<br>ハリィがいるよ<br>ハリィの心は　ひとつだけれど<br>ハリィは　三つの顏を持つ<br>ハリィは　三つの口を持つ<br>ハリィは　三つの夢をみる</p><p>  由サシア口中得知在霧尚未發生前ハリィ已經預知會有三位年輕人來拯救世界，並交待サシア一定要讓這三位年輕人到レム神殿見見這四卷神託之書，不過如果要前往オクタム人避難的居住地─オクタム地下遺跡的話得先拿到星之真珠才行．．</p><p>　在鎮上有個叫ダンパス的人，他總是認為鎮上的風車可能會壞掉兒導至霧瀰漫進來，所以他早早就顧人在地底挖掘了一個避難室，甚至連食物及飲用水都準備好了．．</p><p>  將信交給ペペ後可得ユア的指輪，再回到ジェレミ見ザラン便可以拿到ザラン之冠，接著來準備要到オクタム的レム神殿了！</p><p>【オクタム】</p><p>  來到オクタム後發現這就是夢中所見到的地方，在房中可以見到一本導遊手冊，上頭寫著─<br>　　トㄧンの門（由オクタム往北走再往東前進可到達）<br>風來獸車（在セブクス群島上作為交通工具設施）<br>オクタム（位於セブクス群島正中央的千年古都）<br>レム神殿（在セブクス群島上有９９個島、３３處溫泉以及１１座山，傳說地獸神レム在地底沉睡著，<br>　　而這座レム神殿內所供奉的就是地獸神レム）<br>  進入レム神殿來到裡面可見到四個巨大的石像，在這四個石像的下方各別放著四塊不同顏色石頭，在石頭上還刻著一些字．．<br>  黃　石─「北の門、そのかぎは  ＜地＞　」<br>  藍　石─「南の門、そのかぎは  ＜水＞　」<br>  紅　石─「西の門、そのかぎは  ＜火＞　」<br>  綠　石─「東の門、そのかぎは  ＜風＞　」<br>  而在四邊的臺子上也有神託之書．．．<br>  左　上─「神託の書　第一卷」<br>    寫的是霧的起因及霧對生物的影響<br>  右　上─「神託の書　第二卷」<br>    寫的是要勇者前往トㄧンの門<br>  左　下─「神託の書　第三卷」<br>    寫的是讓石花打開的方法跟那四個石像有關<br>  右　下─「神託の書　第四卷」<br>    寫的是要拿在神殿得到的星之真珠進入石花</p><p>在讀完這四冊神託之書後通往レム神殿地底的路便出現了．．</p><p>  順著樓梯來到下面卻遇上來此尋寶的女盜賊卡拉，由卡拉口中得知星之真珠早就被她偷走並賣給寶石職人ザラン了．．</p><p>【ジェレミの町】</p><p>  回到ジェレミ跟ザラン問有關星之真珠的事，想不到他居然大方的表示他留著這東西也沒用，便將星之真珠送給我們．．</p><p>【トㄧンの門】</p><p>  剛進入トㄧンの門就遇到一位自稱是ギ．デリラ的忍者前來說要一對一的對決，不過又跳出來兩個人，分別是ル．デリラ以及チェ．デリラ，而他們又稱江湖上的デリラ三兄妹．．</p><p>  但是ギ．デリラ說今天臨時有事，所以改天再前來討教，說完這デリラ三兄妹便消失了蹤影．．（來鬧場的嗎？－ˍ－）</p><p>  還記得レム神殿中那四個巨大的石像前不同顏色的石頭嗎？</p><p>在石頭上有刻著一些字．．<br>  黃　石─「北の門、そのかぎは　  　＜地＞　」<br>  藍　石─「南の門、そのかぎは  　　＜水＞　」<br>  紅　石─「西の門、そのかぎは  　　＜火＞　」<br>  綠　石─「東の門、そのかぎは  　　＜風＞　」<br>  而在這邊的四個巨大的石像前也有一些字．．．<br>  左　上─「　北　のかぎに觸れよ」─＜地＞<br>  左　下─「　西　のかぎに觸れよ」  ＜火＞<br>  右　下─「　東　のかぎに觸れよ」  ＜風＞<br>  右　下─「　南　のかぎに觸れよ」  ＜水＞</p><p>  在石花打開後將星之真珠投到小洞中就可進入內部，一直往裡面走去便可來到オクタム地下遺跡．．．</p><p>【オクタム地下遺跡】</p><p>  走沒多久卻發生地震，而且デポラ的家也崩塌了，所幸並無人傷亡，由居民口中的知ハリィ已經沉睡五年了，據說只有擁有神獸之力的人到達此地，ハリィ才會清醒過來．．</p><p>　來到ハリィ的寢宮（瞑想宮）想看看ハリィ時卻被一旁的人擋住，在拜訪市長時後他一直自責自己是個無能的市長，就在見完市長準備下樓時士兵前來稟告說ハリィ已經醒過來了．．</p><p>  再次到瞑想宮由過去的紫色ハリィ、現在的綠色ハリィ以及未來的紅色ハリィ口中得知許多得事情，其中也得知諾雅的雙親還活著而且就住在カリスト皇國的コンクラム，但是ハリィ還提醒諾雅當見到雙親時千萬要小心．．至於凱拉心中最掛念的不外乎是ソンギ的事了，ハリィ也提到並要凱拉將ソンギ由惡夢之中拯救出來，但是ハリィ也提醒凱拉要小心．．．</p><p>  由市長口中得知ハリィ剛剛提到的炎熱海道就位在地下遺跡西北方的洞窟之中，剛一走到瞑想宮之外後又發生地震，原本想進入瞑想宮將ハリィ給救出來卻遭到凱拉的阻擋，只好先行逃開但也眼睜睜看著瞑想宮沒入地底去了．．</p><p>【炎熱海道】</p><p>  進入洞窟一直走來到炎熱海道後利用浮石移動，忽然看見一隻牛頭怪ブルテリオ，將它打倒後可得到風之奧義書２，但是它在臨走前居然將此地變成了一片冰天雪地．．</p><p>  回地下遺跡見市長後得知高速電梯可以使用了，利用高速電梯一下子就回到了オクタム．．．</p><p>【ウィドナ】</p><p>  回到ウィドナ後發現因地底的熔炎冷卻使得用來阻擋霧侵入的風車停止了作用，也使得ウィドナ遭到霧的入侵．．</p><p>  到火力動力室可拿到湯波丸，而在沙灘上則可撿到一副釣竿以及釣魚用的魚餌．．．忽然想到ダンパス不是預先做了避難室嗎？來到避難室果然見到村人都躲在這，但是ダンパス自己卻不見了，由サシア口中得知霧是從西北方飄過來的．．．</p><p>【ラタイユ】</p><p>  來到西北方的ラタイユ後便感到創世樹的存在，由告示牌得知往北可到ラタイユ宮殿、東邊是レトナ山、往右則是西海！</p><p>　雖然感覺到創世樹就在東邊，可是通往レトナ山的路需要有領主ボン．セルジュ所持有的鑰匙才可開啟．．只好先前往宮殿了，但在旅館的桌上發現一張字條，得知領主挑選了一名叫做エリザ的女孩要獻給「獸」做為新娘．．（天啊．．～）</p><p>  進到王宮見領主ボン．セルジュ，沒想到他居然不受影響，他除了將通往レトナ山所需要的レトナ之鍵交給Ｗｅｎ以外還說等霧消失後「獸」的花嫁將會開始，而他也會將一把開啟通往西海通道的ラタイユ西門之鍵送給Ｗｅｎ當做謝禮．．</p><p>【レトナ山】</p><p>  到達山頂時才發現創世樹被結界給封住，打算離去時ソンギ卻迎面走了過來，原來結界是他搞的鬼，這時ソンギ大言不慚的說他一個人就可以打倒我們三人，還說只要能夠打倒他的話那他就將結界給解除！哼～可惡！去死吧！</p><p>  將ソンギ打倒後可得到雷之奧義書２，雖然他是個討厭的傢伙不過他倒是蠻守信用的，果然將結界給解除掉！</p><p>  在創世樹覺醒之後，終於讓ラタイユ的霧給消除掉了，這下子肯定讓霧之巢的力量削弱不少，該去對付霧之巢了．．</p><p>【ラタイユ】</p><p>  回到ラタイユ卻發現居民對領主ボン．セルジュ怨聲載道，而且他還強迫城中的女孩要嫁給「獸」做為新娘．．</p><p>　來到旅館見到即將要出嫁的エリザ，在討論後決定由諾雅代替エリザ做為「獸」的新娘．．被帶到王宮深處的諾雅發現這根本就是把女孩子送給領主的寵物ジゃガㄧノㄧト當食物嘛！</p><p>  諾雅正想逃跑時領主ボン．セルジュ他卻帶士兵追了過來，不敵的諾雅立刻被他們給抓回去了．．此時メㄧタ收到テルマ的通知立刻要Ｗｅｎ及凱拉出發準備救人去了．．</p><p>【ラタイユ宮殿】</p><p>  進到宮中打倒守門的地獸ケマロ後便可進入ジゃガㄧノㄧト所在的地方並救到諾雅，接下來．．嘿嘿！</p><p>  將領主ボン．セルジュ打倒後一隻獸從ボン．セルジュ的身上離去了，至於ボン．セルジュ也恢復了意識．．</p><p>　由他口中得知ドハティ利用變異體控制他，而ドハティ現在就在西南的霧之巢，接著他便把ラタイユ西門之鍵交給我們！</p><p>  此時那些女孩都平安回來了，到旅館可學到奧義也可免費睡覺，在夢中諾雅聽到了父母的聲音．．</p><p>  次日便利用ラタイユ西門之鍵前往西南的ドハティ海王城！</p><p>【ドハティの海王城 】</p><p>  進入ドハティ海王城後一直來到最頂層果然見到霧之巢，但是就在我們想靠近時ドハティ卻出現了，他說他不但是コㄧト的使徒也是セブクス的統治者．．在打倒他之後，他居然說之前就是ジゃガㄧノㄧト去破壞リム．エルム村、ちっぽけな洞窟以及バイロン寺院．．這三個Ｗｅｎ三人的出身地．．</p><p>【ラタイユ宮殿】</p><p>  由領主ボン．セルジュ口中得知想要前往コンクラム，就必需到オクタム搭乘カリスト皇國特有的交通工具─風來獸車，接著還可跟領主ボン．セルジュ拿到一把可開啟ラタイユ城地下的兇獸之間的兇獸之間之鍵，到兇獸之間可拿到兇獸符．．</p><p>【ウィドナ】</p><p>  可以跟一名男子買到攝像石，而此時的ダンパス已經成為全村的英雄了．．但是卻沒見到ペペ，由村人口中得知ペペ他已經回到故鄉ジェレミの町去見父親ザラン了．．</p><p>  來到ジェレミの町ザラン的家可從ペペ口中得知東カリスト皇國的人民尚未脫離霧的影響．．</p><p>【オクタム】</p><p>  將撿到的湯波丸交給市長可得到鈍重的首飾，由酒館中的人口中可知東カリスト皇國有巨大都市─ソル之町以及「獸」的產地─ウル．メイス，接著就到車站搭電梯到頂樓的搭乘處搭風來獸車前往東カリスト皇國．．．不過因為出了點小問題，三人幾乎是被扔到東カリスト皇國．．</p><p>  當清醒過來時竟見到女盜賊卡拉，之後空中出現一座大空城四處飛來飛去，由卡拉口中得知霧之巢就在大空城之中．．</p><p>  由告示牌得知巨大都市ソル之中有諸多遊樂設?</p><p>  在東部溪谷旁的ブブゴルド之町中有創世樹</p><p>  而ウル．メイス就是「獸」的產地</p><p>  ニルボア溪谷則位於ブブゴルド之町的北邊</p><p>【階層都市ソル─下階層】</p><p>  往北進入巨大都市─ソル後，メㄧタ卻說他感覺到尚有人類存活於這個狀似死城的巨大都市之中，或許是因為這個都市的建築物實在是太高了，導至霧尚未侵襲到上面的地方．?</p><p>  來到最底層可見到一臺「賢者的番犬」而在一旁的控制室，在控制室裡面的機器面板上刻著幾行字：<br>  　　「戰士の廣場を　めざすもの、<br>　　賢者の飢えん　いやすベし、<br>    　　されば、賢者の門は開いかれる<br>　飢えた賢者は<br>  　のこり、８なり！    」<br>  往上走途中見到一位老劍士，他一見到Ｗｅｎ等人也嚇了一跳連忙擺好架勢說要除掉我們這群怪物．．看來他是誤會了！</p><p>　在跟他解釋清楚後得知他的名字是蓋塞魯，不過他一見到諾雅卻換她為瑪魯這個名字，但隨即他又喃喃自語道不可能是瑪魯，因為瑪魯已經不存在於這世上．．他一定是老眼昏花了～</p><p>【階層都市ソル─上階層】</p><p>  再往上走便來到沒有霧的上階層（也是享樂的天堂）在旅館的水族箱中標示著裡面的魚是「幻の超高級魚ボルテック」，睡覺時諾雅又夢到雙親了，而他們還自認是霧起因的元兇．．</p><p>　由旅館的客人那得知霧是在與コンクラム的戰爭中發生的，經過十多年的戰爭後コンクラム戰敗了，不過從那時候起在空中就出現那座大空城，而從大空城中開始流出無數的霧．．．</p><p>  來到酒館見到卡拉及グランタス，在卡拉離去後可以跟客人打聽消息，得知ソㄧン族的人擁有可在空中飛的獸之翼，一天一位ソㄧン族的年輕人不小心遺落了ソㄧン之笛，在他找了好久都找不到的情況下，那個年輕人忽然聽到有人吹奏ソㄧン之笛的聲音，當他順著聲音來到ブブゴルド之町後發現吹笛的是一位人間的少女，漸漸的兩人談起了被嚴格禁止的戀情．．</p><p>  在遊樂場中可用１００個代幣換到ソロンパン（波羅麵包）而用５０個代幣可換到迪斯可舞廳的入場證！</p><p>  用入場證進入舞廳花５００元可參加舞蹈比賽，到三丁目劇場看相聲時到後臺凱拉便會上臺，之後到麵包店得知賢者最喜歡吃ソロンパン（波羅麵包）但是一個要６０００元，實在太貴了，但為了見到賢者只好給它買下來（至少要買８個喔～）</p><p>  來到頂樓的バイロン聖堂見到デイズ老，デイズ老擋住三人並說此地有バイロン的武僧才能進入，這時凱拉告訴デイズ老自己是バイロン教ゾッブ老的門下，但是デイズ老並不相信，為了取信於デイズ老，凱拉便秀了一手武術，デイズ老馬上就認出凱拉所施展的正是バイロン僧術中的七の段，他立刻相信凱拉的確是バイロン教的人，而放三人進入バイロン聖堂．．</p><p>  聽了凱拉三人所說的話後，デイズ老便將バイロン聖堂所持有的創世樹樹苗拿了出來，並告知這株樹苗是在１００年前從位於地底深處的戰士廣場中，那棵枯萎的創世樹之中發現的，之後便將它拿到聖堂中受到顏密的保護，如今就要是將這株樹苗帶到地底的戰士廣場讓它成長成創世樹以消滅此地的霧．．</p><p>  來到聖堂外卻見到蓋塞魯怒氣匆匆的走了過來，他氣呼呼的要Ｗｅｎ等人將樹苗扔掉，接著他便向Ｗｅｎ等人攻了過來！</p><p>　在打倒這個頑固的老頭子後，ソンギ又出現了，他一邊嘲笑凱拉居然連人類也開始殺害後一邊假腥腥的說他今天就大發慈悲把這個可憐的老人家救走好了，說完蓋塞魯便被他帶走了～</p><p>【階層都市ソル─下階層】</p><p>  再次到下階層調查那些賢者寶箱，並將那８個賢者寶箱所要求想吃的ソロンパン（波羅麵包）餵給它們，在８個都餵過後<br>進入底層的控制臺調查面板就可見到賢者─杜曼博士的幻影，而他也要Ｗｅｎ等人快將創世樹的樹苗送到戰士廣場．．．</p><p>　因為那尊「賢者的番犬」已經滾一邊去了，所以很順利的便來到戰士廣場，將兩邊的機關都扳開使中央的榨欄移開後，一行人也來到了戰士廣場正中央那唯一有土壤的地方．．</p><p>  不料正要將創世樹的樹苗種下去的時候ソンギ又出現了，當諾雅氣急敗壞地詢問他蓋塞魯老爺爺被他帶到那邊後，ソンギ卻冷笑著回頭要蓋塞魯準備出來見客了．．</p><p>　在蓋塞魯出現在三人面前時他身邊卻跟著一隻變異體的獸，而ソンギ在臨走前還說有了變異體，你們不死也很難了～～</p><p>　好不容易將與變異體合體的蓋塞魯打倒後，蓋塞魯雖然恢復了意識但是他也差不多了，最後決定讓他的魂破寄宿於創世樹之中，隨著創世樹的覺醒階層都市ソル也復興了．．而Ｗｅｎ也繼承了蓋塞魯的星撞斬牙刀，裝備上後果然是強力武器．．</p><p>  由ソル的皇帝エトラ８世口中得知１０年前杜曼博士曾告訴過他將來的事，而那時他也一直記著○○△Ｘ□這個密碼，之後他告訴Ｗｅｎ想要打倒大空城前要先與杜曼博士見面．．</p><p>【ブブゴルド之町】</p><p>  來到ブブゴルド之町所見到的卻是因過度結凍而毫無生機的創世樹，而且不管如何努力還是一點辦法也沒有，此時諾雅想起卡拉也擁有聖獸之力，或許此地的聖獸卵被她先行取走了！</p><p>【杜曼博士研究所】</p><p>  來到杜曼博士研究所對著風管說話然後輸入○○△Ｘ□這個密碼後就可見到杜曼博士了，杜曼博士告知如果想讓ニルボア溪谷的冰熔化的話要有時空爆彈，但是記載時空爆彈做法的古文書是被放在ウル．メイス，所以接著要前往ウル．メイス！</p><p>  到樓下見杜曼夫人通過試驗，就可拿到開啟ウル．メイス之門的いせき之鍵，離開研究所往西北前進．．</p><p>【ウル．メイス】</p><p>　來到ウル．メイス到祭壇上後再進入周圍的洞窟之中，那洞窟中三人分別來到屬於自己的夢境之中．．</p><p>　在Ｗｅｎ的夢境中，他回到自己小時候為了救病重的母親?而偷偷跑出壁外前往ドルク城想求取據說可治病的ドルク水，但是擔心他跟著追出去的父親卻為了救他而失去一條腿，為此在Ｗｅｎ心中對父親一直有著很深的自責．．</p><p>　在諾雅的夢境中，她的雙親是コンクラム的統治者ネビュラ大公及ミネア公妃，在她出世沒多久コンクラム便被霧給破壞殆盡，為了保全諾雅的性命她的母親ミネア公妃，便將諾雅託付給一位ソㄧン族的戰士，但是在途經ふきだまりの洞窟上方的時候，那位ソㄧン族戰士卻因體力不支而與諾雅一起自空中掉了下來，而命大沒死的諾雅便被テルマ給收養了．．</p><p>　在凱拉的夢境中，在一次與ソンギ的試合對決前夕，他明明知道ソンギ拿給他吃的東西其實是毒草，但是凱拉並不想傷害與ソンギ的友情，所以還是吃了下去．．甚至到了事後，他也不去拆穿ソンギ的真面目．．凱拉應該是個善良的人吧．．</p><p>  此時ティㄧグ終於現形了並將火のしずく送給Ｗｅｎ三人，但是在離開時那個神出鬼沒的ジゃガㄧノㄧト卻毀了這地方！</p><p>  而這時卡拉出現了，她告訴三人如果我們能夠讓ブブゴルド之町的創世樹覺醒的話，那她就會將聖獸卵交給我們．．</p><p>【杜曼博士研究所】</p><p>  回到杜曼博士研究將火のしずく交給博士製造時空爆彈，在做好之後博士便將４個時空爆彈交給Ｗｅｎ等人並說第１個是用來炸ニルボア溪谷入口處的冰塊，另三個則是由每一個人要分別帶一個去闖內部的雷之洞門、火之洞門以及風之洞門，等在裡面集合時三人再同時用三顆時空爆彈去轟炸ブリズマ．．</p><p>【ニルボア溪谷】</p><p>  進入ニルボア溪谷用時空爆彈炸開入口處的冰塊後就可進入洞窟中，來到三叉路時就分開行動（按□來轉換三人的行動）</p><p>　當三人都來到ブリズマ的所在地，當正準備放置時空爆彈的時候デリラ三兄妹出現了．．就在凱拉對付チェ．デリラ、諾雅對付ル．デリラ及Ｗｅｎ對付ギ．デリラ的情況下將他們給一個個打倒了．．（這デリラ三兄妹果然來鬧場的！＞ˍ＜）</p><p>  之後用時空爆彈將ブリズマ給炸下山谷,不過卻也讓還沒有死的デリラ三兄妹有和ブリズマ合體的機會．．</p><p>  真是受不了了，怎麼能讓來鬧場的デリラ三兄妹去破壞這個國家哩！當然是立刻跳下山谷把這隻新生的ブリズマ打死了！隨著ブリズマ的滅亡，壟罩著ブブゴルド之町的冰也融化了！</p><p>【ブブゴルド之町】</p><p>  回到ブブゴルド之町合力使三棵創世樹覺醒，正準備離去時卡拉出現了，也得知她並沒有聖獸之卵．．</p><p>　接著空中忽然飛過三個ソㄧン族的人，他們大概是飛過來看看ブブゴルド之町這三棵覺醒的的創世樹吧．．</p><p>　之後卡拉將グランタス為她所做的ふるぴた樂譜交給諾雅，接著她便拜託我們彈奏這首曲子給酒館中的グランタス聽．．</p><p>  由居民口中得知グランタス原來是ソㄧン族的人，但是他因為做錯事而被施以奪去獸之翼的處罰．．</p><p>【階層都市ソル─上階層】</p><p>  到酒館請樂手彈奏ふるぴた樂譜，此舉果然打動グランタス冰封已久的心，而他也決定回ブブゴルド之町見卡拉．．</p><p>【ブブゴルド之町】</p><p>  來到ブブゴルド之町左上方卡拉的家，正好見到グランタス以及卡拉，而此時グランタス也將他為何會被奪去「獸之翼」的原因告訴三人，原來身為ソㄧン族的他正為了無法與卡拉相戀而苦惱時，大空城的女城主ゾラ就對グランタス說只要他能夠幫ゾラ做一件事的話，那他就會賜予卡拉一對「獸之翼」</p><p>  那時グランタス相信了ゾラ所說的話便幫他來到ブブゴルド之町竊取此地的聖獸卵，因為ブブゴルド之町聖獸卵有三顆，所以グランタス便把其中一顆送給了卡拉當禮物．．</p><p>　不過ゾラ在拿到其它的聖獸卵之後，並沒有遵守將獸之翼給卡拉的約定，ゾラ那傢伙還將這件事告訴グランタス的族人，結果他就被施以奪去獸之翼的處罰而掉到地面上，這１０年來幸好有卡拉在照顧他，不然他實在不知道自己會變得如何．．</p><p>  在得知Ｗｅｎ等人想與ソㄧン族的人見面後，グランタス便將一支可叫來ソㄧン族的ソㄧン族之笛交給三人，並交待著一定要到西北方ソㄧン族聖地的ディㄧネ山頂吹奏才有效果．．</p><p>【ディㄧネ山】</p><p>  因為身上帶著ソㄧン族的ソㄧン族之笛就可以進入山中，一直往上走來到山頂吹奏ソㄧン族之笛後，在一陣笛聲過後空中果然飛來了一群身後有獸之翼的ソㄧン族人．．</p><p>  不過帶頭的レクタス在一聽完諾雅說我們手邊的ソㄧン族之笛是グランタス所給的之後，他卻說グランタス是背叛者已經不是ソㄧン族的人了，而要我們快離開這個ソㄧン族的聖地！</p><p>  此時凱拉便破口大罵レクタス，不料レクタス卻翻臉了．．他俯衝下來說我們所說的話已經嚴重侮辱了ソㄧン族，他還說會處罰グランタス的原因是因為他間接幫助大空城的建造．．</p><p>  在得知Ｗｅｎ等人是想借ソㄧン族的力量去消滅位在大空城之中的霧之巢後，レクタス與其它ソㄧン族人討論過後，決定帶Ｗｅｎ等人到ソㄧン族的部落キャンプ去見長老．．．</p><p>【ソㄧン族部落キャンプ】</p><p>  由族人口中得知レクタス以及グランタス都是長老カクタス的兒子，他們兩兄弟的感情一直很好，但是グランタス後來卻愛上了一名叫做卡拉的人類女子，之後グランタス所做的事被族人知道後，他就被奪去獸之翼並丟到充滿霧的人間了．．．</p><p>　而ソㄧン族並不是一生下來就擁有獸之翼的，這對獸之翼是要經過一種神密的儀式後才會生出來．．到宿屋休息時在夢中可以得知這一切事件的幕後主使者叫做コㄧ．．（コㄧト？）</p><p>  見到長老カクタス後他答應協助Ｗｅｎ等人前往大空城，來到廣場找レクタス便可以借ソㄧン族之力前往空中的大空城！</p><p>【大空城】</p><p>  進入大空城後一直走到某個有大蓋子的房間，將牆上的開關啟動後蓋子就會打開，而調查中央的骨骸可得到翼人秘帖．．</p><p>  將玉座之間前的兩個機關扳動後往玉座之間的門即會打開，而在玉座之間卻沒見任何人．．只見到在王座之後有幾扇門，但是卻苦於沒有鑰匙，在討論後決定先找到門的鑰匙．．</p><p>　正準備走出玉座之間時一名很像是ソㄧン族的女子走進來，來的人不是別人正是我們苦尋不著的大空城女城主ゾラ！</p><p>  將她打倒後ソンギ又來了，他一邊嘲笑ゾラ是年老不中用，在另一方面竟說對付這種門要用什麼鑰匙便將門給毀掉，接著他便大搖大擺地走進去，我們見狀也立刻追了進去．．</p><p>　不過已經來遲了一步ソンギ勿已經將霧之巢給破壞掉並奪取了此地的聖獸，此時失去動力的大空城開始要墜落了．．</p><p>　在６分鐘內逃到外面後便可被レクタス等人救回キャンプ～</p><p>【ソㄧン族部落キャンプ】</p><p>  由カクタス長老口中得知經過調查得知目前在カリスト山脈北方的コンクラム還有一個霧之巢，相信只要將它給破壞掉那霧就會完全消滅，而他也下令レクタス送三人到コンクラム！</p><p>  將先前拿到的翼人秘帖交給右上角的ソㄧン族，之後便可以由レクタス送三人來到コンクラム所在的北部山脈．．但是因為那地方尚有大量的霧所以特地拿了降落傘讓三人裝上，等來到コンクラム上空時，Ｗｅｎ三人再張開降落傘落到地面．．</p><p>【コンクラム】</p><p>  一進入コンクラム就感到四周怪怪的，渾濁的天空伴隨著陣陣蠕動的地表，任誰也不相信這裡曾是被眾人公認為稱為美麗之都的コンクラム，不過諾雅卻是一臉亢奮的表情接著她還聽到旁邊傳來人的聲音，循聲找去見到的是融入壁面的男子．．</p><p>　當諾雅急著要將那名男子拉出來時卻被チルマ給阻止了，原來此地的建物、人類都已經與變異體合為一體了，所以當把這男子強行拉出璧面後，那這名男子也會立刻死掉的．．</p><p>  進入王宮來到裡面竟見到諾雅的母親ミネア公妃，已經失明的她也已經融入變異體之中，但是ミネア公妃還是希望諾雅能早日到ジッツ的絕對要塞將霧之巢給破壞掉．．</p><p>　但是想要進入絕對要塞的話，就要先攻破在入口那扇用古代物質打造而成的地獄門，而ネメシス之玉就是對付古代物質一定要有的東西，但長久以來一直都遍尋不到ネメシス之玉．．</p><p>　於是ミネア公妃便要諾雅等人立刻到王宮的地下室去見她的父親ネビュラ大公，並利用獸之炎回到過去的世界尋找．．</p><p>  來到地下見ネビュラ大公後便拿著獸之炎到鏡屋中使用，在用鏡之炎將火把點燃後在鏡中便出現了過去的景像，走進鏡子經歷一段長時間的時空飛行後終於來到了過去．．</p><p>【過去的コンクラム】</p><p>  在王宮中見到外務大臣ドハティ、內務大臣ゼトㄧ以及擔任親衛隊的デリラ三兄妹，而神聖祭司ゾラ則告訴我們ネメシス之玉是屬於國家級機密物質，而ジッツ則是宮廷科學家．．</p><p>　來到旅館可見到杜曼博士，他也是為了明天要舉行的新武器發表會而來的，至於住宿費原本要１００００元，但是老闆說明天是大日子所以特地免費招待三人住宿．．（有詐喔～）</p><p>　來到コㄧト王子（ネビュラ大公之子！？諾雅的哥哥！？）的新武器發表會上見到ネビュラ大公及有身孕的ミネア公妃！但是臨時卻發生問題造成大量的霧外洩．．趕到王宮地下室的研究所發現霧所流出的洞口是直通到獸界的ルㄧジ之塔，商量後決定先斬斷源頭便跳下洞口．．準備去打倒邪獸ルㄧジ．．</p><p>【ルㄧジ之塔】</p><p>  在第２層時要將左上及右下的獸都打倒才可前往下一階層，在第３層時用注意四周的變化，也是要打倒獸才可往下一層，來到頂層將ルㄧジ給打碎之後ルㄧジ之塔也崩塌了，接著三人在聖獸的協助下回到了コンクラム，而此時霧也消失了．．</p><p>【過去的コンクラム】</p><p>  回コンクラム見到ネビュラ大公在罵コㄧト，不過因為身旁有ジッツ及ゾラ的慫恿，コㄧト決定暗中完成這偉大的計劃！</p><p>  為了感謝Ｗｅｎ等人的協助，ネビュラ大公決定將ネメシス之玉送給Ｗｅｎ等人，但是コㄧト還是很不高興就對了．．</p><p>  來到屋頂見ミネア公妃可拿到一枚ミネア的戒指，而ミネア公妃也語重心長的希望Ｗｅｎ等人能夠救救她那因為過度熱心於研究コンクラム的新兵器而變得怪怪的好兒子コㄧト．．</p><p>  之後來到鏡屋再次利用獸之炎回到了現在的コンクラム．．接著便往北前往コㄧト以及ジッツ所在的絕對要塞．．</p><p>【絕對要塞】</p><p>  利用ネメシス之玉將地獄門打破後就可進入絕對要塞，途中我們發現了一座湖，再往前走便見到ジゃガㄧノㄧト在湖中，再往前走來到控制室，將左邊的開關扳動後準備離去時ジッツ出現了，將他打倒後記得要把左邊的開關再扳回來．．</p><p>  當準備將霧之巢破壞掉時，諾雅的頭卻痛了起來，而コㄧト也一步一步向我們逼進，看著他亂噁心地叫我可愛的妹妹．．當他用防護罩時一直用必殺技可把防護罩打破，但是最惡劣的還是兇獸召喚了．．打倒他之後此地也開始崩塌，用逃的或用風之扉都可以，接著就跳下大洞逃命去了．．</p><p>　一到外面就看到卡拉，之後グランタス也飛過來了，原來長老已經原諒グランタス並賜予他新的獸之翼，不過グランタス表示他已經決定與卡拉一起在ブブゴルド之町生活了．．．</p><p>  再回到コンクラム看到的只是一片沙漠．．</p><p>【リム．エルム村】</p><p>  回到村子與眾人交談過後再到村長家找諾雅，此時ソンギ卻出現在這個村子並且還告知ジゃガㄧノㄧト不但還沒被消滅，而且它還跟コㄧト合體了，之後ジゃガㄧノㄧト的勢力也併吞了リム．エルム村，為了救人決定由ウル．メイス前往獸界！</p><p>【ウル．メイス】</p><p>　來到ウル．メイス到祭壇上叫出ティㄧグ後，ティㄧグ便為我們開了往獸界的通道，而經由此通道我們也來到了獸界．．</p><p>【獸界】</p><p>　一直走來到提供聖獸之力的創世大樹前，發現ソンギ他正在吸收創世大樹的力量，之後ソンギ才告訴三人他本身也跟獸合體了，在將ソンギ打倒後因為與他合體的獸已經消失所以連他也一起消失了，但是創世大樹卻也因力量耗盡而逐漸枯死．．</p><p>　在三人的祈求之下在オクタム地下遺跡掉落山谷的ハリィ又出現了，在眾人的合力之下創世大樹蛻掉了乾枯的外皮而從內部長出了一棵更加翠綠的大樹．．終於獸界又復甦了．．</p><p>【リム．エルム村】</p><p>  回村子利用創世大樹的力量打開缺口後即可進入生物城．．</p><p>【生物城】</p><p>  一路走到最裡面打倒最兇獸コㄧト後，聖獸們決定為這世界盡一份心力，於是在聖獸們的合作之下ウル．メイス恢復了～</p><p>  　而Ｗｅｎ與メイ也決定一起出外旅行．．</p><h1 id="剧情小说"><a href="#剧情小说" class="headerlink" title="剧情小说"></a>剧情小说</h1><h2 id="创世树"><a href="#创世树" class="headerlink" title="创世树"></a>创世树</h2><p>「獸」（獣）本該是由人類們所使用，能幫助人類，並與動物們心靈相通。但卻出現了神祕的「霧」，霧改變了獸，使得獸的性情變的狂暴且充滿攻擊性，人類生活因此遭受迫害，遭受攻擊的人類受邪惡的獸的入侵精神，也變成怪物。大陸上幾乎已經佈滿著霧，沒有人知道為什麼會有霧的出現，也沒有人知道該如何阻止這場浩劫。</p><p>故事發生在受霧所侵擾多年後的世界。少年梵（ヴァン）生活在多魯克王領（ドルク王領）的最南方靠近海岸的邊榆村（リム・エルム），與父親華爾（ヴァル）以及妹妹寧寧（ネネ）一同生活著。邊榆村是由巨大高聳的「壁」所保護著不被霧所影響的村子。村子裡頭有著一棵充滿著乾淨氣息的樹，稱為創世樹。創世樹因為某種緣故而無法盛開茂盛，雖然沒有實際上的用途，卻仍為村子帶來平緩心靈的效果。梵從小便常站在創世樹前靜靜凝望著。</p><p>就在梵即將成為獵人的前一天，梵在創世樹前默默祈禱著自己能夠成功的成為獵人，一同長大的梅（メイ）特地為梵量了身體尺寸，打算做一件獵人裝，在梵成為獵人的時候送給他穿。接著梵便去找常常待在岸邊練功的托德（トツド）切磋武技。托德是在拜倫寺院（バイロン寺院）出身的武僧，經常指導梵的武技。接近傍晚，外頭打獵的獵人們回來時，有一名獵人不幸地遭獸的攻擊而死亡，那名獵人正巧是梅的父親利普羅（リブロ）…梅感到十分的傷心。</p><p>當天深夜，外頭傳出奇怪的聲音，梵依照父親的意思到外頭看看。沒想到出現了一名自稱賽特（ゼトー）的可怕人物。他說著要將福音「霧」給人類，此時外頭突然出現巨大無比的魔獸，將保護村子的壁給破壞掉，在村外的霧也隨之飄入村中。獸從外頭不斷湧入攻擊著村民們，而人也一個個受影響漸漸的變成怪物。梵無力的看著村民遭到獸的攻擊，只能先帶著梅進入自己家中。似乎是內心有所共鳴，梵獨自一人走向村中央的創世樹。觸摸到創世樹的剎那，樹內突然傳出一道聲音，那道聲音說明自己是「聖獸」梅達（《聖獣》メータ），需要梵接受牠的力量才可以對抗狂暴的獸。梵沒有多加考慮地接受了梅達的力量，寄宿在梵右手聖獸之力，讓梵一一趨滅了村中的獸群，並將獸之力化為自己的力量。梵依照梅達的指示將村民們帶到創世樹旁，祈禱著創世樹能夠甦醒，就在梵將聖獸之力注入創世樹的那刻，創世樹奇蹟似地發出光芒，然後開始長出枝葉，變茁壯茂盛。村子附近的獸被創世樹的聖氣所籠罩後消失、村外的霧也被驅散。得到這股力量的梵，在梅達的說明下，明白外頭的世界仍有很多也都遭受霧所迫害的人們，單單靠邊榆村的創世樹的力量是不夠的，所以梵決定一一的去解放世界各地已枯萎的創世樹群。</p><p>隔天，眾人為昨晚死去的獵人及其他人舉行葬禮，梵便準備出發了。出發前村長告訴梵，希望在這旅途中能夠順便尋找梅的母親艾咪（エイミ），十年前由於艾咪在拜倫寺院工作時，因為霧的侵擾沒有辦法回來這裡，至此便音訊全無。村長也希望這件事梵能夠對梅保密，因為梅才失去父親不久。在離開村子前，梅將約定好要送梵的獵人裝給了梵，要他小心，一定要平安回來，她會一直等著的…</p><h2 id="狼少女"><a href="#狼少女" class="headerlink" title="狼少女"></a>狼少女</h2><p>梵離開了邊榆村，沿著河路一路往大陸的西北方前進，目的地是多魯克王領的多魯克城（ドルク城）。進入多魯克城內部已經遍滿著霧，城牢內關著已獸化的人們，梵從一旁書櫃信中得知，原來這些怪物都是城內的人民轉變成的，其中也包括多魯克國王（ドルク王）。自知已經將被獸所附身而即將獸化，命令眾人將自己關入牢內城內…由於並沒有發現創世樹，梵暫時沒有辦法解救這群人，從多魯克城後方的山門離開，一路前進到里克洛亞山（リクロア山）。剛踏入里克洛亞山，梅達即刻感應到山頂也有自己同伴聖獸的氣息，要梵趕緊前進。</p><p>一名少女由睡夢中驚醒，因為她又再次夢見了母親…一隻會說人語的狼安慰著少女，要她好好記住這個夢，這個夢將指引她的未來。少女的名字叫做諾亞（ノア），她與這頭曉通人語的狼－帝瑪（テルマ）生活在位於多魯克王領最西北方的深山的洞窟（吹きだまりの洞窟）裡，由於地理環境，讓洞窟奇蹟的不受霧所影響。亞諾是由帝瑪所撫養長大，從帝瑪口中學會人類的語言、戰鬥的技巧。雖然諾亞從小生活就不如小孩般的幸福，性情卻像小孩般地天真無邪。</p><p>一如往昔地，帝瑪帶著諾亞到深處去練習武技，帝瑪頻出問題考驗著諾亞，想要確認諾亞是否已經具備基礎的知識、足夠保護自己的安全。在諾亞通過問題後便開始練功了。諾亞輕盈的身子飛快地打敗了山內的地鼠獸群，讓牠都躲在地洞內不敢上來了…諾亞嚷嚷著餓了，正當狼要帶著諾亞去匿食的時候，突然一股天搖地動…就在地震結束後，洞外竟然飄進了霧…原來是剛剛因地震的影響使得洞窟遭到破壞，帝瑪驚呼著這正陣風可能會將霧吹向南方里克洛亞山頂的創世樹，如此後果不堪設想，便趕緊帶著諾亞離開了洞窟，進入里克洛亞山。</p><p>在里克洛亞山下的洞窟內，不時的發生劇烈地震，上頭的岩石頻頻崩落，已經沒有辦法回去了…諾亞如此想著。雖然如此諾亞還是緊緊跟著帝瑪。在前方出現了巨大的石頭巨人，諾亞和帝瑪合力擊倒後，來到了一處平地，帝瑪似乎相當的疲倦，要諾亞稍等。這個時候帝瑪向諾亞坦承，狼本該是不能說人語的，能夠說話的緣故是因為自己是獸，一隻附著在老狼身體裡的聖獸。因為這頭狼的壽命已經到了盡頭，帝瑪已經沒有辦法再繼續以這頭狼的姿態來守護著諾亞，所以才帶著諾亞到里克洛亞山，要以創世樹為媒介進入諾亞體內（…帝瑪是女性）。休息片刻後，帝瑪帶著諾亞繼續前進，到了山頂。</p><p>看到創世樹，帝瑪不由的感嘆當時本來只有自己待在創世樹內靜靜沉睡著，因為諾亞的哭鬧聲將自己給吵醒，因為當時諾亞身體還太小，無法附在上頭，才會附在老狼身上。眼看創世樹就在眼前，塞特又出現了。塞特無奈笑說要是帝瑪乖乖的成為霧與獸的手下，便不必如此辛苦還得保護人類了…說完便招喚出一頭巨大可怕的翼獅卡巴努斯（カルバヌス）飛上前攻擊帝瑪。但帝瑪附在體內的狼已經衰老將盡，馬上便被卡巴努斯打的趴倒在地，諾亞趕緊上前去保護著帝瑪。塞特笑道要卡巴努斯趕快把眼前的小女孩給撕碎後便離去了。此時一名少年突然出現擋住了卡巴努斯的攻擊。帝瑪馬上感應到了是梅達，並隨即明白這名少年正是梅達現在的主人。但此時仍心繫諾亞安危，希望梵與梅達能夠幫助諾亞。似乎是予天的默契，梵與諾亞合作輕鬆的擊敗了卡巴努斯。梵與諾亞依照帝瑪的請求將狼搬到創世樹旁，兩人合力將聖獸之力注入在創世樹中，如同邊榆村的創世樹，創世樹奇蹟似的長出枝葉，成為一棵茂盛茁壯的大樹。四周圍的霧為之驅散，多魯克城內的人們也恢復了人性。而帝瑪也順利的轉移依附在諾亞左手上。</p><p>帝瑪希望諾亞能和梵在一塊，一同踏上尋找創世樹的旅程，即使會很辛苦，但是請別忘記，牠會一直陪伴在諾亞身旁。帝瑪所依附的老狼，自知生命將盡，緩緩拖著倦怠的身子離開，準備在別的地方默默的等待生命的消逝。最後諾亞好奇的問梵能不能和他在一起，梵很快的點頭同意了，諾亞興奮的如同小孩般的跳躍著，喊著諾亞不會寂寞了，諾亞和梵在一塊了～</p><h2 id="僧兵伽藍"><a href="#僧兵伽藍" class="headerlink" title="僧兵伽藍"></a>僧兵伽藍</h2><p>（伽藍，有僧眾所居住的園林之意）</p><p>梵與諾亞回到了已經恢復正常的多魯克城，諾亞聽到城內有許多人類的聲音，既緊張又興奮的問梵該怎麼辦，畢竟她除了梵以外，不曾與人類接觸過…梵笑著安撫諾亞不需要擔心。諾亞這時候才安心的想有梵在身邊就不用擔心了！入城後便看到多魯克國王－多魯克三世（ドルク王Ⅲ世）正迎接著兩人，他表示非常感激梵與諾亞消除城四周的霧。接著多魯克三世得知梵為了找尋梅的母親，必須通過河流才到達的了拜倫寺院，便馬上喚人將水門鑰匙交給了梵。在梵準備離去時，多魯克三世表示他瞭解梵這趟旅程的目的，但這世界上仍有絕大多處的地方仍籠罩在霧之中，被聖獸所選上的兩人，應該有著更神聖重要的使命…即使他非常感謝梵救了邊榆村與多魯克城，但若是霧沒真正消失，那麼人們便沒有真正的得救…諾亞昨天才理解到什麼是悲傷的事情，她嚷嚷著她討厭悲傷，不喜歡悲劇！所以要梵去打敗霧，這樣就不會有悲劇了！看到諾亞的表現，多魯克總算是安心多了，便祈禱他們一路小心。</p><p>離開了多魯克城，梵與諾亞來到了城外的市場。看著聚集許多人們的諾亞不禁看的呆了，非常的興奮愉悅，便獨自跑去和大家說話。後來諾亞搞懂拿了別人的東西需要付錢；回復果實是用來療傷的；宿屋是用來睡覺和休息的地方…非常滿足對梵說，能夠和這麼多人說話，是諾亞沒有經歷嘗試過的事情…</p><p>關閉了水門，河水漸漸的乾竭，梵他們順利的通過了河道來到對面。走了一段路後便到了拜倫寺院。然而拜倫寺院前卻也已經佈滿了霧…後來梵發現原來寺內有設置抽風系統（真先進XD），開啟抽風裝置後進入寺院的大門就會開啟。進入寺院後，便看到眾多的僧兵正在習武，梵和寺院的長老索普（ゾッブ）介紹自己的身分與來意，索普決定舉辦宴會好好招待兩人便離開了。一旁自稱索基（ソンギ）的紅髮男子突然跑來，笑著問道梵與諾亞手上的是不是「獸」，臉上的表情充滿著羨幕。接著梵在寺院裡找尋艾咪時，沒想到突然一個與梅相同髮色的女人高興的抓著梵，才得知這個女人就是梅的母親艾咪，艾咪先是驚訝她離開村子那年梵還只是個小孩，現在卻已經長的這麼大了，而且長的很像他的父親！然後興奮的說沒想到梵真的會跑來找她，當年因為霧的關係沒辦法回去邊榆村，以為這輩子都沒辦法回去了…說完艾咪就笑著又跑去忙了。由於艾咪非常的高興，梵找不到機會和艾咪說明邊榆村發生了什麼事情…諾亞很高興說終於找到艾咪了，因為艾咪很活潑，所以諾亞就跑去找艾咪聊天。</p><p>到了晚上，索普帶著梵到了招待他們的宴會會場，梵這才找到機會，把自己的來意以及邊榆村所發生的事情告訴了艾咪…包括利普羅的死。艾咪聽到消息之後，當下淚眼盈眶…她一直希望能夠回到邊榆村，再見到她最愛的人，現在卻已經沒有辦法了…諾亞安慰著艾咪要她打起精神…這樣難過的艾咪一點都不像她！並要艾咪和他們一起回去，梅還有邊榆村的家都還在那邊。但難過的艾咪在此時卻沒辦法決定什麼，只說希望能一個人好好靜靜…</p><p>宴會開始不久後，梵在角落看到兩名男子正在談話，其中一名男子是索基。另一名身穿藍色僧衣的男子看到梵與諾亞手上的獸，對他們說道比起令他討厭的獸，他更討厭附有著獸的人！說完就離開了。但一旁的基索卻與藍衣男子相反，他明白表示他很羨幕梵手上那不受霧所影響的聖獸，而聖獸應該都在創世樹內沉睡才對，如果他也有獸的能力，一定會去找大禪師好好打一場。</p><p>長老索普明白梵此趟目的是要來帶艾咪離開後，稱讚著梵真是正直，並說明他聽聞梵靠著聖獸之力將邊榆村、里克洛亞山上的創世樹覺醒了，而拜倫寺院也有兩顆創世樹，想拜託兩人幫忙喚醒創世樹，好消除寺院周圍的霧。梵義不容辭的答應了。索普很高興的向僧兵們宣布這件事情，同時也說明他們拜倫寺院也該幫忙這件事情，由於北方的兩座西布斯（西ヴォズ樹林）與東布斯森林（東ヴォズ樹林）分別長有兩顆創世樹，因此索普詢問梵要先選擇解放哪邊的創世樹。梵決定先解放西布斯的創世樹，索普便找來了大禪師過來，要他和梵同行。大禪師正是剛剛怒斥梵的僧師，他面有慚色的想拒絕，但因為無法違抗長老的意思，也為了拜倫的未來，所以只能答應。也因為這樣使得索基跑出來抱怨！索基說既然如此，那麼東北方的布斯森林就交給他吧，為了以防萬一，由他先去找創世樹，如此也可以保護創世樹的安全。索普不敢相信索基居然會自告奮勇，還是答應索基的請示。此時可怕的想法卻在索基內心盤算著…</p><p>隔天一早，索基便領著僧兵隊先行前往了東布斯森林。而隨後梵一行人也準備出發了。出發前諾亞向大禪師抱怨，大禪師這個名字很奇怪，這時藍衣男子趕忙向諾亞解釋『大禪師』是稱號而不是名字！然後又想到梵與諾亞並不是僧兵，稱呼自己為大禪師確實不妥，於是將自己的名字「伽藍」（ガラ）給報了出來。卻又警告兩人不要隨便叫他的名字，因為他討厭被獸所依附的人類。</p><p>梵一行人出發來到了西北方的西布斯森林，森林中有一條急流，難以通過，諾亞好奇的問著一旁的小樹苗是什麼，很想吃看看，伽藍解釋著那是架橋草（ハシワタリ），幼苗時雖然很脆弱，但是成長後可以越過溪谷，可以當作橋樑在上面走。諾亞這時候突然想到剛剛撿到的肥草水，或許用在架橋草上面可以讓草快速成長。伽藍有點驚訝的說，本來以為他們兩人都是沒大腦的笨蛋，想不到也會有這樣的點子…果真架橋草經過肥水草的灌溉後，馬上成長的能讓梵他們通過了。在森林的深處，梵找到了創世樹，但創世樹卻已即將枯萎壞死，帝瑪說這顆創世樹由於吸入太多的霧，中毒過深已經完全枯死了…也已沒辦法再復原。伽藍雖然不知道梵他們在說什麼，卻曉得他們沒辦法拯救這顆創世樹，要眾人別在這浪費時間，趕快離去。就在此時創世樹的內頭發出細微的光芒，梅達說那光芒是聖獸卵（聖獣卵）所發出的，於是梵便將卵給取出，梅達表示聖獸卵要孵化，必須依靠著健康的創世樹之力才行，要梵好好的保管。伽藍看著枯萎的創世樹，正說著前往東布斯森林的索基不知道進行的如何了的同時，突然遠方傳來巨大的光芒與爆炸聲響，而方向竟是由拜倫寺院所傳來的，慌張的三人便匆忙的趕回寺院。</p><p>回到寺院後，眾人發現寺院前的抽風裝置已損壞，進入寺院內部時已經佈滿著霧…而寺內的僧兵都無力的倒在地上，心急如焚的伽藍先行離開梵與諾亞找尋其他倖存者…梵與諾亞則在一間房內找到了已經獸化的艾咪，十分擔心艾咪的諾亞，想把附在艾咪身上的獸給拉出，卻被帝瑪阻止，帝瑪說一旦獸附著在人類身上，除非是霧散去，否則強行拉出連艾咪都會死去，所以要諾亞不能著急，要趕快去解放東布斯森林的創世樹，才救的了艾咪以及其他人。最後他們兩人在寺院深處的一間房內找到未被霧所影響的長老索普及其他僧兵，索普無奈的表示是索基將寺院外的牆給炸燬，並且帶著一群獸進來攻擊僧兵們…而且他發現索基手上也附著與梵相同的獸，但獸可能已經支配了索基的心…梵與諾亞便決定快到東布斯森林。出到外頭時，伽藍已經在那等他們，並放下身段拜託梵能夠讓他同行。</p><p>在東布斯森林中，伽藍希望梵還有諾亞能夠答應他，等一下遇到基索時，讓他和基索戰鬥，如果基索的意志真的已被獸所控制，他將親手了結基索。當三人趕到創世樹前，正準備以聖獸之力解放創世樹時，索基果真出現了。索基狂妄的說，他並沒有被獸控制，獸只是純粹的能量，讓他渾身充滿力量的！極度憤怒的伽藍對著索基咆哮著，說他是嗜血的野獸，已經失去了人類的心…便與索基打了起來，結果有了獸之力索基輕鬆的解決了伽藍。索基失望的抱怨伽藍實在是太弱了，卻不打算自己動手殺他，而是招喚出雷獸威格洛（雷獣ヴィグロ），打算順便解決一旁的梵與諾亞。梵眾人解決了雷獸後，索基譏笑著伽藍根本就是在扯他們兩人後腿，嘲弄完伽藍後便消失無蹤了…</p><p>梅達似乎知道附著在索基身上的獸之力是什麼，但是現在無瑕理會這個，要梵與諾亞趕快解放創世樹，兩人的聖獸之力注入後，東布斯森林內的創世樹終於也覺醒了，並與以邊榆村、里克洛亞山的兩顆創世樹互相呼應著。帝瑪要梵趕緊將西布斯森林創世樹中取出的聖獸卵放入孵化，沒想到孵化後的聖獸竟然選擇了一旁的伽藍為主人…伽藍驚訝的疑問著聖獸為何會選擇自己…但想到剛剛面對索基的無力感，讓他願意把身體借給聖獸，好讓自己可以把破壞拜倫寺院的索基給打倒。</p><p>聖獸表示自己名為歐茲瑪（《聖獣》オズマ），想不到伽藍的心是封閉的如此的緊密…自己就和未受霧所改變的獸一樣，是為了幫助人類而活的，並不會控制人的想法意志，既然伽藍願意將身體藉助給牠，那麼伽藍也同樣可以擁有牠的力量，希望伽藍能夠和牠一同奮戰。</p><p>就這樣，伽藍成為第三隻聖獸歐茲瑪的主人…</p><h2 id="霧之巢穴"><a href="#霧之巢穴" class="headerlink" title="霧之巢穴"></a>霧之巢穴</h2><p>梵一行人回到了拜倫寺院，寺院已恢復正常。索普很感激梵等人的幫忙，但對於伽藍身上附有了獸，索普說這已經是違反了拜倫的教條，他只能以拜倫領導人的身分將伽藍給逐出師門。諾亞本來不明白逐出師門的意思，一知道伽藍因為這件事情從此與拜倫寺院被給趕出去，非常生氣的責備索普剛剛的決定，但伽藍很快對諾亞解釋，自己身為修行者，有些戒條是務必要遵守的，所以他尊重索普的處罰。諾亞聽到伽藍這麼說，馬上對伽藍說以後我們就是你的夥伴了，絕對不會再被趕走！此時艾咪從一旁出現，她很高興看到梵等人平安無事，託他們解放創世樹的緣故，自己和其他人才能恢復正常…艾咪和梵表示，據說西北方的盆地上的霧已經稀薄許多，而那裡出現了一座奇怪的城…問梵是不是會去，梵一想到或許與霧出現的原因有所關聯，當然是決定要去。索普也在旁說，大約在十年前，霧正是從那塊地方所飄過來的，或許破壞那座城就能夠讓霧消除！將這件使命託付給梵與諾亞後，索普轉身對伽藍說，就算他和索基都被獸給附身，破壞了教條，但還是放心不下兩人…畢竟他們兩個對自己而言，是相當重要的人…他們兩人就像是自己的血親般，都是自己的教子…因此將索基的事情託付給他。</p><p>離開了拜倫，梵三人往西北方前進，進入了神祕的城（ゼトーの穴居城）。來到城內，濃霧瀰漫四周，內部皆是神祕的裝置，就像是生物一般的活動著。而獸群也不同以往，更加的兇暴強悍，梵等人靠著聖獸的力量不斷深入內部，在出電梯後，他們再次遭遇到囂張的索基。索基笑道呆子軍團終於來了，就像是笨蛋一樣不怕死的進來穴居城。此時伽藍要梵和諾亞別插手，他要親自和索基對決，索基笑說伽藍已經完全的輸了，根本不配和他打…但仍然接受了伽藍不怕死的挑戰。如今伽藍已非以往，靠著歐茲瑪的雷聖獸之力，經過一番纏鬥終於擊敗索基。索基不免錯愕，卻仍誇耀伽藍靠著獸之力也變的很強…夠格當他的對手了。既然和自己一樣都成了獸的同伴，這次就算是兩人平手…也因為已經是同伴，索基順便把這座城的秘密說出來。原來這座城的主人正是塞特，他正在霧之巢穴等著他們去送死，要伽藍好好保住自己的小命…說完又一溜煙的跳走了。眾人雖然對索基反覆無常的性格沒輒，卻無暇逗留，接著繼續前進來到了最深處。</p><p>來到城的最深處，他們看到的是一個巨大的圓盤。帝瑪說令人類產生邪惡慾望、改變使獸凶暴無比的「霧」…便是由這機械中樞『霧之巢』（霧の巣）所製造。伽藍看著前方巨大的裝置，不免疑問著自己是否有辦法破壞這麼龐大的東西…歐茲瑪要伽藍明白，只要有牠們的力量配合上三人的祈禱之心，絕對能夠破壞霧之巢。就在眾人即將靠近霧之巢時，塞特果然出現了，如同在邊榆村一樣，塞特對眾人傳導霧是福音、永劫、無懈可擊的調和！不要反抗霧的存在，乖乖接受就好了…只好親自將梵這些微弱的抵抗給消除…諾亞認出塞特就是當時在里克洛亞山上攻擊她和帝瑪的人，也非常的生氣，梵三人便隨即和塞特決戰。塞特化身成一隻龐大的巨螃蟹，不斷使用強烈的海嘯攻擊著三人，但經過三人合力，總算擊敗了可怕的塞特。塞特似乎難以置信，自己竟輸給聖獸…而且還是真正覺醒的聖獸之力…懇求柯特（コート）大人能夠原諒他，就消失了。此時梅達要梵三人做好心理準備，同心協力破壞霧之巢，在眾人的祈禱下，霧之巢終於徹底崩毀，而附近的霧也跟著消失無蹤…伽藍非常驚訝聖獸之力竟然能破壞如此龐大的霧之巢，雖然是非常值得高興的事，但諾亞卻發現帝瑪十分的難過，似乎正在哭泣，帝瑪雖然明白諾亞的體貼，仍要她不必擔心…並趕緊表示，眾人依然不能安心，可恨的霧也只是從多魯克王國上消失而已，將霧之巢設置在此的幕後黑手，還沒有除掉…世界上的其他地方還有許多人仍被霧折磨著！三人離開之後…逐漸崩壞的裝置，伴隨如同聖獸的東西慢慢地粉碎…</p><p>再次回到了拜倫，梵將事情都告訴了索普，索普不免驚訝著霧之巢的本貌，感謝之餘，仍不忘索基，拜託伽藍能夠將索基帶回拜倫。他認為索基身上的獸很明顯不是和他們一樣的聖獸，但卻又從他身上感受不到像塞特那樣的邪惡氣息…或許這趟與霧戰鬥的旅程，對伽藍而言就像是追趕索基之旅一般…而在此同時諾亞興奮的對索普說艾咪決定要回到邊榆村了，艾咪也從旁出現，對索普長老告別…艾咪非常感激他和眾僧兵長久以來的照顧…最後對梵提醒，他是聖獸所選上的人，絕對不可以丟男人的臉！梵耿直的允諾艾咪的提醒，讓艾咪感到很高興，笑道梵已經變成頂天立地的男人了，回去邊榆村後，會和梅述說他的英勇事蹟。因為沒有辦法再目送別人離開，所以艾咪決定自己先離開…要梵、諾亞好好加油，想看她的話隨時都可以回去邊榆村。眾人依依不捨的目送艾咪離去後，伽藍對梵說多魯克王國的北方，也有受霧所困的人們，必須去解救他們，諾亞也應和伽藍的主意，要梵去救其他人，梵點點頭，要兩人跟著他一同繼續前進。見梵的反應，伽藍直稱讚梵的氣勢，說梵以後就是三個人的隊長；諾亞則是嚷嚷著最喜歡梵…索普在梵三人即將出發時告訴他們，北邊的塞布克斯群島（セブクス群島）與更遙遠的卡里斯皇國（カリスト皇国）的情況他並不太暸解，但他相信，梵既然拯救的了多魯克王國，就有辦法能夠拯救的了這世界。</p><p>三人告別了索普，離開了拜倫寺院，往北方前進。</p><h2 id="預言之子哈利"><a href="#預言之子哈利" class="headerlink" title="預言之子哈利"></a>預言之子哈利</h2><p>離開拜倫寺院的梵等三人沿著河流往北方前進，並在河流的盡頭發現風風老洞窟（風々老の洞窟），在洞窟裡銜接著另一個水水婆洞窟（水々婆の洞窟），這兩個洞窟因為地緣關係，並沒有受到霧的侵擾。洞窟內水水婆熱情的迎接梵等人，表示已經十年沒有客人了，並希望（強迫）他們能夠在此過夜。當天晚上三人不約而同做了一個夢，在夢裡的三人似乎是有意識的知道自己在夢境，此時諾亞嚷嚷著聽到一個陌生的聲音，並詢問著聲音來源是不是自己的母親，這個聲音回應說他的名字叫做哈利（ハリィ），他想讓梵三人知道人類世界與聖獸還有關於雷姆（レム）的真相，並希望他們能夠到達名為歐庫塔姆（オクタム）的古都，此地位於塞布克斯群島的中央，屆時他將會告知一切。醒來後梵明白這個夢的重要性，於是決定非得見哈利一面不可，隔天三人便離開了洞窟，到了塞布克斯群島（セブクス群島）。</p><p>順著西北方前進，梵等人首先看到的是一座已被霧所影響的城鎮傑樂美（ジェレミ），那是一座被山崖圍繞的城鎮。蒂瑪感受到此處應該有創世樹的存在氣息，於是眾人決定先讓創世樹覺醒，以拯救獸化的鎮民們。梵等人搭著高聳建築內的中央電梯到了頂端的空中花園，發現有一隻獸－謝奇亞斯（セキアス）正在啃蝕著創世樹，諾亞心急著要這隻獸離開創世樹，反而被獸的力量給彈開，心知那是一隻強大的獸，眾人不敢大意，合力將獸擊倒，創世樹覺醒後，傑樂美的鎮民也都恢復了原狀，本來梵三人是想趕緊離開城鎮，還是被熱情的鎮長拉去參加了替梵他們舉辦的感謝宴，鎮裡有一名名叫薩嵐（ザラン）的男子，他希望梵能夠幫忙他送一封報平安的信到北方的衛德那鎮（ウィドナ）給他的老婆優瑪（ユマ）與兒子貝貝（ぺぺ）。</p><p>離開傑樂美鎮，梵等人來到了衛德那鎮，那是一座以天然溫泉而知名的風車小鎮，拜鎮內有著風車（風車設施運轉的來源是依靠地底溫泉的熱氣）之故，能夠不受霧的侵擾。正因為如此平和，鎮內的人們，尤其是年輕人都顯得格外悠閒（懶散），在海灘上悠閒的曬著日光浴，梵在鎮裡也找到了薩嵐的兒子貝貝，才從貝貝口中得知母親優瑪已經在三年前因病過世，並把優瑪的戒指（母の形見の指輪）交給梵，希望他們能夠把戒指交給薩嵐……在鎮內也找到拜倫僧兵的支部，支部內有一名叫做薩希雅（サシア）的女士，她對梵表示她的身分其實是在歐庫塔姆內侍奉哈利的巫女，在歐庫塔姆即將被霧入侵之前，哈利要薩希雅先到衛德那鎮避難，並指示當有三個帶著聖獸的年輕人出現時，將信息告知：『來雷姆神殿（レム神殿）』吧，閱讀完四本《神托之書（神託の書）》、取得鑰匙星之珍珠（星の真珠）吧』，這將指示他們如何進入歐庫塔姆。得知了哈利留給梵等人的訊息後，梵等人離開衛德那鎮往東北方前進，終於來到了歐庫塔姆。</p><p>在遺跡外，諾亞著急地喊著哈利，要他趕快出來告訴她夢的事情，伽藍則是要諾亞冷靜，並表示歐庫塔姆已經被霧給包圍了，在這種情況下是不會有人可以存活的，於是諾亞想到若有創世樹不就可以趕走霧了嗎！但附在諾亞手上的聖獸蒂瑪很遺憾的說附近並沒有創世樹的氣息，難過的諾亞則是問梵該如何是好，此時梵決定好好的調查這一帶再說。</p><p>靠著當時哈利的提示，梵等人來到遺跡內的雷姆神殿，翻完神殿內的四本神托之書後，開啟了隱藏通道，來到神殿底部，突然出現一名性感妖豔的女性，笑著問梵三人是不是也來尋寶的，這名桃色短髮女性名叫卡菈（カーラ），並自稱是一個小氣的盜賊，隨後質疑梵三人來此處的動機是否跟她一樣是來搜刮財寶的，此時諾亞生氣的表示自己才不是壞人，也不是來這裡做這種事情的！卡菈則不以為然的要諾亞不要裝可愛，這個城鎮的居民早就坐著昇降梯到地下避難了，諾亞隨即意會到哈利可能也一起在地下避難，但卡菈表示電梯也已經停用，居民什麼也沒有留下，此地只留下一顆破爛寶石；眾人發現那居然就是哈利指示的星之珍珠，伽藍趕緊詢問卡菈星之珍珠該如何取得，卡菈一邊笑著他們連這種破寶石都想要的同時，還是好心（傲嬌）的告知梵他們傑樂美有個寶石技工薩嵐專門在做這種騙錢的東西，隨後便離去，雖然梵等人納悶為什麼卡菈身上並沒有聖獸卻能夠在霧裡自由移動，不過也無暇分心，三人馬上前往傑樂美找薩嵐，薩嵐得知優瑪消息後顯得很悲傷，但還是感謝梵的幫忙，梵也順利從薩嵐那拿到了星之珍珠。</p><p>梵等人拿著星之珍珠來到歐庫塔姆東邊的多恩之門（トーンの門），那是外表像一株未開花苞的巨大石塊，就在梵等人才剛靠近，一旁又出現一個蒙面的奇怪男子，一登場便很失望的表示本來還期待能打倒賽特的勇者會是什麼樣的人物，原來只是一群小鬼，並自稱自己是技．迪利拉（ギ・デリラ，以下通稱技），技要求梵能夠跟他一對一的單挑，一旁的諾亞不滿的表示為什麼不找她而選擇梵，技表示一對一是迪利拉家族的傳統，要她等等，就在雙方一觸即發時，又出現兩個奇怪的男女，分別是流．迪利拉（ル・デリラ）與傑．迪利拉（チェ・デリラ），登場的同時，也擺著奇怪的POSE及中二稱呼，讓梵三人不得不啞然，三兄弟的大哥技在此時又說有事，要把梵人頭先寄在自己的脖子上，下次會再來找他討，便化作煙霧消失了。諾亞在他們走後還天然的學起他們帥氣的POES而被伽藍責備要她別玩了，接著三人趕緊解開石花苞的謎題，隨著花朵綻放，花朵的中央出現了一個水球型氣泡，三人便走了進去，經過一條漫長的通道後，梵等人來到了地下的歐庫塔姆。</p><p>位於地底下的歐庫塔姆，有著大小不一的石柱平台，並有著美麗自然的光線照射著，梵等人便先休息一晚，當天諾亞做了一個夢，夢裡出現兩個陌生的聲音，欣慰的表示看到諾亞被養育的這麼健康，依然是那麼天真純樸，想必也遇到了好朋友，原來這兩個聲音是諾亞的父母，諾亞大喊著好想見他們倆，但諾亞的父母說他們目前被封印在黑暗之中無法行動，只能夠靠著夢中與諾亞交談，並告知諾亞他們非常很想念她，諾亞則要父母要等她，諾亞一定會去找他們。隔天早上才剛走出旅館，便發生了地震，房子瞬間便被這地震影響而崩塌……在城鎮裡探索情報得知哈利目前正沉睡著，而且還是小嬰兒，於是梵等人先找到了市長，市長表示自己很無能，沒有辦法幫助市民脫離危險，這才知道原來住在此地的居民雖然躲避了霧卻也因為地震的緣故十分危險，如果哈利能夠醒來就能夠幫助鎮民們，就在這個時候一名士兵跑過來報告哈利醒了，於是梵三人便前往哈利所在的瞑想宮裡。宮裡地下室躺著三個嬰兒，這三個嬰兒分別代表哈利的三個意念，分別是過去、現在與未來。</p><p>過去的哈利表示：梵三人能夠開始這段旅程的因緣，雖然是『過去』式，對現在而言卻是必然發生的！從前霧、獸、聖獸都是從獸界（獣界）來的，人界與獸界其實是表裡一體，可以相通的，根據雷姆的觀察，在霧的中心有個非人非獸的惡魔，準備以霧來摧毀世界，持有聖獸之力的三人絕非偶然。</p><p>現在的哈利表示：霧的使徒目的就是摧毀世界，這便是『現在』的情勢，在歐庫塔姆的地下深處，也就是炎熱海道的底部，便躲著那名惡魔使徒，要梵三人利用聖獸之力打倒牠才能夠拯救歐庫塔姆。</p><p>未來的哈利表示：在『未來』的世界，霧仍到處瀰漫，但即使是擁有神力的雷姆也無法窺視更透徹，並分別告知梵，未來會有個大悲劇將打碎他的希望；告知諾亞她的父母仍活著，他們目前在卡里斯皇國（カリスト皇国）的孔庫拉姆（コンクラム）裡，但當她見到他們後，內心將大受影響；告知伽藍關於他所作過關於索基的惡夢，索基可以說是他的影子或另一個自我，而這場惡夢的導火線可能就是伽藍自己。</p><p>聽完哈利的話後，各自有些心事的三人才剛離開瞑想宮，便又發生地震，瞑想宮則因為地震而倒塌墜落深淵……諾亞著急地問著哈利是不是死了，伽藍則沉重的表示哈利肯定已經死了，要諾亞好好面對現實，這樣才能不愧哈利的用心，於是三人決定到炎熱海道尋找霧的使徒。在市長的指示下梵一行人進入了炎熱海道，在經過陣陣岩漿的炙熱洞窟的深處，梵等人看到一頭巨大的牛－布魯迪歐（ブルテリオ）正在撞擊石柱，原來，地底下頻繁的地震便是這頭牛所引起，與他對話後得知牠正是奉杜哈迪（ドハティ）的命令，對海道底下內的石柱進行衝撞，好讓上面的居民死亡，隨後發現梵等人持有的聖獸是牠的敵人，便進行攻擊，在梵等人苦戰過後打倒了布魯迪歐，布魯迪歐生氣的表示要用牠最後的力氣讓梵等人後悔，最後滾燙的岩漿在布魯迪歐的詛咒下頓時結冰，牠也隨後便死去。梵等人因擔心居民的安危，便趕緊回到上面確認狀況，回到歐庫塔姆，市長已經在那等著梵，市長告知拉泰尤（ラタイユ）附近的雷多那山（レトナ山）似乎有顆創世樹，但拉泰尤的城主似乎不太對勁……聽到有創世樹的消息，於是梵等人便前往拉泰尤。</p><h2 id="解放賽布克斯群島"><a href="#解放賽布克斯群島" class="headerlink" title="解放賽布克斯群島"></a>解放賽布克斯群島</h2><p>才剛踏入拉泰尤領地，附在梵手上的梅達、蒂瑪及歐茲瑪便感應到創世樹的氣息，並對創世樹產生扭曲的波動感到不對勁，此時拉泰尤已經被霧所影響，但由於東邊通往創世樹的雷那多山的石門被封閉，因此必須找到門的鑰匙，眾人便進入拉泰尤城裡找尋方法。在城裡發現了城主瑟基（セルジュ），外貌看似獸化的瑟基見梵前來非常高興，並主動給予梵通往雷那多山的鑰匙，瑟基表示解放創世樹後霧便會消失，他就可以舉行婚禮了；如果梵順利完成，甚至能把通往西方城門的鑰匙給梵。此時眾人雖然疑惑瑟基為什麼被獸化還可以說話，看起來也似乎有陰謀，但的確當務之急便是解放創世樹，便收下鑰匙前往雷那多山。</p><p>一行人很快的到了山頂，就看到創世樹被不明的透明牆壁給罩住，諾亞好奇的觸摸後馬上便被不明的力量彈開並大喊著好痛（XD）！眾人一時也不知道該怎麼辦的時候，索基突然從旁邊跳出來，囂張的表示豬頭軍團又回來啦，並抱怨梵三人只會傻傻的往有創世樹的地方跑，所以他就計畫在這裡等，沒想到他們這麼慢！伽藍生氣的問結界是不是索基搞的鬼，索基馬上就承認並表示只要打贏他就解開結界，於是雙方馬上就開打（定番^^|||），跟先前不同，此時索基身上產生了一些變化：手上的獸變大、頭髮變白、眼露凶光，在在都是被獸化影響的特徵，擊敗索基後，索基很滿足的表示看來他們的獸也變強了，爽快的解開結界，期待梵三人能繼續變強後就離開了，眾人趕緊的利用聖獸之力讓創世樹覺醒，諾亞開心的喊著蒂瑪又變強了，伽藍則發現解放創世樹雖然驅散拉泰尤的霧，但只要沒破壞霧之巢便無法解放賽布克斯群島被霧的影響，於是三人決定先回拉泰尤鎮上。</p><p>回到鎮上發現鎮民們一點也沒因為霧被驅散而感謝、反而嫌梵他們多管閒事！原來，在被霧侵擾前，鎮民們便被城主瑟基的倒行逆施弄得民怨四起，瑟基經常命令士兵把鎮上的年輕少女帶走，說是要把她們嫁給『獸』，被帶走的少女都是一去不返；而鎮上的女孩們也都害怕的躲在家裡……後來梵在旅館裡遇到一名穿著紫色禮服的女孩艾莉莎（エリザ），她無奈的表示自己即將要被帶去嫁給獸了，已經有很多朋友都被帶走，她唯一掛念的就是自己的父母，希望她被帶走之後梵三人能夠照顧她的父母，聽到這裡諾亞馬上要求自己代替艾莉莎成為新娘，梵思索後同意讓諾亞冒險（也拗不過她），對此艾莉莎難過的自責，諾亞則要她不用擔心，於是穿上新娘禮服的諾亞便被士兵帶走了。</p><p>假扮新娘的諾亞被士兵帶到城裡不明深處，在這裡諾亞發現周遭都有被不明物體包覆的新娘，被包覆的新娘痛苦的表示既看不到也聽不到；隨後便看到一個新娘被帶到中央裝置處，諾亞發現裝置中央有隻很大的怪物，原來那隻怪物就是當初破壞邊榆村的凶獸－加卡諾特（凶獣ジャガーノート），牠伸出觸手將新娘當作糧食給吸收，城主瑟基也在這時候出現，高興的表示凡人能成為獸的新娘，成為加卡諾特的一部分是很幸福的事，要諾亞不要反抗了！諾亞則氣噗噗的說絕對饒不了瑟基，卻被後面的士兵給電暈，而在城外的梅達馬上感應到蒂瑪發出的警告信號，梵等人便即刻進入城內要拯救諾亞。到了內部，正當諾亞即將被加卡諾特的觸手給吸收的時候，伽藍立刻把觸手給打退，兩人馬上利用聖獸之力讓諾亞清醒過來，諾亞很開心的表示她相信梵跟伽藍一定會來救她（那還用說！），這時候瑟基氣憤的吼著要殺了梵，便化成類似香菇的怪物襲來，三人合力打倒瑟基後，發現原來是瑟基頭上的突變體在操縱他，突變體瓦解後，瑟基也恢復了意識，他趕緊將控制加卡諾特的裝置關閉，凶獸在梵三人面前被封印回地底下。</p><p>一行人返回城內，瑟基鄭重與梵等人表示歉意，之後一定會負起全責，並說明當時一名叫做杜哈迪（ドハティ）的人來找他，他就被杜哈迪所帶著的獸給附身了，也就是剛剛被消滅的突變體，他的意識被突變體控制，為了製造加卡諾特便犧牲鎮上的少女來當作牠的養分，而目的便是要量產加卡諾特，這也是為什麼當時要幫助梵等人順利解放創世樹的緣故……隨後將通往西方的鑰匙給了梵，告知他們杜哈迪的藏身城堡（ドハティの海王城）即是霧之巢，為了解放賽布克斯群島，三人非打倒杜哈迪不可。出發前夜，諾亞又再次的夢見了父母，他們難過的表示都是他們在過去犯了一個無法挽回的錯誤，才會導致世界毀滅，現在會被困在黑暗都是他們的報應，希望諾亞能夠挽救毀滅的命運，並幫他們贖罪，諾亞則再次喊著一定會去找他們。</p><p>隔日梵等人出發前往海王城，那是一座聳立於海上的巨大城堡，三人努力的打倒許多怪物後終於來到城裡的最頂端，並看到釋放霧的巨大裝置，就在準備破壞的時候，果不其然杜哈迪出現擋住梵的前進，杜哈迪不爽的表示瑟基真是個蠢蛋，居然笨到要拿聖獸之力去餵食加卡諾特，導致計畫失敗，並說自己是柯特（コート）大人的忠實信徒，製造加卡諾特、收拾哈利、進而取得柯特給予的優秀突變體，全部都是他做的！說完便化身為一隻醜陋的怪獸襲來，合力擊倒杜哈迪後，死前的他憤恨表示已經把加卡諾特散播到世界各地去了，也還有正在成長的凶獸，即使他死了，加卡諾特也不會被消滅。隨後梵三人便利用聖獸齊力破壞掉霧之巢的核心裝置，破壞的同時，似乎出現看起來像是聖獸的東西在梵等人面前化為粉末，伽藍問歐茲瑪剛剛消失的是不是聖獸，諾亞也納悶為什麼蒂瑪變的很奇怪，梅達則與其他聖獸一起無奈的表示目前時機還沒成熟，總有一天會說明的，請他們不要再追問了……</p><p>解放了賽布克斯群島後，大地又恢復了生命光彩，梵三人回到拉泰尤城後，知道結果的瑟基無奈的表示對於以前他所製造的加卡諾特將襲擊梵他們的故鄉，他感到非常抱歉，並得知諾亞要去孔拉庫姆找父母，如果要從賽布克斯群島前往卡里斯皇國（カリスト皇国）就必須要搭乘風來獸車（風来獣車），歐庫塔姆那邊有風來獸車的車站，伽藍說有霧就會有索基，諾亞則著急的要趕快去搭獸車（感覺像是想去玩^^），於是三人下一步便是前往風來獸車的車站。</p><h2 id="番外篇章-帶著諾亞及伽藍回去故鄉"><a href="#番外篇章-帶著諾亞及伽藍回去故鄉" class="headerlink" title="番外篇章 帶著諾亞及伽藍回去故鄉"></a>番外篇章 帶著諾亞及伽藍回去故鄉</h2><p>事情發生在前往塞布克斯群島之前，梵決定先回家鄉邊榆村一趟。一回到熟悉的邊榆村時，熱情的村民們見到梵都很開心，村長則對當初託付給梵，將艾咪平安的帶回來這件事能圓滿成功相當感激，直言梵真的是邊榆村的驕傲！回到梵的家中，華爾及寧寧對梵則是一如既往沒有什麼好需要擔心的；伽藍見到久違的托德大師馬上尊敬地做出僧兵行禮，托德不由感嘆當時見面還是小孩的伽藍現在還記得他，但當托德問起索基的事情時，伽藍卻不知道怎麼回應，對此托德則明白是有什麼理由才不好說明，只交代伽藍身為拜倫寺院的一員，要好好照顧梵跟諾亞。</p><p>進到艾咪與梅家時，一見到梵，梅難掩喜悅的衝了過來，本來以為會是開心的場面，梅卻默默低著頭，說梵是個騙子！是個大騙子QQ……為什麼特地去拜倫寺院找母親的事情要瞞著她呢？她一直很擔心、很擔心梵會發生什麼事（這時候伽藍識相的默默的走到一旁望著窗外XD），梵居然默默為了她，獨自去做這麼危險的事情……艾咪過來安慰梅，問梅為什麼要責備梵呢？梅紅著臉表示她也不知道為什麼，明明當初見到母親回來是那麼的開心，心想一定要對梵說謝謝跟抱歉，一見到梵的臉，想到因為他什麼都沒跟自己說就好生他的氣……艾咪擦著梅的眼淚，笑說梅真的是愛哭蟲，哭成這樣真傷腦筋；這時候諾亞跑到梅身旁，好奇的問梅為什麼要哭呢？明明她的母親艾咪在身邊，梅並不孤單的啊！是因為梵的關係嗎？如果是梵不好才讓梅哭的話，諾亞會罵他的！所以梅不要哭了，梅再哭的話……諾亞也要哭了……因為，諾亞沒有母親，諾亞只有一個人……說到這裡諾亞崩潰地跪在地上嚎啕大哭了起來QQ……這讓在場的人都嚇到，到最後，現場只剩下諾亞大大的哭聲……梅難過的對諾亞還有梵表示抱歉，都是自己情緒沒控制好的關係才會變成這樣，艾咪擦著諾亞的眼淚，表示諾亞可以把她當作母親一樣看待也沒關係的；並希望梵能夠幫助諾亞尋找她的母親，因為她從諾亞那裡得知，她時常在夢中聽到有個類似母親的聲音，她相信這應該是雷姆大人的指示，所以希望梵能夠一起幫助諾亞，眾人整理情緒過後，提起精神對艾咪與梅道別，便繼續展開旅程了。</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PS1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>驾照</title>
    <link href="/2024/02/26/%E9%A9%BE%E7%85%A7/"/>
    <url>/2024/02/26/%E9%A9%BE%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="科目一"><a href="#科目一" class="headerlink" title="科目一"></a>科目一</h1><h2 id="考试相关"><a href="#考试相关" class="headerlink" title="考试相关"></a>考试相关</h2><h3 id="不参加考试"><a href="#不参加考试" class="headerlink" title="不参加考试"></a>不参加考试</h3><p>需要提前一天取消预约</p><h2 id="不得申领驾驶证"><a href="#不得申领驾驶证" class="headerlink" title="不得申领驾驶证"></a>不得申领驾驶证</h2><p>1）申请人以欺骗、贿赂等不正当手段取得驾驶证被依法撤销驾驶许可的，多长时间不得重新申请驾驶许可？</p><ul><li>答案是 3 年</li><li>“吊销”的是<strong>合法驾驶证</strong>，“撤销”的是<strong>非法取得驾驶证</strong><ul><li>驾驶许可的撤销，是因为在考驾驶证的时候，弄虚作假，查出来了，就撤销。撤销后满3年方可重新考试申请。<strong>撤销和交通事故、违法无关</strong></li><li>开报废的车属于违章，这是要吊销的，不需要撤销，因为是合法取得，但是没有遵纪守法</li></ul></li></ul><p>2）此外，提供虚假材料的申请<strong>，作弊被发现，</strong>一年内<strong>不得申领一年内</strong>不得申领</p><p>3）欺骗行贿的已经拿到的，驾驶证撤销后<strong>三年内</strong>不得申领</p><p>4）飙车竞速的，吊销+<strong>五年</strong>不得申领</p><p>5）醉驾犯罪<strong>严重</strong>的 <strong>终身</strong>不得申领</p><p>6）无证驾驶闯祸，<strong>同等责任以上</strong>的事故：10年内不能申请</p><blockquote><p>总结: 假身份1年 驾证被吊销的2年 被撤销资格的3年 酒驾的5年 <strong>撞人逃逸的终生</strong></p></blockquote><h2 id="你这是违法行为"><a href="#你这是违法行为" class="headerlink" title="你这是违法行为"></a>你这是违法行为</h2><p>现在已经没有违章违规的说法了</p><p>只要违纪都是按照 违法 来处理</p><p>比如遮挡车牌，也算是违法行为</p><h2 id="初次申领注意点-amp-换证"><a href="#初次申领注意点-amp-换证" class="headerlink" title="初次申领注意点 &amp; 换证"></a>初次申领注意点 &amp; 换证</h2><p>初次申领的机动车驾驶证的有效期是多久</p><p>———— 六年</p><p>有效期分别为6年、10年、和长期！</p><p>其中，有效期时间到了，可以升级</p><p>6年换10年 10年换永远（6年每年未满12分，可以升级换10年（需要<strong>接受检验</strong>） 以此类推 换永久）</p><p><a href="#%E7%94%B3%E8%AF%B7%E6%8D%A2%E8%AF%81">具体参见</a></p><h3 id="谁可以申领"><a href="#谁可以申领" class="headerlink" title="谁可以申领"></a>谁可以申领</h3><p>下限是18周岁以上</p><p>无上限，<strong>超过70岁</strong>需要<strong>每年</strong>提交健康状况</p><p>精神病人不得申请（申请人只要患有精神病，<strong>任何情况</strong>都不可以申请机动车驾驶证）</p><p>XD的不能申请</p><p>癫痫的不能申请</p><h3 id="审验-amp-审验内容"><a href="#审验-amp-审验内容" class="headerlink" title="审验 &amp; 审验内容"></a>审验 &amp; 审验内容</h3><p>如果当兵或者出国需要延缓检验审验，最长不超过三年（因为当兵就是三年）</p><p>大中型客货车驾驶证年年审验，小车不要</p><blockquote><p>大中型客货车驾驶证在每个记分周期结束都要在<strong>30</strong>日内进行审验，如果本记分周期没有扣分，则可以免于审验。</p><p>但是大中型客车以外的车型，即小型汽车等车型，如果<strong>在本记分周期内有发生过造成人员死亡事故承担同等以上责任，没有被吊销驾驶证的</strong>，也要在本记分周期结束后<strong>30</strong>日内接受审验</p></blockquote><p>审验的内容：</p><ul><li>交通违法及事故处理情况</li><li>身体条件</li><li>违法记分及满分学习考试情况</li><li>注意：机动车检验情况属于<strong>机动车年检内容</strong>，不属于驾驶证审验内容</li></ul><h3 id="申请换证"><a href="#申请换证" class="headerlink" title="申请换证"></a>申请换证</h3><p>驾驶证即将到期时应提前申请换证，<strong>有效期满前90日</strong>内要到车管所申请换证</p><p><strong>申请换驾驶证90天，改信息30天</strong></p><p><strong>超过机动车驾驶证有效期一年以上未换证被注销</strong>，但未超过二年的（三年以下，<strong>也就是1~3年</strong>），机动车驾驶人应当 参加道路交通安全法律、法规和相关知识考试（科目一），合格之后恢复驾驶资格</p><h3 id="初次可以申请的车类型"><a href="#初次可以申请的车类型" class="headerlink" title="初次可以申请的车类型"></a>初次可以申请的车类型</h3><p>简单来说就是不能带人（客车）和牵引车</p><p><strong>初次只能申领大货</strong>，<strong>大货，中客，重牵只能升级</strong></p><h2 id="准驾车型代号相关"><a href="#准驾车型代号相关" class="headerlink" title="准驾车型代号相关"></a>准驾车型代号相关</h2><p>小型汽车C1的准驾车型，可驾驶C2，C3，C4准驾车型，而三轮摩托车是的D的准驾车型</p><p>A1 大客车</p><p>A2 重型牵引</p><p>B1 中客车（10-19人公交车）</p><p>B2 大货车</p><p>C1 手动挡（小型汽车）可以驾驶的其他准驾车型有：小型自动挡汽车、<strong>低速载货</strong>汽车、三轮汽车。</p><p>C2 自动挡（小型自动挡汽车）可以驾驶的：小型、微型自动挡载客汽车以及<strong>轻型、微型自动挡载货</strong>汽车</p><p>c5 残疾人</p><p>c6 轻型牵引</p><h3 id="申请增加准驾车型"><a href="#申请增加准驾车型" class="headerlink" title="申请增加准驾车型"></a>申请增加准驾车型</h3><p>B2大货车 -&gt; A2重型牵引车 中型客车 ：需要<strong>2年</strong>以上时间 + 2个记分周期内没有满12分的记录</p><p>C1&#x2F;C2 -&gt; C6轻型牵引车：需要<strong>一年</strong>时间</p><h3 id="年龄相关"><a href="#年龄相关" class="headerlink" title="年龄相关"></a>年龄相关</h3><p>中科，大货：20</p><p>大客，重牵：：22</p><p>年满二十，<strong>城公大货有无轨</strong>（申请城市公交车、中型客车、大型货车、轻型牵引挂车、无轨电车或者有轨电车准驾车型的，在20周岁以上，<strong>60</strong>周岁以下）</p><h2 id="考试次数"><a href="#考试次数" class="headerlink" title="考试次数"></a>考试次数</h2><p>科二+科三 预约次数<strong>分别</strong>不得超过： 2+3 &#x3D; 5</p><h2 id="丢了找谁"><a href="#丢了找谁" class="headerlink" title="丢了找谁"></a>丢了找谁</h2><p>机动车<strong>登记证书、号牌、行驶证</strong>（上路用的）、丢失损毁的选择<strong>登记证车辆管理所</strong>。</p><p>机动车<strong>驾驶证遗失</strong>、损毁无法辨认应该向机动车<strong>驾驶证核发地</strong>管理所申请补发。</p><blockquote><p>小总结</p></blockquote><p>号牌都找登记地车管所（<strong>不是居住地</strong>）</p><p>驾驶证找核发地</p><h2 id="迁出户籍"><a href="#迁出户籍" class="headerlink" title="迁出户籍"></a>迁出户籍</h2><p>机动车驾驶人户籍迁出原车辆管理所需要向什么地方的车辆管理所提出申请？</p><blockquote><p>都已经迁出了，所以和原来地方没关系，要找迁入的车管所</p></blockquote><h2 id="扣分细则"><a href="#扣分细则" class="headerlink" title="扣分细则"></a>扣分细则</h2><h3 id="1"><a href="#1" class="headerlink" title="-1"></a>-1</h3><p><strong>不按规定使用灯光</strong> -1</p><p>违反禁令标志、禁止标线指示（禁止停车的地方停车） -1</p><p>驾驶没有年检（未按规定定期进行安全技术检验）的 <strong>公路客运汽车、旅游客运汽车、危险物品运输车辆</strong> <strong>以外</strong> 的机动车上道路行驶 -1</p><p>不管在哪里，没系安全带 -1</p><p><strong>校车大车</strong>在<strong>高速以外</strong>超速10%~20% -1</p><p><strong>高速外</strong>，不按规定掉头，倒车，会车 -1</p><h3 id="3"><a href="#3" class="headerlink" title="-3"></a>-3</h3><p>乱停车 -3</p><p>在道路上车辆发生故障、事故停车后，不按规定使用灯光或者<strong>设置警告标志</strong> -3</p><p>在高速公路上行驶不得低于60公里&#x2F;小时，低于规定时速 -3</p><p>高速上不按规定车道开 -3</p><p>不礼让行人 -3</p><p><strong>不礼让校车 -3</strong></p><p>小车在<strong>高速外超速</strong> 20%~50% -3</p><p>开车打电话 -3</p><p>普通路逆行 -3 （高速逆行 -12）</p><p>借道超车 -3</p><p>不按规定挂牌 -3</p><h3 id="6"><a href="#6" class="headerlink" title="-6"></a>-6</h3><p>闯红灯 -6 (不按交通信号灯指示通行)</p><p>高速上违法占用应急车道 -6</p><p>城市快速路上违法<strong>占用应急车道行驶</strong> -6</p><p>驾驶**载货汽车超载50%**以上 -6</p><p>校车以外的载客汽车，超载50%~100% -6</p><p>运载<strong>超限</strong>的<strong>不可解体</strong>的物品，<strong>爆炸物品</strong>，<strong>未按指定的时间、路线、速度行驶</strong> -6</p><p>驾驶证被扣还开车 -6</p><p><strong>大车以外</strong>的车在<strong>高速以外</strong>的地方，<strong>超速50%</strong> -6</p><p><strong>大车以外</strong>的车在高速上，超速20%-50% -6</p><h3 id="9"><a href="#9" class="headerlink" title="-9"></a>-9</h3><p>城市快速路上违法<strong>停车</strong> -9</p><p>驾驶7座以上载客汽车载人超过核定人数 50% 以上未达到 100% -9 （大车超载50%）</p><p>车型不符（校车也是） -9</p><p><strong>大车的车</strong>在<strong>高速以外</strong>的地方，<strong>超速 50%</strong> -9</p><p>遮挡 &amp; 没挂牌 -9</p><p>大车&amp;危险品<strong>超四小时</strong>没休息 -9</p><h3 id="12"><a href="#12" class="headerlink" title="-12"></a>-12</h3><p>酒驾 -12</p><p>轻伤以上或者死亡+逃逸 -12</p><p>轻伤+逃逸 不犯罪 -12</p><p>伪造变造车牌号 &amp; 驾驶证，行驶证 -12 （只要是造假的都是-12）</p><p>在<strong>高速公路</strong>、城市快速路上<strong>倒车、逆行、穿越中央分隔带掉头</strong> -12</p><p>驾驶<strong>校车</strong>、公路客运汽车、旅游客运汽车载人<strong>超过核定人数20%<strong>以上，或者驾驶其他载客汽车载人超过核定人数</strong>百分之百</strong>以上 （也就是大车超载20%，小车超载100%）-12</p><p>代替实际机动车驾驶人接受交通违法行为处罚和记分牟取经济利益 -12</p><p>驾驶<strong>中型以上</strong>载客汽车在<strong>高速公路</strong>上超速20%以上 -12</p><p>小车<strong>高速超速</strong>百分之五十 -12</p><p>不按规定安装扣三分，无牌，遮挡污损扣九分，假牌扣12分</p><p>普通道路乱掉头倒车扣1分</p><h3 id="高速小总结"><a href="#高速小总结" class="headerlink" title="高速小总结"></a>高速小总结</h3><p>高逆12，违停9，应急6，低速3</p><h3 id="超速小总结"><a href="#超速小总结" class="headerlink" title="超速小总结"></a>超速小总结</h3><p>不管小车还是大车，只要在高速超，都是6分起扣，20 50 分段</p><ul><li>小车20-50 6  50以上 12</li><li>大车20以下6 20以上 12 （大车更危险，要求更严格）</li></ul><p>不管小车还是大车，只要在高速外超，扣1369 10 20 50 分段</p><ul><li>小车 20-50 3 ，50以上 6</li><li>大车 10-20 1 ，20-50 6 ， 50以上 9</li></ul><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224225803987.png" alt="image-20240224225803987" style="zoom:50%;" /><h3 id="超载小总结"><a href="#超载小总结" class="headerlink" title="超载小总结"></a>超载小总结</h3><p>超员：（超员分大）</p><ul><li>小车 36 12分，20-50-100</li><li>7座以上 69分，20-50-100</li><li>校车 6 12分，20上下</li></ul><p>超载： 136分，0-30-50</p><h2 id="扣车"><a href="#扣车" class="headerlink" title="扣车"></a>扣车</h2><h3 id="补发行驶证"><a href="#补发行驶证" class="headerlink" title="补发行驶证"></a>补发行驶证</h3><p>驾驶证<strong>因违法行为被依法扣押、扣留或暂扣</strong>期间，是不得申请补发的</p><p>你要是驾驶证丢失了，那是可以申请补发的</p><h3 id="扣车条件"><a href="#扣车条件" class="headerlink" title="扣车条件"></a>扣车条件</h3><p>未挂牌</p><p>未挂年检标志</p><p>没带驾驶证</p><p>没带行驶证</p><p><strong>不会扣行驶证！！！</strong></p><h2 id="处罚相关"><a href="#处罚相关" class="headerlink" title="处罚相关"></a>处罚相关</h2><h3 id="组织作弊"><a href="#组织作弊" class="headerlink" title="组织作弊"></a>组织作弊</h3><p>申请人在机动车驾驶人考试过程中，<strong>组织</strong>作弊，<strong>情节严重</strong>构成犯罪的，会受到什么处罚？</p><p>处<strong>三年以上七年以下</strong>有期徒刑，并处罚金</p><p><strong>情节不严重</strong>  3年以下</p><h3 id="组织欺骗"><a href="#组织欺骗" class="headerlink" title="组织欺骗"></a>组织欺骗</h3><p>3~5倍倍率，不超过10w的赔偿</p><h3 id="组织代替审验"><a href="#组织代替审验" class="headerlink" title="组织代替审验"></a>组织代替审验</h3><p><strong>组织</strong>他人实施前两款行为之一，有违法所得的，由公安机关交通管理部门处违法所得<strong>三倍以下罚款，但最高不超过二万</strong>元；没有违法所得的，由公安机关交通管理部门处二万元以下罚款</p><p>参见<a href="#%E5%AE%A1%E9%AA%8C%E5%A4%84%E7%BD%9A">审验处罚</a></p><h3 id="代我扣分"><a href="#代我扣分" class="headerlink" title="代我扣分"></a>代我扣分</h3><p>机动车驾驶人请他人 <strong>代为接受交通违法行为处罚和记分并支付经济利益的</strong> -12分</p><p>3倍以下倍率，不超过5w</p><h3 id="个人申请驾照处罚"><a href="#个人申请驾照处罚" class="headerlink" title="个人申请驾照处罚"></a>个人申请驾照处罚</h3><p>虚假材料500 一年不得 （不予受理&amp;不予办理，因为你是虚假的）</p><p>考试作弊1000 一年不得</p><p>行贿欺骗2000 三年不得</p><h3 id="驾驶证造假"><a href="#驾驶证造假" class="headerlink" title="驾驶证造假"></a>驾驶证造假</h3><p>2000-5000</p><h3 id="超速50"><a href="#超速50" class="headerlink" title="超速50%"></a>超速50%</h3><p>200-2000</p><p>吊销驾驶证</p><h3 id="肇事罪"><a href="#肇事罪" class="headerlink" title="肇事罪"></a>肇事罪</h3><p><strong>明知是无牌或是已经报废的机动车还上路</strong>，闯祸了就是肇事罪 | 逃离现场被判罪的 也是肇事罪（肇事逃逸）</p><p>（<strong>没带驾驶证，没抢救，没报警的都不算肇事罪</strong>）</p><p>主要有三个档次：3年 3-7 7</p><p>致人死亡，<strong>重大事故</strong> <strong>没逃跑</strong> 3年以下</p><p>重大事故死亡+逃逸 3-7</p><p>因逃逸死亡 7年以上</p><p>补充：没犯罪肇事逃跑 200~2000 拘役15天</p><h3 id="学法减分作假"><a href="#学法减分作假" class="headerlink" title="学法减分作假"></a>学法减分作假</h3><p>意思就是通过 参加交通安全教育 来 扣减交通违法行为积分</p><p><strong>如果你弄虚作假了 -1000</strong></p><h3 id="给无证驾驶开"><a href="#给无证驾驶开" class="headerlink" title="给无证驾驶开"></a>给无证驾驶开</h3><p>吊销驾驶证</p><p>200-2000</p><h3 id="拼装报废车还开上路"><a href="#拼装报废车还开上路" class="headerlink" title="拼装报废车还开上路"></a>拼装报废车还开上路</h3><p>吊销<strong>驾驶证</strong>（行驶证没有）</p><p>200-2000</p><h3 id="审验处罚"><a href="#审验处罚" class="headerlink" title="审验处罚"></a>审验处罚</h3><p>机动车<strong>驾驶人</strong>参加审验教育时在签注学习记录、学习过程中弄虚作假的 罚1000，<strong>不会扣驾驶证</strong></p><p><strong>代替实际机动车驾驶人参加审验教育的</strong> 罚2000</p><p><strong>组织</strong>他人实施前两款行为之一，有违法所得的，由公安机关交通管理部门处违法所得<strong>三倍以下罚款，但最高不超过二万</strong>元；没有违法所得的，由公安机关交通管理部门处二万元以下罚款</p><p>逾期不参加审验仍驾驶机动车的，罚款<strong>200-500元</strong></p><h3 id="饮酒"><a href="#饮酒" class="headerlink" title="饮酒"></a>饮酒</h3><p>初次 扣六个月 1000-2000</p><p>再次饮酒驾驶 吊销驾驶证 10日拘留 1000-2000</p><h2 id="满分学习"><a href="#满分学习" class="headerlink" title="满分学习"></a>满分学习</h2><p>机动车驾驶人在一个记分周期内累积记分满12分的：</p><ul><li>应当按规定参加为期<strong>一周</strong>满分学习、考试</li><li>扣留驾驶证</li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224225741800.png"></p><p>满12未满24，道路驾驶技能考试合格后</p><p>满36，场地和道路驾驶技能考试合格后</p><hr><p>满分学习减免时，驾驶人<strong>参加现场学习、网络学习的天数累计不得少于5天，现场学习的天数不得少于2天</strong></p><p>满分学习是为期<strong>七天</strong>的道路交通安全法律、法规和相关知识学习（小车一周，大车一个月）</p><h2 id="实习期"><a href="#实习期" class="headerlink" title="实习期"></a>实习期</h2><p>实习期需要贴一个标志</p><p>实习期可以上高速（三年以上老司机）</p><p>实习期是<strong>一年</strong></p><h2 id="计分减免-amp-学法减分"><a href="#计分减免-amp-学法减分" class="headerlink" title="计分减免&amp;学法减分"></a>计分减免&amp;学法减分</h2><p>在一个记分周期累计没有扣满12分是可以参加的，但是<strong>最多只能减免6分</strong></p><p>网学半小时考试合格减扣1分</p><p>现场学习一小时合格减扣2分</p><p><strong>参加公益活动一小时减扣1分</strong></p><p>受过酒驾处罚的，在<strong>三个记分周期内不得参加计分减免</strong></p><h2 id="各种道的编号"><a href="#各种道的编号" class="headerlink" title="各种道的编号"></a>各种道的编号</h2><p>国道红底白字 G开头</p><p>省道黄底黑字 S开头</p><p>县道X开头</p><p>乡道白底黑字 Y开头</p><h2 id="各种标识"><a href="#各种标识" class="headerlink" title="各种标识"></a>各种标识</h2><p><a href="https://zhuanlan.zhihu.com/p/539814159">仪表盘上各个图标意思？——汽车仪表盘故障灯、指示灯图标图解大全 - 知乎 (zhihu.com)</a></p><h3 id="交叉路口"><a href="#交叉路口" class="headerlink" title="交叉路口"></a>交叉路口</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223161844927.png" style="zoom:50%;" /><h3 id="雾灯"><a href="#雾灯" class="headerlink" title="雾灯"></a>雾灯</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223163117811.png" style="zoom:50%;" /><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223163140455.png" style="zoom:50%;" /><h3 id="急转弯-amp-连续弯路-amp-反向弯路-amp-下坡"><a href="#急转弯-amp-连续弯路-amp-反向弯路-amp-下坡" class="headerlink" title="急转弯 &amp; 连续弯路 &amp; 反向弯路 &amp; 下坡"></a>急转弯 &amp; 连续弯路 &amp; 反向弯路 &amp; 下坡</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223163231699.png" style="zoom:50%;" /><h3 id="道路出入口"><a href="#道路出入口" class="headerlink" title="道路出入口"></a>道路出入口</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223163449177.png" style="zoom:50%;" /><h3 id="人行道"><a href="#人行道" class="headerlink" title="人行道"></a>人行道</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223163937617.png" style="zoom:50%;" /><h3 id="前后位置灯"><a href="#前后位置灯" class="headerlink" title="前后位置灯"></a>前后位置灯</h3><p>也叫做示廓灯</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223164153977.png" style="zoom:50%;" /><h3 id="避障路段"><a href="#避障路段" class="headerlink" title="避障路段"></a>避障路段</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223164214352.png" style="zoom:50%;" /><h3 id="主干道优先"><a href="#主干道优先" class="headerlink" title="主干道优先"></a>主干道优先</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223164227450.png" style="zoom:50%;" /><h3 id="禁止和解除禁止"><a href="#禁止和解除禁止" class="headerlink" title="禁止和解除禁止"></a>禁止和解除禁止</h3><p>红色圈是禁止</p><p>黑色圈是解除禁止</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223164633286.png" style="zoom:50%;" />**</p><h3 id="停车区"><a href="#停车区" class="headerlink" title="停车区"></a>停车区</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223165022184.png" style="zoom:50%;" /><h3 id="隧道出口"><a href="#隧道出口" class="headerlink" title="隧道出口"></a>隧道出口</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223165107842.png" style="zoom:50%;" /><h3 id="离合减速加速"><a href="#离合减速加速" class="headerlink" title="离合减速加速"></a>离合减速加速</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223200727572.png" style="zoom:50%;" /><h3 id="仪表指示灯"><a href="#仪表指示灯" class="headerlink" title="仪表指示灯"></a>仪表指示灯</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201125441.png" style="zoom:50%;" /><h3 id="左单行"><a href="#左单行" class="headerlink" title="左单行"></a>左单行</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201209625.png" style="zoom:50%;" /><h3 id="单侧通行"><a href="#单侧通行" class="headerlink" title="单侧通行"></a>单侧通行</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201227078.png" style="zoom:50%;" /><h3 id="双黄实线"><a href="#双黄实线" class="headerlink" title="双黄实线"></a>双黄实线</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201243541.png" style="zoom:50%;" /><p>禁止跨越对向车道分界线（因为实线不可跨越）</p><h3 id="机油压力低"><a href="#机油压力低" class="headerlink" title="机油压力低"></a>机油压力低</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201421235.png" style="zoom:50%;" /><h3 id="铁路"><a href="#铁路" class="headerlink" title="铁路"></a>铁路</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201626069.png" style="zoom:50%;" /><h3 id="转向灯开关方向"><a href="#转向灯开关方向" class="headerlink" title="转向灯开关方向"></a>转向灯开关方向</h3><p>向上拨 &#x3D; 右转</p><p>向下拨 &#x3D; 左转</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201643116.png" style="zoom:50%;" /><h3 id="驼峰桥"><a href="#驼峰桥" class="headerlink" title="驼峰桥"></a>驼峰桥</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201716675.png" style="zoom:50%;" /><p>跳车的是两个波峰</p><h3 id="渡口"><a href="#渡口" class="headerlink" title="渡口"></a>渡口</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223202322298.png" style="zoom:50%;" /><h3 id="注意行人"><a href="#注意行人" class="headerlink" title="注意行人"></a>注意行人</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224143830946.png" style="zoom:50%;" /><h3 id="停车让行-amp-减速让行"><a href="#停车让行-amp-减速让行" class="headerlink" title="停车让行 &amp; 减速让行"></a>停车让行 &amp; 减速让行</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224144512430.png" style="zoom:50%;" /><p>双白实线+停 &#x3D; 停车让行</p><p>双白虚线 &#x3D; 减速让行</p><h3 id="禁止通行-amp-禁止驶入"><a href="#禁止通行-amp-禁止驶入" class="headerlink" title="禁止通行&amp;禁止驶入"></a>禁止通行&amp;禁止驶入</h3><ul><li>禁止驶入——仅限制“不得进入该区段”，一旦在允许时段进入，后续行驶不受限制</li><li>禁止通行——<strong>即便在允许时段进入，时间一到，也不得继续行走、行驶</strong></li></ul><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224145608009.png" style="zoom:50%;" /><h3 id="距离无人看守"><a href="#距离无人看守" class="headerlink" title="距离无人看守"></a>距离无人看守</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224155914184.png" style="zoom:50%;" /><p>有栅栏的表示有人</p><p>没栅栏的表示没人</p><p>一停二看三通过</p><p>没人看守的路口，停车确认安全后通过</p><h3 id="一把尺子是积水"><a href="#一把尺子是积水" class="headerlink" title="一把尺子是积水"></a>一把尺子是积水</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224160119036.png" style="zoom:50%;" /><h3 id="近光灯远光灯"><a href="#近光灯远光灯" class="headerlink" title="近光灯远光灯"></a>近光灯远光灯</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224160234651.png" style="zoom:50%;" /><h3 id="车门锁住开锁"><a href="#车门锁住开锁" class="headerlink" title="车门锁住开锁"></a>车门锁住开锁</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224160353773.png" style="zoom:50%;" /><h3 id="障碍物警告"><a href="#障碍物警告" class="headerlink" title="障碍物警告"></a>障碍物警告</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224161222938.png" style="zoom:50%;" /><h3 id="注意儿童-amp-学校"><a href="#注意儿童-amp-学校" class="headerlink" title="注意儿童 &amp; 学校"></a>注意儿童 &amp; 学校</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224161300849.png" style="zoom:50%;" /><h3 id="落石"><a href="#落石" class="headerlink" title="落石"></a>落石</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224161458713.png" style="zoom:50%;" /><h3 id="电动自行车道"><a href="#电动自行车道" class="headerlink" title="电动自行车道"></a>电动自行车道</h3><p>仅能电动车通行</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224225324686.png" style="zoom:50%;" /><h3 id="向左转弯-amp-合流"><a href="#向左转弯-amp-合流" class="headerlink" title="向左转弯&amp;合流"></a>向左转弯&amp;合流</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224225619600.png" style="zoom:50%;" /><h3 id="窄桥"><a href="#窄桥" class="headerlink" title="窄桥"></a>窄桥</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224230558371.png" style="zoom:50%;" /><h3 id="潮汐车道"><a href="#潮汐车道" class="headerlink" title="潮汐车道"></a>潮汐车道</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224230740751.png" style="zoom:50%;" /><h2 id="方向相关"><a href="#方向相关" class="headerlink" title="方向相关"></a>方向相关</h2><h3 id="急转弯"><a href="#急转弯" class="headerlink" title="急转弯"></a>急转弯</h3><p>急转弯一定要 <strong>减速 靠右行驶</strong></p><h3 id="让行"><a href="#让行" class="headerlink" title="让行"></a>让行</h3><p>三个先行原则：</p><ul><li><strong>转弯 让 直行</strong>，直行优先</li><li>右方来车先行</li><li>右转让左转先行</li></ul><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223164450522.png" style="zoom:50%;" /><h2 id="酒驾"><a href="#酒驾" class="headerlink" title="酒驾"></a>酒驾</h2><p>酒驾 -12 分</p><p>酒驾小车 5 年不得申领</p><p>酒驾<strong>运营机车</strong> 吊销驾驶证，<strong>10年不得申领</strong></p><p>同时 3 个记分周期不能进行计分减免补分</p><p>判断依据：80mg&#x2F;100ml</p><h3 id="初次-amp-再次"><a href="#初次-amp-再次" class="headerlink" title="初次 &amp; 再次"></a>初次 &amp; 再次</h3><p>初次 扣六个月 1000-2000</p><p>再次饮酒驾驶 吊销驾驶证 10日拘留 1000-2000</p><h2 id="掉头-amp-变更车道-amp-超车"><a href="#掉头-amp-变更车道-amp-超车" class="headerlink" title="掉头 &amp; 变更车道 &amp; 超车"></a>掉头 &amp; 变更车道 &amp; 超车</h2><p>掉头需要驶入掉头车道</p><p>在驶入掉头车道的时候需要变道，变道<strong>只能在虚线处变更车道</strong></p><p>超车只能<strong>从左侧超车</strong></p><h2 id="速度相关"><a href="#速度相关" class="headerlink" title="速度相关"></a>速度相关</h2><h3 id="冰雪"><a href="#冰雪" class="headerlink" title="冰雪"></a>冰雪</h3><p>最高 <strong>30</strong></p><h3 id="无中心线"><a href="#无中心线" class="headerlink" title="无中心线"></a>无中心线</h3><p>城市30 公路40</p><h3 id="有中心线"><a href="#有中心线" class="headerlink" title="有中心线"></a>有中心线</h3><p>城5 公7</p><h3 id="非机动车道"><a href="#非机动车道" class="headerlink" title="非机动车道"></a>非机动车道</h3><p>在非机动车道行驶最高 30</p><h3 id="雨天行车"><a href="#雨天行车" class="headerlink" title="雨天行车"></a>雨天行车</h3><p>不能紧急制动</p><p>应使用<strong>发动机制动减速</strong></p><h3 id="平坦路面颠簸感"><a href="#平坦路面颠簸感" class="headerlink" title="平坦路面颠簸感"></a>平坦路面颠簸感</h3><p>迅速降低车速 &#x3D; 迅速反应开始缓慢减速</p><p>防止爆胎</p><h3 id="能见度"><a href="#能见度" class="headerlink" title="能见度"></a>能见度</h3><p>低于50m 20的速度，<strong>尽快驶离</strong></p><p>低于100m 40速度 50车距</p><p>低于200m 60速度 100车距</p><p>261 145 520</p><h3 id="窄路窄桥"><a href="#窄路窄桥" class="headerlink" title="窄路窄桥"></a>窄路窄桥</h3><p>最高 30</p><h3 id="转弯掉头下陡坡"><a href="#转弯掉头下陡坡" class="headerlink" title="转弯掉头下陡坡"></a>转弯掉头下陡坡</h3><p>最高 30</p><h3 id="超车"><a href="#超车" class="headerlink" title="超车"></a>超车</h3><p>隧道和陡坡都不能超车</p><h3 id="高速车道限速"><a href="#高速车道限速" class="headerlink" title="高速车道限速"></a>高速车道限速</h3><p>两车道：</p><p><strong>两条车道 6-10 10-12（100-120）</strong></p><p>三车道：</p><p>从右到左6-9 9-11 11-12</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>转弯掉头下陡坡、冰雪天、窄路窄桥、非机动车道 都是30最高</p><p><strong>能见度低于 50m 的，最高20</strong></p><h2 id="开车基本素质"><a href="#开车基本素质" class="headerlink" title="开车基本素质"></a>开车基本素质</h2><h3 id="没有信号灯交叉路口"><a href="#没有信号灯交叉路口" class="headerlink" title="没有信号灯交叉路口"></a>没有信号灯交叉路口</h3><p>需要<strong>交替使用近远光灯</strong></p><h3 id="休息"><a href="#休息" class="headerlink" title="休息"></a>休息</h3><p><strong>连续驾驶 4 小时以上，需要休息 20 分钟</strong></p><h3 id="安全头枕"><a href="#安全头枕" class="headerlink" title="安全头枕"></a>安全头枕</h3><p>主要是防止撞车的时候，<strong>颈部</strong>受伤</p><h3 id="有积水路面"><a href="#有积水路面" class="headerlink" title="有积水路面"></a>有积水路面</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224160055275.png" style="zoom:50%;" /><p>慢速通过</p><h3 id="轻微财产损失事故"><a href="#轻微财产损失事故" class="headerlink" title="轻微财产损失事故"></a>轻微财产损失事故</h3><p>无争议的可以<strong>自行撤离</strong>后面协商</p><h3 id="遇到堵车"><a href="#遇到堵车" class="headerlink" title="遇到堵车"></a>遇到堵车</h3><p>排队等候</p><p>必要的时候开双闪警告，防止追尾</p><h3 id="停车打灯"><a href="#停车打灯" class="headerlink" title="停车打灯"></a>停车打灯</h3><p>停车的时候都是靠右边停车的</p><p>因此需要提前打右转向灯</p><h3 id="夜间会车"><a href="#夜间会车" class="headerlink" title="夜间会车"></a>夜间会车</h3><p><strong>150m开外</strong>就需要切换成近光灯</p><p>不要等到人过来的时候再切换，不然会晃眼睛</p><p>对方一直开远光灯，可以交替闪他，如果再不关就靠右减速</p><h3 id="校车礼让"><a href="#校车礼让" class="headerlink" title="校车礼让"></a>校车礼让</h3><p>一条车道，后方车辆等待</p><p>两条以上车道，校车后方+相邻车道等待，其他车道减速</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240224230008074.png" style="zoom:50%;" /><h3 id="对向来车占道"><a href="#对向来车占道" class="headerlink" title="对向来车占道"></a>对向来车占道</h3><p>打不过<strong>礼让</strong>他</p><h3 id="口五站三"><a href="#口五站三" class="headerlink" title="口五站三"></a>口五站三</h3><p>口五：</p><ul><li>交叉路口</li><li>铁路口</li><li><strong>宽度不足4m弯道窄路</strong></li><li>隧道</li></ul><p>站三 30m内：</p><ul><li>公交站</li><li>加油站</li><li>消防站</li></ul><p>都不可以停车的</p><h3 id="人车"><a href="#人车" class="headerlink" title="人车"></a>人车</h3><p>只要没有提到行人<strong>故意</strong>碰撞机动车的，机动车一方就要承担赔偿责任</p><p>机动车与行人发生事故，<strong>机动车一方无过错的，承担不超过10%的赔偿责任</strong></p><h3 id="前后"><a href="#前后" class="headerlink" title="前后"></a>前后</h3><p>货物散落，导致后车被撞，货车全责</p><h3 id="黄灯"><a href="#黄灯" class="headerlink" title="黄灯"></a>黄灯</h3><p>已经过线的可以继续行驶</p><p>未越过线的停下等待</p><h2 id="交警手势"><a href="#交警手势" class="headerlink" title="交警手势"></a>交警手势</h2><h3 id="减速慢行"><a href="#减速慢行" class="headerlink" title="减速慢行"></a>减速慢行</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201539830.png" style="zoom:50%;" /><h3 id="左转弯信号"><a href="#左转弯信号" class="headerlink" title="左转弯信号"></a>左转弯信号</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240223201603321.png" style="zoom:50%;" /><h2 id="名下牌照互换"><a href="#名下牌照互换" class="headerlink" title="名下牌照互换"></a>名下牌照互换</h2><p>申请前 两辆车 <strong>无未处理的记录</strong></p><p>三条件同时满足：</p><ul><li>同一辖区车管所等级</li><li><strong>同一号牌种类</strong></li><li>使用性质必须为<strong>非营运</strong></li></ul><h2 id="盘点"><a href="#盘点" class="headerlink" title="盘点"></a>盘点</h2><h3 id="需要重新考试"><a href="#需要重新考试" class="headerlink" title="需要重新考试"></a>需要重新考试</h3><ul><li>扣满12分，为期7天</li><li>12-24 重学科三</li><li>36 重学科二+科三</li><li>驾驶证过期2年 重学科目一</li></ul><h1 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h1><h2 id="启动准备"><a href="#启动准备" class="headerlink" title="启动准备"></a>启动准备</h2><p>上车之前首先在车身外边检查车号码是否正确，停在正确的道上</p><p>坐下之前检查四个车门是否关好并观察车辆是否在点火状态（指针指向靠近1的位置）</p><p>如果没有点火需要进行点火操作：<strong>挂P挡</strong> <strong>踩脚刹</strong>，按住启动按钮&#x2F;扭动钥匙启动车辆</p><p>调整座椅前后及靠背高低，<strong>高低是杠杆上下撬动翘起来的，翘到最高；座椅推到最后，角度大概居中，使得坐正的时候和车顶距离一个手掌塞进去的距离</strong>；<strong>前后位置是肚子距离方向盘三个拳头，手臂展开差不多手腕碰到方向盘</strong></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240320225932149.png" alt="后视镜位置"></p><p>完全检查调整好后，最后系安全带，进行人脸识别验证</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p><strong>先挂D挡再放手刹 松脚刹 起步</strong></p><h2 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h2><p>全程车速放慢</p><p>往哪边倒，往那边打死，看那边镜子</p><h3 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h3><p>在车上找一个基准点：<strong>左侧铆钉正对第二格黄线虚线右边</strong>，开到黄色虚线到肩膀，挂倒挡，看左镜</p><h3 id="右侧入库"><a href="#右侧入库" class="headerlink" title="右侧入库"></a>右侧入库</h3><p>当左镜下边缘和黄色虚线还差两个手指的距离时，右打死，看右镜</p><p><strong>直角和前门差一&#x2F;两个手指</strong>的时候，回正，继续看右镜</p><p>当直角快要穿过门把的瞬间，右打死，看左镜</p><p><strong>后门【快要】和黄线平行</strong>的时候，回正，倒车管直</p><p>当<strong>外侧左后视镜下方</strong>对<strong>黄线的下边缘</strong>重合的时候，停车</p><h3 id="出库"><a href="#出库" class="headerlink" title="出库"></a>出库</h3><p>慢速直行</p><p>当车头盖过黄线的时候，左打死</p><p>之后感觉快正了回正</p><p>肩膀和黄色虚线对齐时到点停下</p><h3 id="左侧入库"><a href="#左侧入库" class="headerlink" title="左侧入库"></a>左侧入库</h3><p>左镜下边缘差黄线一个手指头<strong>左打死，看左镜</strong></p><p>观察<strong>前门把和直角之间的距离</strong>，差一个手指头回正</p><p>前门把穿过直角瞬间左打死</p><p><strong>车屁股</strong>和黄线<strong>平行靠左一丢丢</strong>回正，回正之后就是管直，准备停车（速度一定要放慢）</p><p>当<strong>外侧左后视镜下方</strong>对<strong>黄线的下边缘</strong>重合的时候，停车</p><blockquote><p>如果起点没有走好，导致第一个左打死之后，前门把和直角之间的太宽了，可以直接<strong>一把过不用打两把的打死</strong></p></blockquote><h2 id="侧方停车"><a href="#侧方停车" class="headerlink" title="侧方停车"></a>侧方停车</h2><p><strong>全程车速放慢</strong></p><h3 id="起点切边线"><a href="#起点切边线" class="headerlink" title="起点切边线"></a>起点切边线</h3><p>在车上<strong>右侧雨刮器倒数第三个铆钉所在的那一块不规则弧角的角尖</strong>对准黄线外边缘，走到起点的过程中看远走直</p><p>等到黄色直角到右侧后视镜中间偏上快到顶的位置就算到达起点</p><h3 id="入库"><a href="#入库" class="headerlink" title="入库"></a>入库</h3><p>挂倒挡观察右侧镜</p><p>直角<strong>快要消失</strong>的时候<strong>右打死</strong>，切换到左侧镜</p><p>看到<strong>黄色直角</strong>出现的时候立刻回正，看车轮</p><p>看<strong>前门把</strong>和黄色虚线<strong>外边缘</strong>重合**时，左打死入库，继续看左侧镜</p><p>当车身和左侧镜中黄色虚线<strong>平行靠右一点</strong>的时候就可以<strong>停车</strong>了</p><p><strong>停车之后原地回正</strong></p><h3 id="出库-1"><a href="#出库-1" class="headerlink" title="出库"></a>出库</h3><p>挂D档，打<strong>左转向灯</strong>，左打死，观察左侧镜</p><p><strong>黄色直角出现完整</strong>的时候立刻回正，看前方实线和基准点的位置</p><p>基准点碰到黄线内侧的瞬间<strong>往右打一圈</strong>（根据timing可以适当调整往右打圈的程度）</p><p>差不多正了之后立刻回正</p><h2 id="考场花圃"><a href="#考场花圃" class="headerlink" title="考场花圃"></a>考场花圃</h2><p>根据自己考场所在道的位置，关键在于看远走直，肩膀到花圃的时候左&#x2F;右打死，速度放慢</p><h2 id="曲线行驶"><a href="#曲线行驶" class="headerlink" title="曲线行驶"></a>曲线行驶</h2><h3 id="起点-1"><a href="#起点-1" class="headerlink" title="起点"></a>起点</h3><p>雨刮器<strong>左侧突起</strong>和人在<strong>路中间</strong></p><h3 id="第一个左弯"><a href="#第一个左弯" class="headerlink" title="第一个左弯"></a>第一个左弯</h3><p><strong>左侧车头</strong>盖过黄线（车头偏左位置的时候，也就是慢个1s左右） <strong>左打一圈</strong>，看角度，保持角度让它不要出去</p><p>发现角度在变小了就往左调90，1-2s回正，如此往复（也可以保持45度推，窄了就一圈端平，还宽就90度推）</p><p>内侧弯道变直道之后<strong>保持90</strong>，看左侧车头</p><h3 id="第二个右弯"><a href="#第二个右弯" class="headerlink" title="第二个右弯"></a>第二个右弯</h3><p>左侧车头盖到黄线后 快速回正（此时应该是左一圈+90度）看车头</p><p>等外侧黄线<strong>在车中间偏右边（也就是慢个1s左右）时候右打一圈</strong>，保持角度让它不要出去，小了就往右调90，1-2s回正，也可以保持45度推（<strong>右侧镜变化慢，要保持距离黄线3-4个手指宽，主要看车头</strong>）</p><p>最后要出去的时候凭感觉 快要正时回正</p><h2 id="直角转弯"><a href="#直角转弯" class="headerlink" title="直角转弯"></a>直角转弯</h2><h3 id="起点-2"><a href="#起点-2" class="headerlink" title="起点"></a>起点</h3><p>保持直行车道 雨刮器的<strong>左侧铆钉</strong> 距离 <strong>左边线 两根手指宽</strong></p><p><strong>一定要记得打右转灯！</strong></p><h3 id="一个右打死"><a href="#一个右打死" class="headerlink" title="一个右打死"></a>一个右打死</h3><p>拉完边线，车头距离前方黄线两个手指时看右边 <strong>车窗按钮的部位</strong> 对黄线上方的时候，右打死</p><p>快要回正的时候回正，看远走直行驶</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>在倒车寻找点位和线对其的时候，<strong>哪边宽往那边打</strong></p><p>倒车入库，管直停车，大左小右</p><p>考试的时候：语音报下一个项目：xxx，表示项目还没开始，可以停观察一下前面情况</p><p>当报两次 xxx 的时候才是正式开始，这个时候不能中途停车了</p><h1 id="科目三"><a href="#科目三" class="headerlink" title="科目三"></a>科目三</h1><h2 id="暗号"><a href="#暗号" class="headerlink" title="暗号"></a>暗号</h2><p>长吐气 &#x3D; 加油</p><p>短吸气 &#x3D; 松油</p><p>短吐气2声 &#x3D; 可以起步和起步推方向4s后的回方向盘+转向灯</p><p>地毯地下发出声音 &#x3D; 停车</p><p>座位发出声音 &#x3D; 点踩刹车三秒左右观察</p><h2 id="考试注意细节"><a href="#考试注意细节" class="headerlink" title="考试注意细节"></a>考试注意细节</h2><p>科目三不像科目二那样每一个项目都有汇报是否通过，只会汇报扣分，扣到低于90分不及格才会汇报，否则就是直到做完整个项目才会给你汇报一个考试通过</p><p>考试的全程手都需要放在方向盘上，防止考官人工判不合格</p><p>关灯需要单手脱离方向盘，不然发力的时候会导致带歪方向</p><p>点刹感觉到减速即可，不要把速度减没了</p><p>点刹的实机不要早于教练的暗号，不然是无效的</p><p>科三的三条线路，掉头过来都是公交站，因此注意路口<strong>掉完头就需要点刹</strong></p><h2 id="上车准备"><a href="#上车准备" class="headerlink" title="上车准备"></a>上车准备</h2><p>车身上的号码就是代表靠边停车的单双号，例如58</p><p>上车人脸验证（<strong>手放在方向盘上，可以不系安全带</strong>），粗略调好位置后，<strong>听到语音说验证成功，可以开始考试，上车准备这四个字</strong> 后说明各个装置工作正常，下车</p><p>下车（<strong>右手开，左手推，侧头观察，轻关门</strong>）<strong>逆时针</strong>走一圈</p><p>挡感应器4S左右</p><p>踢轮胎</p><p>上车以后最终确定座位，调镜子，和科目二的镜子不一样，<strong>科目三的镜子要能看到左右两边的全景</strong></p><p>左右镜子的后门把都要在镜子的中间，然后整体占三分之一左右的位置</p><p>踩踩踏板，开始灯光考试（两下双闪开启）</p><h2 id="灯光考试"><a href="#灯光考试" class="headerlink" title="灯光考试"></a>灯光考试</h2><p>考试开始按两下双闪触发考试开始按钮</p><p>一开始会让你切换到近光灯模式，之后听题目：</p><ul><li>夜间进入灯光差&#x2F;无灯光 —&gt; 切换到远光灯常驻（推一下）</li><li>路边停车：示廓灯+双闪</li></ul><p>其他全部都不知道，不知道的分两种状态：</p><ul><li>近光灯常驻：拨两次</li><li>远光灯常驻：拨三次</li></ul><p>灯光考试结束后，语音报请前进，这个时候听教练指挥，准备起点起步之后准备超车</p><p><strong>拨灯光的时候注意手势要顺着拨杆</strong>，防止碰到转向灯</p><h2 id="起点起步"><a href="#起点起步" class="headerlink" title="起点起步"></a>起点起步</h2><p>先打左灯，之后听轻吐气暗号，重踩刹车，挂D挡，再松手刹</p><p><strong>推90度</strong>+松油（缓缓抬起松油），<strong>不能立刻踩油的情况下推4s后回正，这个时候灯自己会跳</strong></p><p><strong>不能立刻踩油！！</strong></p><p>已经起步拉回方向跳灯了，就可以不用再打灯了，不然倒扣分</p><p>教练暗号往左意思是让你往左拉一点，这个时候也不需要再打灯了，已经出来了打一次灯就行，不然就是倒扣分</p><h2 id="超车-1"><a href="#超车-1" class="headerlink" title="超车"></a>超车</h2><p>打左灯，提速，松油，观察，变道</p><p>之后车身正了之后，立刻重复（因为超车项目也有距离限制）</p><p>打右灯，提速，松油，观察，变道</p><p>超车做完之后过电线杆的时候，车身回正的时候就可以打右灯了</p><h2 id="掉头"><a href="#掉头" class="headerlink" title="掉头"></a>掉头</h2><p>掉头的时候主要还是看前面，后面的车辆<strong>，回头90度</strong>看一下有没有就行，因为掉头还是要往前走的，如果一直看后面有没有来车，等会前面撞了</p><p><strong>就算是后面有车，前面没车，你方向打一下一脚油门也能拉开距离</strong></p><p>在掉头的路口，<strong>减速打左灯</strong>：</p><ul><li>如果对向有来车，需要<strong>停车</strong>等待</li><li>如果对向没车，需要点刹，最好停车，监考直接无话可说</li></ul><p>四周扭头90观察之后，确定没车了，再送刹推方向掉头，快要回正的时候回正</p><h2 id="左转右转车道选择"><a href="#左转右转车道选择" class="headerlink" title="左转右转车道选择"></a>左转右转车道选择</h2><p>要去对应的车道</p><p><strong>掉头算是特殊的左转</strong>，需要在回正的时候的那个车道，选好就不要再变了，不然会直接判你压线不合格</p><p>右转也比较特殊，右转一般都是到最右边的那个车道</p><h2 id="变道"><a href="#变道" class="headerlink" title="变道"></a>变道</h2><p>打转向灯后，要<strong>左右45度观察</strong></p><p>观察三秒之后就可以推方向过去了</p><p>千万<strong>不能先推方向然后等三秒</strong>，不然就叛你长期侵占道路中心线，直接不合格</p><p>因此推方向过去的时候应该是一气呵成而不是犹犹豫豫的</p><p>同时需要看同向来车速度：慢的我们加速，一般都是快，所以打灯就松油。<strong>如果车特别多，可以停车等待</strong>。<strong>千万不能再踩油门了，因为变道有距离限制</strong></p><p><strong>斑马线前后不能打灯和变道</strong></p><h2 id="直线行驶"><a href="#直线行驶" class="headerlink" title="直线行驶"></a>直线行驶</h2><p>核心在于控制速度，速度快了容易飘，速度慢了地面不平很容易歪</p><p>速度控制在30最好，<strong>看远走直</strong>，找好远处的参照物</p><p>前方出现问题可以减速甚至是停车</p><h2 id="靠边停车"><a href="#靠边停车" class="headerlink" title="靠边停车"></a>靠边停车</h2><p>回到内场超车之后过电线杆车身回正就可以打右灯了</p><p>减速打右灯</p><p>雨刮器第三个钉靠白色线之后停车</p><p>先P档，再手刹，最后关灯（<strong>不能低头看挡位</strong>，可以看仪表盘，<strong>假装在左右张望最佳</strong>）</p><p>起步的时候也是先打灯，然后D档松手刹，靠边停车的起步可以踩油，<a href="#%E8%B5%B7%E7%82%B9%E8%B5%B7%E6%AD%A5">起点起步有四秒的不能踩油</a></p><h2 id="回场"><a href="#回场" class="headerlink" title="回场"></a>回场</h2><p>回场的时候类似回驾校的那个虎口</p><p>会占用非机动车道几秒钟，这个时候一定要注意右边同向过来的电动车，扭头观察</p><h2 id="科目三灯跳了要不要补灯"><a href="#科目三灯跳了要不要补灯" class="headerlink" title="科目三灯跳了要不要补灯"></a>科目三灯跳了要不要补灯</h2><p>很简单的一个原则：</p><ul><li>项目还没做完在去做的过程中跳了，需要补，并且根据情况往前开三秒钟<ul><li>例如：靠边停车没有停下来都要打灯</li></ul></li><li>项目做完了跳灯不需要补<ul><li>例如：起步方向拉回来了不需要再补灯</li></ul></li></ul><h2 id="科目三的点位注意"><a href="#科目三的点位注意" class="headerlink" title="科目三的点位注意"></a>科目三的点位注意</h2><p>桥下掉头：肩膀过花圃的时候打一圈</p><p>斑马线左右转：肩膀完全过最后的斑马线的时候打90度</p><h2 id="临时出现问题应对方式"><a href="#临时出现问题应对方式" class="headerlink" title="临时出现问题应对方式"></a>临时出现问题应对方式</h2><p>让速不让道</p><p>实在不行停车</p><p>只要<strong>不是虚线、实线、黄网都能停车</strong>，直线行驶都能停车</p><h1 id="科目四"><a href="#科目四" class="headerlink" title="科目四"></a>科目四</h1><h2 id="考察范围"><a href="#考察范围" class="headerlink" title="考察范围"></a>考察范围</h2><p>题型和科目一略有重合</p><p>针对课目一中的内容：科目四不考扣分题，罚款题，判刑题，动画题</p><p>科目一：会认，是什么</p><p>科目四：怎么做</p><ul><li>案例分析多选题</li><li>图标手势题</li></ul><h2 id="案例分析题"><a href="#案例分析题" class="headerlink" title="*案例分析题"></a>*案例分析题</h2><p><strong>找关键字，一般都在题目的括号里</strong></p><table><thead><tr><th>关键词</th><th>对应违法行为</th></tr></thead><tbody><tr><td>核载&#x2F;实载&#x2F;承载</td><td>他可能要超载&#x2F;超员了</td></tr><tr><td>路段&#x2F;限速&#x2F;速度</td><td>他可能要超速了</td></tr><tr><td>某日&#x2F;昨日&#x2F;次日</td><td>他可能是开了一整天疲劳驾驶了</td></tr><tr><td>驾驶证&#x2F;吊销</td><td>他可能是证和车不匹配</td></tr><tr><td>酒精浓度</td><td>20-80酒驾 80以上醉驾</td></tr></tbody></table><p>那么对应需要背住的只有这些：</p><ul><li>A2驾驶证驾驶大型客车：准驾不符</li><li>中型客车&gt;19人：超载了，中型客车10~19</li><li>特殊路段（弯道，交叉路口）&gt;30：限速超速了</li><li>客货高速&gt;100：限速超速了（小轿车是120不能超，客货是100不能超）</li><li>酒精含量&gt;&#x3D;20：酒驾了</li></ul><h3 id="案例分析三步走"><a href="#案例分析三步走" class="headerlink" title="案例分析三步走"></a>案例分析三步走</h3><ul><li>先找三超：超速，超员，超载</li><li>再看人：酒驾，疲劳驾驶</li><li>其他：车是否隐患，准驾不符</li></ul><h2 id="交通信号题"><a href="#交通信号题" class="headerlink" title="交通信号题"></a>交通信号题</h2><h3 id="交警手势-1"><a href="#交警手势-1" class="headerlink" title="交警手势"></a>交警手势</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240720224515189.png"></p><p>转弯信号：一只手掌心在前，<strong>另一只手在下，哪只手在下朝哪儿转</strong></p><p>交警没看我，掌心对我，就停车</p><h3 id="交通标志"><a href="#交通标志" class="headerlink" title="交通标志"></a>交通标志</h3><p>红高蓝低黄建议</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240720224939584.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240720225123689.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240720225132809.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240720225407002.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240720225300521.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240720225308215.png"></p><h3 id="交通标线"><a href="#交通标线" class="headerlink" title="交通标线"></a>交通标线</h3><p>黄高白低（速度）  </p><h2 id="安全文明驾驶"><a href="#安全文明驾驶" class="headerlink" title="安全文明驾驶"></a>安全文明驾驶</h2><h3 id="只要看到都是错的"><a href="#只要看到都是错的" class="headerlink" title="只要看到都是错的"></a>只要看到都是错的</h3><p>紧急制动</p><p>远光灯（非必要不用远光灯）</p><p>加速通过</p><p>疯狂按喇叭</p><p>迅速</p><p>手刹（驻车制动）</p><h3 id="只要看到都是对的"><a href="#只要看到都是对的" class="headerlink" title="只要看到都是对的"></a>只要看到都是对的</h3><p>只要感觉是谨慎安全的行为，都是对的</p><p>先稳方向再减速，非必要不减速</p><h3 id="安全装置"><a href="#安全装置" class="headerlink" title="安全装置"></a>安全装置</h3><ul><li>安全带：只有一个作用：减轻损伤，所有人都要系</li><li>头枕：<strong>保护颈部，支撑头部</strong></li></ul><h3 id="危险品"><a href="#危险品" class="headerlink" title="危险品"></a>危险品</h3><p>只会有两种：</p><ul><li>易燃</li><li>易爆</li></ul><p>带药都是易爆的</p><p>火柴硫磺赤磷这种都是易燃物品</p><h2 id="事故避险-amp-特殊路段题"><a href="#事故避险-amp-特殊路段题" class="headerlink" title="*事故避险&amp;特殊路段题"></a>*事故避险&amp;特殊路段题</h2><h3 id="常见事故"><a href="#常见事故" class="headerlink" title="常见事故"></a>常见事故</h3><p>爆胎，侧滑，碰撞</p><p>制动失效，转向失控</p><h3 id="正确操作"><a href="#正确操作" class="headerlink" title="正确操作"></a>正确操作</h3><p>稳住方向</p><p>抢挂抵挡（不能越二级挂挡）</p><p>不急转，不急刹（<strong>只有事故无法避免的情况下，才能急刹</strong>）</p><h3 id="需要背住"><a href="#需要背住" class="headerlink" title="需要背住"></a>需要背住</h3><p>转向失控——果断连续踩制动踏板，禁止<strong>急刹</strong></p><p>制动失效——减档，发动机制动，避险车道，被迫减速都是可以的，<strong>禁止手刹</strong></p><p>碰撞——<strong>顺势而为</strong>，不能倒反天罡；<strong>车速高可以先制动</strong></p><p>泥泞道路侧滑——<strong>前轮相反，后轮相同</strong>，驱动轮铺石，如果没说，就顺势而为</p><p><strong>涉水路段——间断轻踏</strong></p><p><strong>铁路：道口内不换档</strong></p><p>山区：上坡路段需要<strong>比在平时路段推迟使用行车制动</strong>，下坡要提前；<strong>停车上坡左转，下坡右转</strong>（防止溜下去，撞到马路牙子可以减速）</p><p>环岛：进入不打灯，出去打右转灯</p><p>雪天<strong>临时停车</strong>需要开启双闪</p><p>暴雨天，<strong>立即减速靠边停车</strong>（最稳妥，最安全，选这个）</p><p>雾天：不用远光，<strong>和雾灯锁死</strong>，低能见度，（能见度-车速-跟车距离）261 145 520</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240721213440362.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240720191559224.png"></p><p>爆胎：胎压过高或者过低都会导致爆胎</p><p><strong>先稳方向再减速</strong>，非必要不能急刹（除非事故无法避免）</p><h2 id="急救题"><a href="#急救题" class="headerlink" title="急救题"></a>急救题</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20240720231642081.png"></p><p>抢救没呼吸了 &#x3D; 心肺复苏</p><p>搬运昏迷 &#x3D; <strong>开放气道 &#x3D; 侧卧位</strong></p><h2 id="经典题型技巧"><a href="#经典题型技巧" class="headerlink" title="经典题型技巧"></a>经典题型技巧</h2><h3 id="问注意什么"><a href="#问注意什么" class="headerlink" title="问注意什么"></a>问注意什么</h3><p>优先全选</p><p>然后排除错误选项：加速，远光灯，驻车制动等</p><h3 id="问故障"><a href="#问故障" class="headerlink" title="问故障"></a>问故障</h3><p>打灯放标人转移+报警</p><p>双闪+车后警告标识（高速150以外，普通路段 50-100）+人转移到右侧路肩+报警</p><h3 id="问着火"><a href="#问着火" class="headerlink" title="问着火"></a>问着火</h3><p>不能用水灭火</p><p>不能打开发动机盖</p><p>一定要跑</p><h2 id="让行通行题"><a href="#让行通行题" class="headerlink" title="*让行通行题"></a>*让行通行题</h2><p>右转让左转，转弯让直行，右方先行</p><p>校车：一二停，三减速</p><p>会车让行：靠山让临崖，有障让无障</p><p>超车：<strong>特殊路段不能超车</strong></p><p>高速：进入打左转，驶出打右转</p><p>无线成三公四，有线城5公7</p><h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><h3 id="图表题"><a href="#图表题" class="headerlink" title="图表题"></a>图表题</h3><p><strong>顶角朝那边，哪边通行</strong></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefined26005c29fb9cc0871c549208532d0859.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/undefined80cabe5e51a607f40d18bab21848e67f.png"></p><h3 id="常识题"><a href="#常识题" class="headerlink" title="常识题"></a>常识题</h3><p>胎压 &#x3D; 正常情况下<strong>最大安全充气压力值</strong></p><p>碰撞建筑物，没有年检的都是问题不大，可以移到一边处理；但是没有车牌&#x2F;酒驾，就很严重了，要报警</p><p>只要不影响交通就可以掉头，这句话是对的</p><p><strong>对方鸣喇叭我们也要积极回应</strong></p><p>夜间超车，确实可以远近光等交替使用</p><h4 id="三特找30"><a href="#三特找30" class="headerlink" title="三特找30"></a>三特找30</h4><p>特殊路段限速30</p><p>雨雪雾能见度&lt;50限速30</p><p>故障牵引车限速30</p><h2 id="地方题"><a href="#地方题" class="headerlink" title="地方题"></a>地方题</h2><p>被超车时要<strong>保持减速和匀速</strong>，迅速减速让对方超车</p><p>减速或者停车时，<strong>最大的危险来自后方</strong></p><p>防御性驾驶技术：放眼远方，<strong>顾全大局</strong></p><p>左右后视镜应能看到车身的<strong>四分之一</strong></p><p>往右超车都是错的</p><p><strong>不能避免交通事故发生，只能降低可能性</strong></p><p>夜间在山区道路上行驶，尤其是在陡坡弯道上，可以交替变换近圆光等</p><p>高速催眠：以上都对，避免保持同一个状态，确实可以拨闪光灯</p>]]></content>
    
    
    <categories>
      
      <category>驾照</category>
      
    </categories>
    
    
    <tags>
      
      <tag>职场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 八股</title>
    <link href="/2024/01/05/Java%20%E9%9D%A2%E8%AF%95/"/>
    <url>/2024/01/05/Java%20%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语法基础"><a href="#Java语法基础" class="headerlink" title="Java语法基础"></a>Java语法基础</h1><h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><ul><li>封装</li><li>继承</li><li>多态</li></ul><h2 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM JDK JRE"></a>JVM JDK JRE</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM是指运行 Java 字节码的一个虚拟机，<strong>对不同的平台系统有特定的实现</strong>，程序员只需要编写相同的 Java 代码，交由 JVM 运行字节码，实现跨平台， <strong>字节码和不同系统的 JVM 实现</strong>是 Java 语言 <code>一次编译，随处可以运行</code> 的关键所在</p><p>最常用的 JVM 是 Hotspot JVM</p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>Java 运行时环境，它是<strong>运行已编译 Java 程序所需的所有内容的集合</strong>，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）</p><p>JRE 仅包含 Java 应用程序的运行时环境和必要的类库</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>包含一系列开发功能的 JAVA SDK 提供给开发者用的，用于创建和编译 Java 程序</p><p>JDK 包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等</p><p>此外，对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240103155808731.png" alt="三者的区别"></p><h2 id="如何理解-Java-的编译与解释并存"><a href="#如何理解-Java-的编译与解释并存" class="headerlink" title="如何理解 Java 的编译与解释并存"></a>如何理解 Java 的编译与解释并存</h2><p><strong>编译型</strong>：<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言</a> 会通过<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</p><p><strong>解释型</strong>：<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言</a>会通过<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</p><p>至于为什么说 Java 的编译和解释共存，主要是 Java 先经过编译生成 <strong>字节码</strong> 文件，之后 <strong>JVM 类加载器首先加载字节码文件，再由解释器逐行解释运行</strong>（针对热点代码有 JIT 编译器）</p><h2 id="采用字节码的好处"><a href="#采用字节码的好处" class="headerlink" title="采用字节码的好处"></a>采用字节码的好处</h2><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它<strong>不面向任何特定的处理器，只面向虚拟机</strong></p><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</p><p>所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序<strong>无须重新编译便可在多种不同操作系统的计算机上运行</strong></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231229192650729.png"></p><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器<strong>逐行解释</strong>执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于<strong>运行时编译</strong>：</p><p><strong>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用</strong>。而我们知道，直接获得机器码的运行效率肯定是高于再去走 Java 解释器的</p><p>这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong></p><h2 id="标识符和关键字的区别"><a href="#标识符和关键字的区别" class="headerlink" title="标识符和关键字的区别"></a>标识符和关键字的区别</h2><p>标识符 Identifier 其实就是我们编码的过程中的名字，马甲，称呼</p><p><strong>关键字是特殊含义的标识符</strong></p><h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode()"></a>hashcode()</h2><p>本身是 Object 类的方法，带有 native 关键字是用 C&#x2F;CPP 来实现的</p><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，<strong>判断元素是否在对应容器中的效率会更高</strong>（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><h2 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h2><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><h2 id="String参数传递"><a href="#String参数传递" class="headerlink" title="String参数传递"></a>String参数传递</h2><p>字符串在 Java 中是通过引用传递的，但由于字符串的不可变性，对字符串的任何修改都会创建一个新的字符串对象。因此，原始的字符串对象不会受到方法内部修改的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringParameterExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;Before method call: &quot;</span> + original);<br>        modifyString(original);<br>        System.out.println(<span class="hljs-string">&quot;After method call: &quot;</span> + original);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyString</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">// 在方法内部修改字符串，实际上是创建了一个新的字符串对象</span><br>        str = str + <span class="hljs-string">&quot; World&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;Inside method: &quot;</span> + str);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Object类的方法有哪些"><a href="#Object类的方法有哪些" class="headerlink" title="Object类的方法有哪些"></a>Object类的方法有哪些</h2><p>1．clone方法</p><p> 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。</p><p> 主要是JAVA里<strong>除了 8 种基本类型 (byte short int long float double char boolean ) + String + 包装数据类型 传参数是值传递</strong>，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。</p><p> 2．getClass方法</p><p> final方法，获得运行时类型。</p><p> 3．toString方法</p><p> 该方法用得比较多，一般子类都有覆盖。</p><p> 4．finalize方法</p><p> 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p><p> 5．equals方法</p><p> 该方法是非常重要的一个方法。一般equals和=&#x3D;是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p><p> 6．hashCode方法</p><p> 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p><p> 一般必须满足obj1.equals(obj2)=&#x3D;true。可以推出obj1.hash- Code()&#x3D;&#x3D;obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p><p> 如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。</p><p> 7．wait方法</p><p> wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p><p> 调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p><p> （1）其他线程调用了该对象的 notify 方法。</p><p> （2）其他线程调用了该对象的 notifyAll 方法。</p><p> （3）其他线程调用了 interrupt 中断该线程。</p><p> （4）时间间隔到了。</p><p> 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p><p> 8．notify方法</p><p> 该方法唤醒在该对象上等待的某个线程。</p><p> 9．notifyAll方法</p><p> 该方法唤醒在该对象上等待的所有线程。</p><h2 id="如何比较两个对象"><a href="#如何比较两个对象" class="headerlink" title="如何比较两个对象"></a>如何比较两个对象</h2><p>两种方法：</p><ul><li>equals</li><li>compareTo</li></ul><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>在Java中，每个类都继承自 <code>Object</code> 类，而 <code>Object</code> 类中有一个<code>equals()</code>方法。<strong>默认情况下，<code>equals()</code>方法实现是比较对象的引用是否相等，即比较两个对象是否是同一个对象</strong>。</p><p>如果你想在自定义类中比较对象的内容而非引用，你需要覆盖<code>equals()</code>方法，并在其中实现你自己的比较逻辑。通常，你需要比较对象的属性来确定它们是否相等。</p><h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h3><p>如果你的类实现了<code>Comparable</code>接口，你可以使用<code>compareTo()</code>方法来比较两个对象的大小。这通常用于排序操作。</p><h2 id="函数签名三要素"><a href="#函数签名三要素" class="headerlink" title="函数签名三要素"></a>函数签名三要素</h2><p>方法名，参数列表，返回值</p><p>通过这三点来确定一个函数</p><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>发生在编译期，同一个类中（或者<strong>父类和子类之间也可以</strong>），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写发生在<strong>运行期</strong>，是<strong>子类对父类的允许访问的方法</strong>的实现过程进行重新编写。</p><ol><li><strong>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类</strong>（两同两小一大）</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，<strong>如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象</strong>。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，<strong>包括这个对象所包含的内部对象</strong>。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240110080422323.png"></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="几种实现"><a href="#几种实现" class="headerlink" title="几种实现"></a>几种实现</h2><p>一种是基于JDK实现的，另一种是 CGLIB ，还有ASM的实现</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：提供了在程序运行时获取和执行任意一个类中的方法，代码更加灵活</p><p>缺点：安全问题：无视泛型的类型检查（因为泛型的类型检查发生在编译期间）</p><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>输入输出（I&#x2F;O）流是Java中用于处理输入和输出的一组机制。</p><p>I&#x2F;O流以字节或字符为单位传输数据，用于与文件、网络、设备等进行数据交互。在Java中，I&#x2F;O流主要<strong>分为字节流和字符流</strong>两种类型。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>在 Java 中一个字符一般认为相当于 2 个字节</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)</p><p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口</p><p>对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰</p><h2 id="有了字节流为什么还需要字符流"><a href="#有了字节流为什么还需要字符流" class="headerlink" title="有了字节流为什么还需要字符流"></a>有了字节流为什么还需要字符流</h2><ul><li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li><li>如果我们不知道编码类型就很容易出现乱码问题。</li></ul><p>对于文本类型包含字符数据的，直接用字节流会出现编码格式导致的乱码问题，因此I&#x2F;O 流就干脆提供了一个<strong>直接操作字符</strong>的接口，方便我们平时对字符进行流操作。</p><p><strong>如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</strong></p><p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码</p><p>顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？</p><p><code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p><p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br></code></pre></td></tr></table></figure><p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><h2 id="Spring支持的事务类型有哪些"><a href="#Spring支持的事务类型有哪些" class="headerlink" title="Spring支持的事务类型有哪些"></a>Spring支持的事务类型有哪些</h2><ul><li>声明式</li><li>编程式</li><li>基于注解</li><li>注解驱动</li><li>全局事务</li></ul><h2 id="AOP的应用"><a href="#AOP的应用" class="headerlink" title="AOP的应用"></a>AOP的应用</h2><ul><li>日志</li><li>事务</li><li>异常处理</li><li>性能监控</li></ul><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="SpringBoot核心入口"><a href="#SpringBoot核心入口" class="headerlink" title="SpringBoot核心入口"></a>SpringBoot核心入口</h2><p>在Spring Boot应用中，核心的入口点是<code>SpringApplication</code>类。具体来说，Spring Boot应用的启动是通过<code>public static void main(String[] args)</code>方法实现的，该方法通常位于一个包含<code>@SpringBootApplication</code>注解的主类中。这个主类是Spring Boot应用的启动类，同时也是<code>SpringApplication</code>的一个参数。</p><p>以下是一个简单的Spring Boot应用启动类示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MyApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyApplication</code>类上使用了<code>@SpringBootApplication</code>注解，它包含了多个元注解，其中之一是<code>@SpringBootConfiguration</code>，它表明这是一个Spring Boot配置类。<code>main</code>方法使用<code>SpringApplication.run</code>启动了Spring Boot应用，传递了<code>MyApplication.class</code>作为主要的启动类，以及<code>args</code>数组作为命令行参数。</p><h2 id="SpringBoot常见注解"><a href="#SpringBoot常见注解" class="headerlink" title="SpringBoot常见注解"></a>SpringBoot常见注解</h2><p><strong><code>@SpringBootApplication</code></strong></p><ul><li>包含**<code>@SpringBootConfiguration</code>**<ul><li>包含**<code>@Configuration</code>**</li></ul></li></ul><p>@<strong><code>RestController</code></strong></p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="简单介绍一下是什么"><a href="#简单介绍一下是什么" class="headerlink" title="简单介绍一下是什么"></a>简单介绍一下是什么</h2><p>Spring MVC（Model-View-Controller）是Spring框架的一个模块，用于支持构建基于模型-视图-控制器设计模式的Web应用程序</p><p>它提供了一个灵活的、基于注解的Web框架，用于开发和部署Web应用程序</p><p>Spring MVC被设计为与Spring框架的其他模块（如Spring Core和Spring Data等）无缝集成，提供了一种结构化和模块化的方式来构建Web应用程序</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EagerSingleton</span> &#123;<br><br>    <span class="hljs-comment">// 在类加载时就创建单例实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EagerSingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagerSingleton</span>();<br><br>    <span class="hljs-comment">// 私有构造方法，防止外部实例化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">EagerSingleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 全局访问点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleLazySingleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SimpleLazySingleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SimpleLazySingleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SimpleLazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 懒汉式，在第一次请求时创建实例</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleLazySingleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>线程安全问题？饿汉式是线程安全的，懒汉式不安全</p><p>可以通过双重锁定+同步块来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleCheckedLazySingleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> DoubleCheckedLazySingleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DoubleCheckedLazySingleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleCheckedLazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 双重检查锁定</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (DoubleCheckedLazySingleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleCheckedLazySingleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="装饰器设计模式"><a href="#装饰器设计模式" class="headerlink" title="装饰器设计模式"></a>装饰器设计模式</h2><p>缓冲流是I&#x2F;O流中的一种装饰器，它提供了对底层字节流（或字符流）的缓冲功能，以提高I&#x2F;O性能。在Java中，缓冲流通常通过 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>（用于字节流）以及 <code>BufferedReader</code> 和 <code>BufferedWriter</code>（用于字符流）来实现。这些类都是装饰器类，采用了装饰器设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedStreamsExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建文件输入流</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br>             <span class="hljs-comment">// 将文件输入流包装在缓冲输入流中</span><br>             <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fileInputStream);<br>             <span class="hljs-comment">// 创建文件输出流</span><br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br>             <span class="hljs-comment">// 将文件输出流包装在缓冲输出流中</span><br>             <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bufferedOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fileOutputStream)) &#123;<br><br>            <span class="hljs-comment">// 读取数据并写入到输出流</span><br>            <span class="hljs-type">int</span> byteRead;<br>            <span class="hljs-keyword">while</span> ((byteRead = bufferedInputStream.read()) != -<span class="hljs-number">1</span>) &#123;<br>                bufferedOutputStream.write(byteRead);<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;File copied successfully.&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 分别包装了 <code>FileInputStream</code> 和 <code>FileOutputStream</code>，提供了缓冲的功能。这样的嵌套使用正是装饰器设计模式的体现，通过一系列装饰器来增强原始的功能。</p><p>字符流的缓冲流用法类似，可以使用 <code>BufferedReader</code> 和 <code>BufferedWriter</code> 来提高字符流的性能。</p><h1 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h1><h2 id="说说-List-Set-Queue-Map-的几个区别"><a href="#说说-List-Set-Queue-Map-的几个区别" class="headerlink" title="说说 List Set Queue Map 的几个区别"></a>说说 List Set Queue Map 的几个区别</h2><p>List 有序可重复</p><p>Set 不可重复，具体有序无序要看实现</p><p>Queue FIFO的实现，有序可重复</p><p>Map 键值对存储映射</p><ul><li>key是无序<strong>不可重复</strong>的</li><li>value是无序可重复的</li><li>一个key最多对应一个value</li></ul><h2 id="常见的-List-Set-Queue-Map"><a href="#常见的-List-Set-Queue-Map" class="headerlink" title="常见的 List Set Queue Map"></a>常见的 List Set Queue Map</h2><p>List：</p><ul><li>ArrayList 线程不安全</li><li>Vector 线程安全，古早</li><li>LinkedList 双向链表，1.6之前还是循环的，但是在1.7之后取消了循环</li></ul><p>Set：</p><p><font color='red'>都是线程不安全的</font></p><ul><li>HashSet <font color='red'>无序</font>（底层是HashMap）</li><li>LinkedHashSet（底层是LinkedHashMap）</li><li>TreeSet（有序）</li></ul><p>Queue：</p><ul><li>PriorityQueue：优先级队列</li><li>DelayQueue</li><li>ArrayQueue 可扩容的动态双向数组</li></ul><p>Map：</p><ul><li>HashMap <strong>在1.8之前是数组+链表</strong>，数组是主体，链表则是为了解决哈希冲突，拉链法实现的；在1.8以后当一个点上的链表长度大于8的时候就会转化为红黑树（前提也要是数组长度大于64的时候才会转化，小于64则会先进行数组扩容）</li><li>LinkedHashMap 继承自 HashMap 同时增加了一条双向链表，使得<strong>可以按插入顺序访问各个 bucket 的节点</strong></li><li>HashTable 线程安全，不允许 null 的 key 和 value</li><li>TreeMap 红黑树（自平衡的二叉排序树）</li></ul><h2 id="线程不安全的解决"><a href="#线程不安全的解决" class="headerlink" title="线程不安全的解决"></a>线程不安全的解决</h2><p>我们都知道ArrayList是线程不安全的，多个线程对同一个List进行写或者是删除的操作可能会导致数据冲突</p><p>为了确保线程安全，可以使用 <code>Collections.synchronizedList</code> 或者 <code>CopyOnWriteArrayList</code> 等线程安全的替代品，或者在访问 <code>ArrayList</code> 时手动进行同步</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>它通过<strong>在写操作时创建原始数据的拷贝来实现线程安全性</strong>，这使得读操作可以在不受写操作干扰的情况下进行。适用于<strong>读多写少</strong>的场景，对于迭代操作也是安全的。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>加入操作默认是最后一位加入，操作是O(1)，删除中间指定位置的就是O(n)因为要移动</p><p><strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><h1 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h1><h2 id="Java中创建线程的方法"><a href="#Java中创建线程的方法" class="headerlink" title="Java中创建线程的方法"></a>Java中创建线程的方法</h2><p>主要是两个</p><p>继承Thread类重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot; Value &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br><br>        <span class="hljs-comment">// 启动线程</span><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实现 Runnable 接口，把这个类的实例传递作为 Thread 构造函数的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot; Value &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br><br>        <span class="hljs-comment">// 启动线程</span><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h2><p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。</p><p>但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h2 id="Volatile-关键字"><a href="#Volatile-关键字" class="headerlink" title="Volatile 关键字"></a>Volatile 关键字</h2><p>保证多线程环境下变量的可见性，但是不保证针对变量的操作是原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatoleAtomicityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">inc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123;<br>        inc++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">VolatoleAtomicityDemo</span> <span class="hljs-variable">volatoleAtomicityDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatoleAtomicityDemo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500</span>; j++) &#123;<br>                    volatoleAtomicityDemo.increase();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 等待1.5秒，保证上面程序执行完成</span><br>        Thread.sleep(<span class="hljs-number">1500</span>);<br>        System.out.println(inc);<br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能</p><h3 id="公平锁和非公平锁的区别"><a href="#公平锁和非公平锁的区别" class="headerlink" title="公平锁和非公平锁的区别"></a>公平锁和非公平锁的区别</h3><p><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p><p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p><p>synchronized 默认是非公平，ReentrantLock 可以自定义公平和非公平</p><h3 id="可重入锁指的是什么"><a href="#可重入锁指的是什么" class="headerlink" title="可重入锁指的是什么"></a>可重入锁指的是什么</h3><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p><p>在下面的代码中，<code>method1()</code> 和 <code>method2()</code>都被 <code>synchronized</code> 关键字修饰，<code>method1()</code>调用了<code>method2()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法1&quot;</span>);<br>        method2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>synchronized</code>锁是可重入的，同一个线程在调用<code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如<code>synchronized</code>是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 <code>method2()</code>时获取锁失败，会出现死锁问题。</p><h3 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h3><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁</li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231229115631317.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231229115725856.png"></p><h2 id="什么时候用-TCP-什么时候用-UDP"><a href="#什么时候用-TCP-什么时候用-UDP" class="headerlink" title="什么时候用 TCP 什么时候用 UDP"></a>什么时候用 TCP 什么时候用 UDP</h2><p><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</p><p><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等</p><h2 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h2><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手?"></a>为什么要三次握手?</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><ol><li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ol><p>三次握手就能确认双方收发功能都正常，缺一不可</p><h2 id="奇偶校验机制"><a href="#奇偶校验机制" class="headerlink" title="奇偶校验机制"></a>奇偶校验机制</h2><p>奇偶校验机制是在数据链路层中一种常见的用于检测bit数据在传输过程中是否发生位错误的一种技术</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）</p><p><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)</p><p>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>缓存、分布式锁</p><p>具体数据类型以及对应的应用场景如下：</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>可以缓存网页内容，存储简单的数据对象例如验证码等kv键值对，就是最简单的 kv 存储</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">SET page:/home <span class="hljs-string">&quot;&lt;html&gt;...&lt;/html&gt;&quot;</span> <span class="hljs-comment">#被频繁访问的网页内容本体可以缓存在 Redis 中</span><br>GET page:/home<br></code></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>有序的字符串<strong>列表</strong>(说是列表其实是一个队列)</p><p>可以用 list 数据结构实现最简单的一个消息队列模型</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">LPUSH queue:tasks <span class="hljs-string">&quot;task1&quot;</span><br>LPUSH queue:tasks <span class="hljs-string">&quot;task2&quot;</span><br>RPOP queue:tasks<br></code></pre></td></tr></table></figure><p>可以使用 Redis 列表实现简单的消息队列，LPUSH 用于添加任务，RPOP 用于消费任务</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 集合数据结构可以实现简单的用户标签系统</p><p>同时还可以进行交集并集运算</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">SADD user:1:tags <span class="hljs-string">&quot;redis&quot;</span><br>SADD user:1:tags <span class="hljs-string">&quot;database&quot;</span><br>SADD user:2:tags <span class="hljs-string">&quot;cache&quot;</span><br>SINTER user:1:tags user:2:tags <span class="hljs-comment">#查询两个用户的兴趣交集</span><br></code></pre></td></tr></table></figure><p>在社交网络应用中，可以使用 Set 集合存储用户的标签，并进行交集计算，找出共同的兴趣点</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>哈希是键值对集合，我们可以实现对象的存储</p><p>相较于 String 只能存储简单的字符串，Hash可以存储多个字段以及他们的值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">HSET user:1000 name <span class="hljs-string">&quot;John Doe&quot;</span><br>HSET user:1000 email <span class="hljs-string">&quot;john.doe@example.com&quot;</span><br>HGETALL user:1000<br></code></pre></td></tr></table></figure><p>Hash 数据结构可以对单个字段进行操作。例如，只修改或获取哈希中的一个字段</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">HSET user:1000 name <span class="hljs-string">&quot;Jane Doe&quot;</span><br>HGET user:1000 name <span class="hljs-comment">#只获取 user:1000 key(集合)的name这一个字段</span><br></code></pre></td></tr></table></figure><h3 id="ZSet-x2F-Sorted-Set"><a href="#ZSet-x2F-Sorted-Set" class="headerlink" title="ZSet&#x2F;Sorted Set"></a>ZSet&#x2F;Sorted Set</h3><p>相较于集合而言多了一个权重，可以进行排序</p><p>例如在标签的基础上增加一个 weight 权重的设计，或者是设计一个排行榜</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ZADD leaderboard 1000 <span class="hljs-string">&quot;user1&quot;</span><br>ZADD leaderboard 2000 <span class="hljs-string">&quot;user2&quot;</span><br>ZREVRANGE leaderboard 0 1 WITHSCORES<br></code></pre></td></tr></table></figure><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>可以用来实现某一天的签到业务，或者是统计海量用户在某一天的活跃度</p><p>一个网站可以使用 Bitmap 来记录用户在某一天是否活跃。假设网站有 1 亿用户，可以使用一个大小为 1 亿位的 Bitmap，其中每一位代表一个用户的活跃状态（0 表示不活跃，1 表示活跃）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">SETBIT active_users:2024-05-14 12345 1  # 用户 ID 为 12345 的用户在 2024-05-14 活跃<br>GETBIT active_users:2024-05-14 12345  # 检查用户 ID 为 12345 的用户在 2024-05-14 是否活跃<br></code></pre></td></tr></table></figure><p>采用这个数据结构可以节省大量存储空间，比使用布尔数组更高效</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 是一种基于概率的数据结构，用于估算大规模数据集合的基数（即不同元素的数量）</p><p>例如可以实现独立（不同）访客统计，商品去重的访问量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">PFADD unique_visitors:2024-05-14 user12345  <span class="hljs-comment"># 记录用户 ID 为 user12345 的用户在 2024-05-14 访问</span><br>PFADD unique_visitors:2024-05-14 user67890  <span class="hljs-comment"># 记录用户 ID 为 user67890 的用户在 2024-05-14 访问</span><br>PFCOUNT unique_visitors:2024-05-14  <span class="hljs-comment"># 估算 2024-05-14 的独立访客数量</span><br><br>PFADD product:page:123 user12345  <span class="hljs-comment"># 记录用户 ID 为 user12345 访问了商品页面 123</span><br>PFADD product:page:123 user67890  <span class="hljs-comment"># 记录用户 ID 为 user67890 访问了商品页面 123</span><br>PFCOUNT product:page:123  <span class="hljs-comment"># 估算商品页面 123 的独立访问用户数量</span><br></code></pre></td></tr></table></figure><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p>可以借助 Geospatial 来存储和操作<strong>地理空间数据</strong>，可以进行半径查询、距离计算等操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">GEOADD stores 13.361389 38.115556 <span class="hljs-string">&quot;Palermo&quot;</span><br>GEOADD stores 15.087269 37.502669 <span class="hljs-string">&quot;Catania&quot;</span><br>GEORADIUS stores 15 37 100 km <br></code></pre></td></tr></table></figure><p>上面是查询了以 15 37 这一经纬度坐标点为中心，100km为半径的所有商店</p><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p><p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p><h2 id="缓存穿透-缓存击穿-缓存雪崩"><a href="#缓存穿透-缓存击穿-缓存雪崩" class="headerlink" title="缓存穿透 缓存击穿 缓存雪崩"></a>缓存穿透 缓存击穿 缓存雪崩</h2><p>缓存穿透：说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p>缓存击穿： 大量请求的 key 不在缓存中但是在数据库里（一般都是缓存的时间到了就过期）</p><p>缓存雪崩：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong></p><h2 id="Redis常见的删除策略"><a href="#Redis常见的删除策略" class="headerlink" title="Redis常见的删除策略"></a>Redis常见的删除策略</h2><p>定时删除，TTL 结束就触发删除，对 CPU 不友好</p><p>惰性删除：使用的时候发现过期了才删除，但是会浪费内存空间</p><p>定期删除：每隔一段时间「随机」取出一定数量的 key 进行检查和删除</p><h2 id="描述用-Redis-实现验证码的存储和过期时间"><a href="#描述用-Redis-实现验证码的存储和过期时间" class="headerlink" title="描述用 Redis 实现验证码的存储和过期时间"></a>描述用 Redis 实现验证码的存储和过期时间</h2><p>用户请求验证码的时候进行验证码的生成，之后存储到 Redis 中，通过一个 Set 方法就可以同时实现过期时间的设置</p><p>之后用户携带验证码的时候从 Redis 中获取验证码，如果验证码正确且未过期，则验证成功；否则验证失败。</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>LIMIT 子句来实现</p><p>分页通常需要两个参数：偏移量（offset）和行数（limit）。</p><p>基本的分页查询语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> your_table<br>LIMIT <span class="hljs-keyword">offset</span>, limit;<br></code></pre></td></tr></table></figure><p>其中，<code>offset</code>表示开始的行数，<code>limit</code>表示要选择的行数。</p><p>例如，如果你想获取从第 11 行开始的 10 条记录，查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> your_table<br>LIMIT <span class="hljs-number">10</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这将返回从第 11 行到第 20 行的记录。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在 MySQL 中，索引是一种用于提高数据库查询性能的重要机制。索引是一种数据结构，类似于书籍目录，它提供了一种快速查找数据的方式，而不必扫描整个数据表。例如我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。下面是关于 MySQL 索引的一些基本概念</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li><p><strong>索引的作用：</strong></p><ul><li><strong>提高检索速度：</strong> 索引可以加快数据检索的速度，特别是在大型数据表中。</li><li><strong>加速排序：</strong> 对于排序和分组操作，索引也可以提高性能。</li><li><strong>唯一性约束：</strong> 索引可以强制表中的<strong>每一行数据</strong>的唯一性。</li></ul></li><li><p>索引的缺点</p><ul><li>创建和维护索引需要一定的性能开销</li><li>如果是批量插入上万行的数据，则需要针对这些插入语句关闭索引，否则会很慢很慢</li></ul></li></ol><h3 id="常见类型的索引：按照底层数据结构划分"><a href="#常见类型的索引：按照底层数据结构划分" class="headerlink" title="常见类型的索引：按照底层数据结构划分"></a>常见类型的索引：按照底层数据结构划分</h3><ul><li>B树</li><li>B+树</li><li>Hash表</li><li>红黑树</li></ul><p>无论是 InnoDB 还是 MyISam，采用的底层数据结构都是 B+ 树</p><h4 id="Hash表数据结构"><a href="#Hash表数据结构" class="headerlink" title="Hash表数据结构"></a>Hash表数据结构</h4><p>其实就是哈希函数映射+拉链法</p><p>和JDK1.8以前的实现方式差不多</p><p>哈希表虽然快，但是不支持顺序和范围查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tb1 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure><p>像是这样的 SQL 就无法通过哈希表来实现</p><p>（TODO）</p><h3 id="常见类型的索引：按照应用维度划分"><a href="#常见类型的索引：按照应用维度划分" class="headerlink" title="常见类型的索引：按照应用维度划分"></a>常见类型的索引：按照应用维度划分</h3><ul><li><strong>主键索引（Primary Key Index）：</strong> 数据表的主键列使用的就是主键索引，是一种唯一性索引，用于唯一标识表中的每一行记录。一个表只能有一个主键索引。</li><li><strong>唯一索引（Unique Index）：</strong> 唯一索引确保索引列中的所有值都是唯一的，但允许空值。</li><li><strong>普通索引（Normal Index）：</strong> 普通索引是最基本的索引类型，没有唯一性限制。</li><li><strong>全文索引（Full-Text Index）：</strong> 用于全文搜索，适用于对文本数据进行搜索的场景。</li><li>唯一索引、普通索引、全文索引，都属于二级索引，他们的叶子节点存储的数据是主键的值</li></ul><p>InnoDB存储引擎使用的是B树索引结构。B树（或B+树）是一种平衡树结构，它在插入、删除和查找操作上具有较好的性能表现，适用于范围查询和排序操作。InnoDB的主键索引和普通索引都是基于B树的。</p><h2 id="事务带来的问题"><a href="#事务带来的问题" class="headerlink" title="事务带来的问题"></a>事务带来的问题</h2><p>脏读 幻读 不可重复读</p><h2 id="SQL定义的四个隔离级别"><a href="#SQL定义的四个隔离级别" class="headerlink" title="SQL定义的四个隔离级别"></a>SQL定义的四个隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@tx</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@tx</span>_isolation  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br></code></pre></td></tr></table></figure><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>除了 InnoDB 和 MyISAM 外还有什么</p><p><strong>MEMORY</strong></p><p><strong>CSV</strong>文件</p><h2 id="一百万条数据插入MySQL，有什么好的处理方法么"><a href="#一百万条数据插入MySQL，有什么好的处理方法么" class="headerlink" title="一百万条数据插入MySQL，有什么好的处理方法么"></a>一百万条数据插入MySQL，有什么好的处理方法么</h2><p>禁用索引</p><p>用 preparedStatement 预编译SQL语句批处理插入</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>JDBC（Java Database Connectivity）是<strong>Java程序与关系型数据库进行交互的一种标准接口</strong>。它提供了一组用于访问和操作数据库的Java API，允许Java应用程序与各种关系型数据库进行通信，如 MySQL、Oracle、SQL Server 等。</p><p>JDBC的主要组成部分包括：</p><ol><li><strong>DriverManager：</strong> 用于管理一组数据库驱动程序，负责建立与数据库的连接。</li><li><strong>Driver：</strong> JDBC驱动程序是一个实现JDBC接口的类，它充当Java应用程序与数据库之间的桥梁。不同的数据库需要使用相应的JDBC驱动。</li><li><strong>Connection：</strong> 表示与数据库的连接。通过<code>DriverManager.getConnection</code>方法获取数据库连接。</li><li><strong>Statement：</strong> 用于执行SQL语句。<code>Statement</code> 接口有三个主要的实现类：<code>Statement</code>、<code>PreparedStatement</code> 和 <code>CallableStatement</code>。</li><li><strong>ResultSet：</strong> 表示数据库结果集，是通过执行查询获取的数据集合。</li></ol><h2 id="JDBC中的事务是如何管理的？"><a href="#JDBC中的事务是如何管理的？" class="headerlink" title="JDBC中的事务是如何管理的？"></a><strong>JDBC中的事务是如何管理的？</strong></h2><p>在JDBC中，事务管理主要通过<code>Connection</code>接口的<code>commit()</code>和<code>rollback()</code>方法来实现</p><p>当所有SQL语句执行完成后，通过<code>commit()</code>提交事务；如果出现错误或需要回滚，则调用<code>rollback()</code>方法</p><p>默认情况下，每个SQL语句都是一个事务，如果需要手动管理事务，可以使用<code>setAutoCommit(false)</code>关闭自动提交。</p><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="动态SQL如何实现"><a href="#动态SQL如何实现" class="headerlink" title="动态SQL如何实现"></a>动态SQL如何实现</h2><p>MyBatis中的动态SQL允许你在映射文件中编写灵活的SQL语句，根据不同的条件生成不同的SQL片段，以满足动态查询的需求。动态SQL通常使用<code>&lt;if&gt;</code>, <code>&lt;choose&gt;</code>, <code>&lt;when&gt;</code>, <code>&lt;otherwise&gt;</code>, <code>&lt;trim&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;foreach&gt;</code>等标签来实现</p><h2 id="分页如何实现"><a href="#分页如何实现" class="headerlink" title="分页如何实现"></a>分页如何实现</h2><p>MyBatis 提供了 <code>RowBounds</code> 类，通过将 <code>RowBounds</code> 作为方法的参数来实现分页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">(RowBounds rowBounds)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    SELECT * FROM users<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">RowBounds</span> <span class="hljs-variable">rowBounds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RowBounds</span>(offset, limit);<br>List&lt;User&gt; userList = userDao.getUserList(rowBounds);<br></code></pre></td></tr></table></figure><h2 id="和-的区别是？"><a href="#和-的区别是？" class="headerlink" title="#{}和${}的区别是？"></a>#{}和${}的区别是？</h2><p>${}是properties文件的变量占位符，可以用在配置文件或者是 SQL 语句中</p><p>例如：根据参数按任意字段排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $&#123;orderControls&#125;<br></code></pre></td></tr></table></figure><p><code>orderControls</code>可以是 <code>name</code>、<code>name desc</code>、<code>name,sex asc</code>等，实现灵活的排序</p><p>而 #{} 是SQL的参数占位符，Mybatis会将其设置为 ？ 并且在执行的过程中由 preparedStatement 来设置参数值</p><h1 id="Tomcat-amp-Servlet"><a href="#Tomcat-amp-Servlet" class="headerlink" title="Tomcat &amp; Servlet"></a>Tomcat &amp; Servlet</h1><h2 id="什么是Tomcat？它与Web服务器的区别是什么？"><a href="#什么是Tomcat？它与Web服务器的区别是什么？" class="headerlink" title="什么是Tomcat？它与Web服务器的区别是什么？"></a><strong>什么是Tomcat？它与Web服务器的区别是什么？</strong></h2><p>Tomcat是一个开源的、轻量级的、<strong>用于运行Java Servlet和JSP的Web应用服务器</strong></p><p>它与传统的Web服务器（如Apache HTTP Server）的区别在于Tomcat<strong>更专注于Java Servlet和JSP技术的支持</strong>，而不仅仅是提供静态文件服务。</p><h2 id="Tomcat-运行流程"><a href="#Tomcat-运行流程" class="headerlink" title="Tomcat 运行流程"></a>Tomcat 运行流程</h2><p>Tomcat的运行流程可以简单概括为以下几个步骤：</p><ol><li><strong>启动阶段：</strong><ul><li>当Tomcat启动时，会加载并初始化服务器组件。在这个阶段，Tomcat会读取配置文件（主要是 <code>server.xml</code> 文件）来配置连接器、虚拟主机、Web应用等信息。</li></ul></li><li><strong>监听端口：</strong><ul><li>连接器（Connector）负责监听指定的端口，等待客户端的请求。常见的连接器有HTTP&#x2F;1.1连接器、AJP连接器等。</li></ul></li><li><strong>接收请求：</strong><ul><li>当有请求到达时，连接器将请求交给 Catalina 容器进行处理。Catalina是Tomcat的Servlet容器，负责处理Servlet和JSP。</li></ul></li><li><strong>处理请求：</strong><ul><li>Catalina根据请求的URL和虚拟主机等信息，将请求交给对应的Host（主机）。Host根据Context的配置将请求分发给对应的Web应用。</li></ul></li><li><strong>Web应用处理：</strong><ul><li>Web应用处理阶段涉及多个组件，包括ClassLoader、Context、Wrapper等。ClassLoader加载Web应用的类，Context提供Web应用的运行环境，Wrapper负责实际的Servlet执行。</li></ul></li><li><strong>Servlet执行：</strong><ul><li>当请求到达目标Servlet时，Wrapper将请求转发给Servlet进行处理。Servlet执行相应的逻辑，生成响应内容。</li></ul></li><li><strong>生成响应：</strong><ul><li>Servlet生成响应后，将响应返回给Catalina容器，然后由Catalina返回给连接器。</li></ul></li><li><strong>连接器响应：</strong><ul><li>连接器将响应发送给客户端，完成请求-响应周期。</li></ul></li><li><strong>关闭阶段：</strong><ul><li>当Tomcat关闭时，会执行关闭阶段。在这个阶段，Tomcat会释放资源、关闭连接器等。</li></ul></li></ol><h2 id="简单介绍-Servlet"><a href="#简单介绍-Servlet" class="headerlink" title="简单介绍 Servlet"></a>简单介绍 Servlet</h2><p>Servlet（Serverlet）是Java编写的服务器端程序，主要用于扩展服务器功能。Servlet在Web开发中广泛使用，它是Java EE（Enterprise Edition）平台的一部分，用于处理Web请求和响应</p><h1 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h1><h2 id="基本组件和概念"><a href="#基本组件和概念" class="headerlink" title="基本组件和概念"></a>基本组件和概念</h2><h2 id="你在项目中用到了哪些功能"><a href="#你在项目中用到了哪些功能" class="headerlink" title="你在项目中用到了哪些功能"></a>你在项目中用到了哪些功能</h2><h2 id="pod网络"><a href="#pod网络" class="headerlink" title="pod网络"></a>pod网络</h2><h1 id="笔试刷题错题"><a href="#笔试刷题错题" class="headerlink" title="笔试刷题错题"></a>笔试刷题错题</h1><h2 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h2><p>左半部分不应该指定大小，下面这种都不是 Java 的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[<span class="hljs-number">5</span>] a= &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>Integer[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] a = &#123;&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">2</span>)&#125;,&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interger</span>(<span class="hljs-number">4</span>)&#125;&#125;;<br></code></pre></td></tr></table></figure><p>此外，创建二维数组的时候不能先创建第二层，至少也得先声明第一层的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Float[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>[][<span class="hljs-number">5</span>]; <span class="hljs-comment">//这种就不对</span><br>Fload[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>[<span class="hljs-number">5</span>][]; <span class="hljs-comment">//这种可以</span><br></code></pre></td></tr></table></figure><h2 id="声明作用域"><a href="#声明作用域" class="headerlink" title="声明作用域"></a>声明作用域</h2><p>private:  仅限类的内部 </p><p>pakage: 包内类可以访问</p><p>default: 同一个包可见</p><p>protect: 包内类可以访问，另外包外子类也可以访问</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类可以实现接口，且<strong>不必实现接口中的抽象方法</strong></p><p>抽象类可以没有抽象方法，也可以有抽象方法+具体方法</p><p>抽象类和接口<strong>不能实例化</strong></p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="包装数据类型变量-a"><a href="#包装数据类型变量-a" class="headerlink" title="包装数据类型变量 ++a"></a>包装数据类型变量 ++a</h3><p>核心考点：</p><ul><li>数据机器级表示</li><li>包装类自动装箱拆箱</li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240101165746438.png"></p><p>核心解法：</p><ul><li>++a先是触发拆箱操作Byte.byteValue，得到基本类型的值127，然后执行+1操作，使得值变为-128，最后触发装箱操作Byte.valueOf将value&#x3D;-128的Byte对象赋值给a</li><li>至于为什么是 -128 这是CSAPP和计算机组成原理的知识</li><li>add方法里那一段其实没有任何作用，实际上这个<strong>和自增也没啥关系</strong>，就算是你改成 <code>b = ++b</code> 由于<strong>包装类作为参数的时候传递的是值而不是引用</strong>，因此无论是 <code>++b</code> 还是 <code>b++</code> 都不会修改到 test() 声明的 b 的值</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个新创建的线程<strong>并不是自动的开始运行的</strong>，必须调用它的start()方法使之将线程放入可<strong>运行态(runnable state)</strong>     </p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>ArrayList 初始化之后第一次扩容的逻辑：通过新建一个数组，再通过 <code>System.arrayCopy</code> 的方式将旧数据移植新数组中</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="事务相关的指令"><a href="#事务相关的指令" class="headerlink" title="事务相关的指令"></a>事务相关的指令</h3><p>Commit 用于事物的显示提交 </p><p><strong>savepoint</strong> 用于在 sql 语句中设置事物保存点，用法为 <code>savepoint 保存点名称</code> ，在 rollback 时使用 </p><p>rollback [work] to [savepoint] 回滚到某个保存点</p><p>需要注意的是我们都知道 commit 和 rollback 但是 savepoint 不是很熟</p><hr><p>正常执行完DDL语句。包括 create，alter，drop，truncate，rename</p><p>正常执行完DCL语句。包括 grant，revoke</p><p>正常退出数据库管理软件，没有明确发出 commit 或者 rollback</p><p>除了基本的查询语句与增删改的对表的操纵语句外基本都是隐式提交的，使用时要注意。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>在定义视图的 SELECT 语句后的字段列表中使用 DISTINCT 、聚合函数 、 GROUP BY 、 HAVING 、UNION 等，视图将不支持INSERT、UPDATE、DELETE</p><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>UNION ALL不去重，UNION<strong>去重</strong></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p> 别名不可以用’’引起来<br> 别名可以用””引起来<br> 别名前面用不用as都可以</p><h3 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h3><p>索引是记录文件位置的特殊文件结构,他是保存在磁盘上的,所以<strong>不能直接被sql引用</strong></p><h3 id="纯概念"><a href="#纯概念" class="headerlink" title="纯概念"></a>纯概念</h3><p>数据库的独立性分为逻辑独立性和物理存储独立性。 </p><p>逻辑独立性是指应用程序独立与数据库的逻辑结构，当模式发生改变时，外模式不变从而使应用程序不变。 </p><p>物理独立性是指应用程序独立于数据的物理存储结构，当内模式发生改变时，模式不会发生改变，从而外模式也不会发生改变，从而使得应用程序不发生改变。 </p><p>模式&#x2F;外模式映射保证数据库的逻辑独立性 </p><p>内模式&#x2F;模式映射保证数据库的物理独立性。</p><h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231231161239265.png"></p><p>1NF：指每一列是原子不可分割 </p><p>2NF：消除非主属性对主属性的部分依赖，也就是说每列都依赖主键，而不能与主键的部分相关，也就是<strong>不存在依赖与联合主键的情况</strong></p><p>3NF：关系中既不存在部分依赖，也不存在传递依赖的关系</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="空间计算"><a href="#空间计算" class="headerlink" title="空间计算"></a>空间计算</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231231161120569.png"></p><p> 7000H &#x3D; 0111 0000 0000 0000 </p><p> 8K&#x3D;2^13 &#x3D; 0010 0000 0000 0000 </p><p> 初始地址为7000H，则其8K长度的地址的终点为 </p><p> 7000H + 8K - 1&#x3D;&amp;nbsp;0111 0000 0000 0000 +&amp;nbsp;0010 0000 0000 0000 - 1 </p><p> &#x3D;0111 0000 0000 0000&amp;nbsp; </p><p> +0001 1111 1111&amp;nbsp;1111<br> &#x3D;1000 1111 1111 1111&#x3D;8FFFF(十六进制)</p><h2 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP重传"><a href="#TCP重传" class="headerlink" title="TCP重传"></a>TCP重传</h3><p>TCP使用<strong>超时事件</strong>和<strong>冗余ACK</strong>来检测数据包的丢失。</p><ul><li>当超时事件发生时，TCP会执行重传</li><li>此外，TCP还使用冗余ACK（冗余确认）来快速检测数据包的丢失，并在收到冗余ACK时触发快速重传</li></ul><p>在TCP中，超时时间是<strong>动态调整</strong>的，根据网络的延迟和拥塞情况进行调整，而不是固定的</p><p>TCP接收方通常<strong>需要对乱序到达的分组进行确认</strong>。TCP协议使用累积确认机制，<strong>接收方会发送一个确认号</strong>，<strong>表示已成功接收到这个序号之前的所有数据</strong>。如果接收方收到乱序的分组，它仍然会确认已经接收到的最后一个按序到达的分组，以指示发送方不需要重传已经成功接收的数据，但仍然需要重传丢失的数据。</p><h2 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h2><h3 id="垃圾回收策略"><a href="#垃圾回收策略" class="headerlink" title="垃圾回收策略"></a>垃圾回收策略</h3><p>新生代收集器： Serial、 ParNeW、Parallel Scavenge</p><p>老年代收集器： Serial Old、 Parallel Old、 CMS</p><p>整堆收集器： G1 （统管新生代和老年代）</p><h3 id="释放指定内存空间"><a href="#释放指定内存空间" class="headerlink" title="释放指定内存空间"></a>释放指定内存空间</h3><p>在Java中，释放掉一个指定占据的内存空间的方法是：</p><p>A：调用system.gc()方法 </p><p>B：调用free()方法 </p><p>C：赋值给该对象的引用为null </p><p>D：程序员无法明确强制垃圾回收器运行</p><p>在Java中，释放内存的具体操作是由垃圾回收器（Garbage Collector）负责的，而<strong>不是由程序员手动释放</strong>。因此，程序员不能直接明确强制垃圾回收器运行</p><p>A：<code>System.gc()</code>方法调用<strong>是建议垃圾回收器运行</strong>，但并不能保证立即执行。</p><p>B：<code>free()</code>方法在Java中通常不是程序员用来释放内存的方法，而是在C语言中使用。</p><p>C：赋值给该对象的引用为null并不能直接释放内存。<strong>垃圾回收器会在适当的时候发现这个对象没有被引用，然后将其回收</strong>。</p><p>D：程序员无法明确强制垃圾回收器运行，这是Java设计的一部分，以避免程序员过多地涉及内存管理。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="可以判断有向图是否带环的算法"><a href="#可以判断有向图是否带环的算法" class="headerlink" title="可以判断有向图是否带环的算法"></a>可以判断有向图是否带环的算法</h3><ul><li>DFS</li><li>拓扑排序</li></ul><h1 id="OLK"><a href="#OLK" class="headerlink" title="OLK"></a>OLK</h1><h2 id="SPI-机制"><a href="#SPI-机制" class="headerlink" title="SPI 机制"></a>SPI 机制</h2><h3 id="SPI和API"><a href="#SPI和API" class="headerlink" title="SPI和API"></a>SPI和API</h3><p>简单来说，API是接口和实现都放在实现方，实现对调用者透明，是<strong>实现方定义了接口的规则</strong>，<strong>调用者调用实现方提供的接口</strong></p><p>而SPI是接口由<strong>调用方来定义规则</strong>，实现方基于调用方接口的定义，来实现调用方定义的接口</p><h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><h3 id="外部函数注册-amp-下推"><a href="#外部函数注册-amp-下推" class="headerlink" title="外部函数注册&amp;下推"></a>外部函数注册&amp;下推</h3><p>继承抽象类</p><p>注绑定字符串，数字运算，日期相关的函数</p><h3 id="MariaClientModule绑定配置"><a href="#MariaClientModule绑定配置" class="headerlink" title="MariaClientModule绑定配置"></a>MariaClientModule绑定配置</h3><p>注册绑定 Client Module 的时候针对配置文件中的 URL 处理，MySQL 和 MariaDB 实现不一样</p><p>MariaDB 由驱动提供的 UrlParser类来实现</p><p>此外获取数据库的时候一些判断也根据不同的 Driver 进行上层的实现</p><h3 id="编写流程"><a href="#编写流程" class="headerlink" title="编写流程"></a>编写流程</h3><p>注册 Module，配置一些连接器元数据信息，包括 catalog schema 名称等</p><p>绑定 Client 对象，外部函数以及配置文件的信息（实体化为Config类）</p><p>MariaClient 代表一个 JDBC 客户端对象，基于JDBC来操作数据源，是在BaseJdbcClient基础上针对MairaDB的一套适配，一些异常ErrorCode进行了适配</p><h2 id="最难的问题"><a href="#最难的问题" class="headerlink" title="最难的问题"></a>最难的问题</h2><p>在集成测试的时候，社区要求的引入的 airlift 包里通过代码创建了 mysqld 进程，但是默认是root身份启动，不允许，因此学习修改源码修改启动的 mysqld 的相关配置，允许 root 启动</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PS2|.hack// Vol.1 感染扩大</title>
    <link href="/2024/01/01/PS2-hack-Vol-1-%E6%84%9F%E6%9F%93%E6%89%A9%E5%A4%A7/"/>
    <url>/2024/01/01/PS2-hack-Vol-1-%E6%84%9F%E6%9F%93%E6%89%A9%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<p>「使用者登錄總算是結束了……再來確認名字就可以了。靖彥（ヤスヒコ）已經在等了吧，快點結束吧。」</p><p>│The World的使用者登錄結束，最後請會員確認您的名字和ＰＣ名。│</p><p>您的名字　　：沙下夜雪一輩子都是沙下夜雪～<br>您的ＰＣ名字：凱特（カイト）</p><p>│請確認您的名字？│</p><p>是。</p><p>│使用者登錄確認完成。│<br>│選擇在桌面明細中的The World開始遊戲。│<br>│那麼請您享受The World世界中的樂趣。　│</p><h1 id="遊戲系統介面"><a href="#遊戲系統介面" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>讀取信件。</p><p>送信者：靖彥<br>    　　　件名：登錄結束了嗎？</p><p>嗨～登錄結束了嗎？<br>    　　真期待你是什麼樣的ＰＣ呢。</p><p>啊，對了對了。雖然我在學校說過了，但你若取了奇怪的名字往後一定會後悔的喔。</p><p>在The World裡，我就是歐卡（オルカ），往後就請多指教了。<br>    　　不過別叫本名喔～<br>    　　在那個世界裡，就是在扮演著不同的自己。<br>    　　不，也許在扮演的是自己……(^^;)<br>    　　總之我在路由城鎮（ルートタウン）等著。</p><p>-<br>  　　送信者：ＣＣ社<br>    　　　件名：登錄結束的通知</p><p>謝謝您登錄The World。<br>    　　ＣＣ社通知您登錄完成。</p><p>The World（本遊戲）是由複數的伺服所構成的。<br>    　　各伺服裡有著路由城鎮存在，<br>    　　而路由城鎮裡有一個叫做混沌之門（カオスゲート）的房間裡，<br>    　　在那裡任意輸入資料編碼就可以開始冒險了。</p><p>接下來介紹各伺服的路由城鎮。</p><p>Δ（デルタ）伺服<br>    　　路由城鎮<br>    　　水の都　マク．アヌ<br>    　　城市的名字有著女神之子的意思。<br>    　　街道中圍繞著水路，那樣的風景及潺潺的水流聲能夠讓冒險者感到安心。</p><p>-<br>  　　Θ（シータ）伺服<br>    　　路由城鎮<br>    　　高山都市　ドゥナ．ロリヤック<br>    　　城市的名字有著紡織的守護者的意思。<br>    　　是一個有許多利用岩山建造的房子，並且受到精靈加護，與自然共存的街道。<br>    　　那吹襲的狂風讓冒險者的心情高漲。</p><p>-<br>  　　Λ（ラムダ）伺服<br>    　　路由城鎮<br>    　　文明都市　カルミナ．ガデリカ<br>    　　城市的名字有著歡喜之歌的意思。<br>    　　這裡是一個融合著科學知識和紋樣文明知識的大都市。</p><p>-<br>  　　Σ（シグマ）伺服<br>    　　路由城鎮<br>    　　空中都市　フォート．アウフ<br>    　　城市的名字有著精靈城砦的意思。<br>    　　原本是作為カルミナ．ガデリカ戰爭的要塞，<br>    　　但在和平之後便成為自空中監視怪物的分布及動向的機能都市。</p><p>-<br>  　　Ω（オメガ）伺服<br>    　　路由城鎮<br>    　　遺跡都市　リア．ファイル<br>    　　城市的名字有著命運之石的意思。<br>    　　這個城市在巨大的破壞之前，是タルタルガ族的聖地。<br>    　　但也因為如此，所以被カルミナ．ガデリカ軍攻擊而壞滅。</p><p>-<br>  　　這些可以在路由城鎮中的混沌之門裡選擇。<br>    　　而ＰＣ的等級不高的情況下，建議選擇Δ城鎮冒險。</p><h1 id="水の都-マヌ．アク"><a href="#水の都-マヌ．アク" class="headerlink" title="水の都　マヌ．アク"></a>水の都　マヌ．アク</h1><p>凱特在看完了信件後，便登入到The World裡。而在混沌之門前已經有人在等著他了。<br>    　　對方是一個裸著上半身的粗獷ＰＣ，手持著劍一副來勢洶洶的樣子。<br>    　　他的名字叫做歐卡，也就是凱特在信件中所看到的名字，看來就是靖彥了。</p><p>「唷，你來啦。」歐卡向凱特打了招呼。<br>    　　「呃……」凱特似乎不知道對方是誰而猶豫著。<br>    　　「是我啦，劍士的歐卡。」<br>    　　「啊～？」凱特驚呼一聲。「感覺完全不同呢……你是靖彥啊。」<br>    　　「我說啊……在這裡要叫我歐卡！」歐卡想明明就在信裡說過了啊。「算了，姑且不論現實，這裡就稍微裝一下嘛……」</p><p>不過凱特似乎還抱著好奇的眼神在看著歐卡。</p><p>「做什麼啦……」<br>    　　「不，我知道了……（笑）」凱特笑了，大概真實的靖彥和歐卡差很多吧。<br>    　　「總之這個拿去。」歐卡把自己的MemberAddress給了凱特。「MemberAddress是只能在The World裡使用的信件簡址。只要在The World裡使用簡易信件的話，就可以瞬間送訊息給對方。普通都是利用在遊戲開始時拿來連絡同伴組隊就是了。那就試著把我加入隊伍吧。」</p><p>凱特照著歐卡的說明開始執行著遊戲的指令。</p><p>「……嗯，來了來了。」歐卡收到了凱特的訊息。「『希望加入組隊！』，在對方面前送訊息有點不好意思啊（笑）。不過組隊只能在城鎮裡實行，而且對方若不在The World裡也連絡不到喔。畢竟大家都有自己的事，不可能２４小時都在玩的啦～所以最好是別認為總是可以組到同一隊人。所以囉，儘可能的認識很多ＰＣ並且取得MemberAddress，這樣就能開心的遊戲。反正要怎麼玩隨你高興，因為經驗值和隊伍的人數沒有關係，所以一個人玩也沒有好處啊～（苦笑）。那我們該出發冒險了？……不用擔心，我會好好找個適合初心者的地點的！」</p><p>歐卡指著在兩人旁邊的像是鏡子的藍色平面旋轉物體。</p><p>「這個是混沌之門，是可以讓我們從現在這個城鎮傳送到其他地方的裝置。」</p><p>歐卡在教導著凱特如何輸入片語後，他們便選擇來到了Δ萌え立つ　過越しの　碧野。</p><h1 id="Δ萌え立つ-過越しの-碧野"><a href="#Δ萌え立つ-過越しの-碧野" class="headerlink" title="Δ萌え立つ　過越しの　碧野"></a>Δ萌え立つ　過越しの　碧野</h1><p>歐卡先在原野上告訴凱特如何使用指令、查看地圖和如何戰鬥等等遊戲規則。等到他們覺得原野上已經沒有什麼的時候，兩人便進入了這個領域的地下迷宮。</p><p>迷宮裡又暗又陰森，感覺好像會跑出什麼東西來似的。凱特正好奇的東張西望著。<br>    　　就在前進沒幾步時，歐卡像是聽到了什麼聲音而擋下了跟在他後頭的凱特。<br>    　　歐卡盯著眼前的Ｔ型叉路，是怪物嗎？他等著對方的出現。</p><p>約過數秒的時間，從叉路的一邊所出現的是一名穿著白衣的少女，少女並沒有發現兩人，她的視線是放在她後方的怪物。怪物正在追她，而她似乎也沒有反抗的能力而只能不斷的逃避。<br>    　　少女和怪物就這樣橫過了凱特和歐卡的視野裡。</p><p>「那什麼？你看到了嗎……」歐卡回頭問著凱特。<br>    　　「她是被追嗎？」<br>    　　「看樣子沒錯，不過這個等級的迷宮有那樣的東西嗎……」</p><p>兩人循著路線追了上去，但卻不見人影。</p><p>（是死路，剛才的少女究竟是……）凱特看著走不通的路，思考著少女和怪物是怎麼消失的。</p><p>既然見不到剛才的少女和怪物，兩人便繼續逛這個迷宮。<br>    　　很快的他們便攻略結束這裡。<br>    　　本來應該是要使用道具．精靈之笛離開，不過因為歐卡並沒有帶著，所以只好直接走回原路。但等到他們準備折回原路回到城鎮時，突如其來的系統障礙讓兩人到了一個完全以先前迷宮迴異的地方。<br>    　　荒涼、詭異，若說這是一個廢棄的場所也不為過。</p><p>此時先前看到的少女出現了。</p><p>「不會吧……傳聞是真的嗎……！？」歐卡說著讓凱特完全摸不著頭緒的話，接近了少女。<br>    　　「這個……」少女拿出了一本書交給歐卡。<br>    　　「咦？」<br>    　　「這個拿去……沒有時間了……」<br>    　　「這是……？」<br>    　　「很強的力量……依照使用者的想法，可以成為拯救，亦或是毀滅……」<br>    　　「妳是……」<br>    　　「來了……」</p><p>少女在留下這句話後便煙消雲散，而追隨在消失的少女之後的便是方才所看見的怪物。<br>    　　怪物似乎不再堅持追尋少女，而直接針對著兩人。</p><p>「快逃！現在的你馬上會死的！」</p><p>歐卡在叫凱特趕緊離開後，便獨自上前攻擊。<br>    　　他奮力的舉起大劍揮砍，但怪物似乎不為所動。</p><p>「什麼，這樣的攻擊……普通的攻擊對他沒有用！」</p><p>縱然自己感覺到攻擊對於這位意外的訪客沒有用，但目前除了攻擊也別無他策。<br>    　　但是攻擊無效卻也象徵著失敗的指標，怪物毫不留情的攻擊了歐卡。</p><p>血紅色的十字架禁錮著自己的朋友，凱特在一旁也只能夠顫抖著看著。<br>    　　連等級50的歐卡都束手無策，更何況是才剛進入這個世界的自己。</p><p>怪物在使用了奇怪的攻擊後，十字架便消失了，而歐卡也隨之落地。<br>    　　凱特趕緊跑過去看著歐卡的情況。</p><p>「怎麼會……怎麼會有這種可能……對不起……快逃……」</p><p>歐卡的ＰＣ消失了，原本他從少女手中得到的書本便從他的身體分解而出，轉而飛往天空消失不見。<br>    　　而怪物也沒有就此放過他們，他的目標轉往了凱特。</p><p>這算什麼，為什麼會有這種事？<br>    　　凱特弄不懂目前到底是什麼情況，一切發生的太過突然，他的思緒完全無法思考。</p><p>突然間從天空射下了一把武器讓怪物的攻擊為之停頓，而來自另外的力量則把凱特強制拉離現場。</p><p>│SystemError!│</p><p>一道光芒之後，他掉落在不知名的場景之中，但是他已經毫無意識。<br>    　　此時，原以為消失的書本再度出現，進入了凱特體內。<br>    　　而救了他一命的女子則在天空靜靜的俯視著倒在地上的他，露出了微笑。</p><h1 id="遊戲系統介面-1"><a href="#遊戲系統介面-1" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>『靖彥為什麼會遇到那樣的事呢？雖然我想要確認發生了什麼事，但是他都沒有回電。然後－－等到我知道靖彥住院的事情時，已經是隔天了。雖然我馬上去了醫院，但卻沒有見到靖彥。但是這樣也許比較好吧，因為我不想要看到柔弱的靖彥，而他也應該不想讓我看到。而且……為什麼會發生這種事……我認為這件事的關鍵，一定就在－－The World裡。』</p><p>凱特再次進入了The World裡。<br>    　　如果他想要找出讓靖彥恢復的方法，他想就只有這裡了吧。<br>    　　解鈴，就需繫鈴人。<br>    　　於是他上了ＢＢＳ看看能不能找到任何一點的線索。</p><p>「在ＢＢＳ上寫這件事吧，也許能找到什麼線索。」</p><p>【拜託】<br>    　　　留言者：凱特</p><p>　朋友因為這個遊戲而意識不明。<br>    　　　他住院了，至今尚未回復意識。<br>    　　　但是會發生這種事嗎？<br>    　　　有沒有人知道呢？<br>    　　　或是有誰知道還有什麼人也如此呢？<br>    　　　還是該如何讓朋友恢復呢？<br>    　　　這個遊戲的Maker也會看這裡吧？<br>    　　　什麼都可以，請給我情報。<br>    　　　拜託。</p><p>-<br>  　　就在凱特在ＢＢＳ留言沒有多久，他便收到了一封信。</p><p>送信者：奧＃＊<br>    　　　件名：＃託＊</p><p>給持＃書＠％人（給持有書的人呀）<br>    　　スケィ：＊﹑（スケィス）<br>    　　在找Ｆ＊＋＝（在找我）<br>    　　沒有時％了（沒有時間了）<br>    　　拜＠￥。請幫Ａ＃（拜託，請幫助我）</p><p>（這是誰……亂碼看不懂啊。）</p><h1 id="水の都-マヌ．アク-1"><a href="#水の都-マヌ．アク-1" class="headerlink" title="水の都　マヌ．アク"></a>水の都　マヌ．アク</h1><p>凱特登入了遊戲裡，他踏出了混沌之門。</p><p>一名帶著大劍的少女正在混沌之門前徘徊著，她好像在找什麼人或東西吧，頻頻的來回跺步並東張西望著。<br>    　　而凱特也絲毫不避諱的直盯著她看。大概是好奇吧，所以他的視線一直都沒有離開少女的身上。但是他笑了，那種笑容就好像看穿了女孩的本質一樣。</p><p>「幹嘛……做什麼啦！你是想說什麼！」女孩發現到凱特正在注意她。<br>    　　「沒事……」凱特連忙搖頭。<br>    　　「哈哈～我知道了，你是初心者，沒錯吧！？絕對沒錯吧！」女孩逼近到凱特面前。</p><p>凱特沒有回應，但是女孩的氣勢卻讓他倒退了幾步。<br>    　　女孩的ＰＣ名是黑玫瑰（ブラックローズ），除了那似乎不太適合的大劍外，俏麗的短髮及黝黑的肌膚，還有桃紅色系的服飾感覺起來都與她目前表現出來的個性相符。</p><p>「真沒禮貌。聽好，我特別親切的告訴你，這樣盯著別人瞧違反規定！不管是現實還是在遊戲中都一樣，知道了沒！」在教訓完凱特後，黑玫瑰便離開了。</p><p>凱特被刮了一頓。<br>    　　不過想想確實是自己的錯啦，這樣盯著別人看真的很沒禮貌。反正事過境遷，被罵過就算了，於是凱特準備再踏入混沌之門離開城鎮。</p><p>「等等！」剛才的黑玫瑰又回來了，她叫住凱特。</p><p>又有什麼事啦？凱特被叫了，也只好回頭。</p><p>「喂，你！呃……我知道很有趣的片語哦，若是你能跟我一起去，那我可以特別告訴你。想知道嗎？」</p><p>『請務必告訴我。』★<br>    　　『因為妳很奇怪，算了。』</p><p>「沒錯沒錯！就是這樣。初心者老實點是最好的！片語是Δ隱されし　禁断の　聖域。那我們走吧！」</p><p>反正自己現在也是在找著怎麼救歐卡的方法，那麼四處去察看不也是一種經驗。於是凱特便和她組隊進入了黑玫瑰提供的領域。</p><h1 id="Δ隱されし-禁断の-聖域"><a href="#Δ隱されし-禁断の-聖域" class="headerlink" title="Δ隱されし　禁断の　聖域"></a>Δ隱されし　禁断の　聖域</h1><p>兩人所來到的地方很單純，就是筆直的長道，及長道之後且大門半掩的教堂。<br>    　　凱特雖不懂為什麼黑玫瑰要來這裡，不過看來似乎沒有什麼危險，縱然自己是初心者也應該不會有什麼問題。</p><p>「嗚哇，這裡……」黑玫瑰看來有些害怕。<br>    　　「嗯？」<br>    　　「沒事，我們走吧。你是男孩子的話就好好的保護我！」<br>    　　「喂。」但凱特卻停下腳步叫住了她，他大概想問些事情吧。<br>    　　「哇！哇哇哇哇哇哇哇哇～……我以為心臟會停呢。」黑玫瑰大叫了起來。<br>    　　「……」<br>    　　「做、做、做什麼啦！別這麼突然就出聲叫人，這違反規則！」</p><p>看到黑玫瑰情緒上似乎不是很穩定，凱特也不方便再說些什麼。</p><p>兩人一同進入了教堂裡。</p><p>教堂裡並沒有很華麗，有的只是從天上灑落而下的夕暮。<br>    　　而就在兩人進入的同時，也出現了一隻怪物。</p><p>「咦！？什麼什麼什麼！哇哇！……別過來！討厭～」</p><p>黑玫瑰沒有上前攻擊，反而是慌張了起來。<br>    　　看到她這樣的凱特也只能上前攻擊怪物，不然GameOver也沒有什麼好處。很快的，他便解決了怪物。</p><p>「什麼嘛，很弱小的怪物嘛……這種東西不用我出手。」</p><p>清除了怪物後，隨即出現在兩人眼前的是佇立在教堂內部的巨大少女像。<br>    　　少女像的身上沒有華麗的裝飾，有的只是像是為了要禁錮她的重重鎖鍊。</p><p>「這是什麼……？有種……難過的感覺。」黑玫瑰看著少女像。</p><p>相較於黑玫瑰的反應，凱特則靜靜的站到了少女像的面前。<br>    　　他沒有問黑玫瑰為什麼要來這裡，也沒有問的打算，就只是安靜的站著看著少女像之下的石碑。</p><p>「スケィス、イニス、メイガス……再來字就被削掉看不清楚了。」<br>    　　「呃，我……」<br>    　　「嗯？」<br>    　　「我是初心者的事情曝光了嗎……？」<br>    　　「嗯，是啊……」<br>    　　「這也是啦……我那樣提心吊膽的也難怪會穿幫……而你知道這點還願意跟我來……你也許是個好傢伙呢。」她站到了凱特身邊。「……我呢……有一件無論如何都要調查……」</p><p>就在黑玫瑰想要和凱特解釋些什麼的時候，從入口處射進了大量的光芒。<br>    　　有人打開了教堂的門。</p><p>「你們在這裡做什麼！」是一名背上有著羽翼的劍士，ＰＣ名是巴爾孟克（バルムンク）。<br>    　　「你才是吧，到這裡來做什麼！」黑玫瑰明顯的對這名不速之客感到不悅。<br>    　　「沒有說明的時間了，這裡很危險！」<br>    　　「哈？」<br>    　　「就是叫你們逃走啦！」</p><p>巴爾孟克的警告才一出口，馬上在凱特兩人的附近就出現了變化。怪物</p><p>「快點走！」</p><p>怪物，又是怪物。<br>    　　凱特想，自己怎麼跟這種東西這麼有緣。</p><p>看到怪物的出沒，巴爾孟克隨即抽出自己的劍砍向怪物。這道攻擊非同小可，一般而言，若是遊戲裡所設定的怪物的話，早就應聲消散了。<br>    　　但這個怪物卻沒有，而且還開始散發著異樣的綠光。</p><p>「果然這傢伙也是……！」<br>    　　「怎麼會！怪物不是應該死了嗎！？」黑玫瑰看著怪物的變化。「而且還發光了，感覺真差……有這種東西嗎！？」<br>    　　「是病毒Bug！病毒轉換了資料，這傢伙的ＨＰ是無限的……！」<br>    　　「這傢伙……」<br>    　　「我來爭取時間，你們趁這個時候快走！」<br>    　　「都是因為這個……」聽到了巴爾孟克的話，黑玫瑰明顯出現了怒氣。她舉起大劍衝向怪物。「我殺了你！」<br>    　　「太勉強了，這傢伙打不倒的！別攻擊他，會死的！」巴爾孟克趕緊上前阻止黑玫瑰。</p><p>看到了這一幕的凱特回想起當時歐卡的情形。<br>    　　又來了嗎……？又要再發生先前遇過的事情？<br>    　　不要。<br>    　　絕對不要。</p><p>『書……打開書……』</p><p>不知從哪裡傳來了少女的聲音，而且只有凱特聽的到的樣子。</p><p>「書？」<br>    　　『很強的力量……依照使用者的想法，可以成為拯救，亦或是毀滅。』</p><p>凱特的手裡浮現了少女所說的書。<br>    　　從書裡所釋放出來的許多的資料都侵入了凱特的ＰＣ裡，凱特正被強制性的接受那些資料。<br>    　　而吸收的資料正在改造著凱特，漸漸在他的右手凝聚成為一個無形的腕輪。</p><p>腕輪發動了像殺死歐卡時的技能攻擊了怪物，而怪物原本散發的綠光消失後，變回了原本的模樣。</p><p>「剛才是……歐卡那時候的……」凱特看著自己的右手，回想著剛才發生的事。</p><p>因為凱特發動了書的力量的關係，巴爾孟克擊倒了因病毒而變化的怪物。</p><p>「……」黑玫瑰在鬆懈後便坐在地上。<br>    　　「剛才的技能……是嗎，是這麼回事嗎。你也和那個病毒是同類，我竟然被這種傢伙救了。」<br>    　　「怎麼會……我什麼都……」<br>    　　「別裝傻了！最近The World各地都出現了病毒的被害……對於那種半開玩笑而散佈病毒，而擾亂著這個世界的傢伙，我沒有容許的道理。」<br>    　　「不是的，我是……！」<br>    　　「沒想到這麼快就能遇到元兇。」巴爾孟克拔出了武器。「拔吧，拔出你的劍！」<br>    　　「不要！我沒有戰鬥的理由！」<br>    　　「我這裡有。快拔！」<br>    　　「不要，我不要戰鬥。我……我只是……」<br>    　　「你給我慢著！」黑玫瑰走到了巴爾孟克的面前，指著他。「你也得救了不是嗎！？」<br>    　　「……」他猶豫了數秒，確實黑玫瑰說的沒錯，而且自己也還沒弄清楚事情原委。於是他收起了劍。「這並不代表我相信你，而是我沒有把握而已。當我確認你是那些東西的同伴時……我一定會殺了你。」</p><p>巴爾孟克離開了教堂。</p><p>「フィルナ的末裔．蒼天的巴爾孟克，這樣是不是太孩子氣了呢？」</p><p>有人在叫著走出教堂的巴爾孟克，他停下了腳步巡著聲音的方向看去，是先前救了凱特的ＰＣ，名字是黑爾芭（ヘルバ）。</p><p>「我跟駭客沒什麼好說的！」巴爾孟克不準備搭理她，直接就要離開了。<br>    　　「嘻嘻。」黑爾芭發動了傳送。「他呢，是你的伙伴的朋友。」<br>    　　「歐卡的……？」</p><p>等到巴爾孟克一回頭，黑爾芭已經不見了。<br>    　　而凱特和黑玫瑰也沒有立即離開教堂，兩人還留在裡面。<br>    　　他正在和黑玫瑰說明著先前遇見的事，以及現在所發生的事。</p><p>「我以為他也會像歐卡那樣，所以想說非得做些什麼不可時，我聽到了聲音。我想那時給歐卡書本的那個女孩的聲音。」<br>    　　「是嗎……但是你要怎麼辦呢？病毒還會再出現……而那個力量把你的朋友……」黑玫瑰覺得自己說錯了話。「呃……抱歉。」<br>    　　「我不是很清楚。像這個力量是什麼，那女孩是想要歐卡做什麼，還有持有這種力量的我該怎麼做才好……但我只是想要幫助歐卡……」</p><p>但在這裡思考也沒有定論，而且兩人都累了，於是他們便登出了The World裡。</p><h1 id="遊戲系統介面-2"><a href="#遊戲系統介面-2" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>凱特看著桌面上的信箱，他收到了一個不認識的人的信。</p><p>送信者：黑爾芭<br>    　　　件名：DataDrain</p><p>我看到了你的力量。<br>    　　在怪物的身上出現了ＯＫ字樣時，你若使用腕輪的DataDrain便能夠置換怪物的資料。</p><p>不要弄錯使用的方法，因為這份力量對往後的你有很大的幫助。<br>    　　不，應該說是必須的力量。</p><p>但使用DataDrain這件事，也可能把污染The World的資料給吸入，<br>    　　所以請注意病毒的侵食度。</p><p>侵食度應該可以從你選擇技能的清單就能夠確認到計量表。<br>    　　侵食度為100%時，也就是計量表完全變紅的情況下，你的ＰＣ可能會引起修復不能或是致命的暴走。</p><p>而不使用DataDrain時，打倒怪物能夠讓侵食度些許的下降，<br>    　　所以要經常的注意別讓計量表變成100%。</p><p>那麼我就多管閒事的再給你一個警告。<br>    　　你的行動是完全的被監視著。<br>    　　不管你想不想要，往後你確實就是The World的颱風眼。<br>    　　這是持有腕輪的人的命運。<br>    　　請做好心理準備。</p><p>知道了嗎？</p><p>「她知道腕輪的事……這個人是什麼人？」</p><p>雖然凱特並不懂這封信的意思，但他還是照著上面所寫的注意一下吧。起碼這應該對自己沒有壞處……想著想著，他便移到了ＢＢＳ去確認自己先前所留的言是否有回覆。<br>    　　他跳到了標題為「意識不明」的討論串裡。<br>    　　刪除。<br>    　　無人回覆就算了，他所看到的結果便是如此。</p><p>「我寫的被刪除了……」</p><p>只有系統管理員才有辦法這麼做。<br>    　　不明究理。凱特的心裡只有這句話。<br>    　　這樣的回答是連官方都打算置之不理嗎？</p><h1 id="水の都-マヌ．アク-2"><a href="#水の都-マヌ．アク-2" class="headerlink" title="水の都　マヌ．アク"></a>水の都　マヌ．アク</h1><p>凱特在水之都裡逛著，想說是不是能得到什麼訊息。<br>    　　走著走著，他便來到了巷子裡。那裡有一個貓型的ＰＣ外，還有一個看來是咒紋使的男性ＰＣ。<br>    　　他正追著貓型的ＰＣ。</p><p>「哪哪，找到有很多エノコロ草的領域哦，要去嗎？」ＰＣ名是艾爾克（エルク）的咒紋使問著貓型ＰＣ。<br>    　　「去吧去吧！」<br>    　　「那我們去整備裝備。」艾爾克話才一出口，貓型ＰＣ便跑起步來了。「啊……蜜亞（ミア）？」<br>    　　「喂，你！」叫做蜜亞的貓型的ＰＣ叫住了凱特。<br>    　　「……」凱特指著自己，是在叫他嗎？<br>    　　「沒錯，就是你！」蜜亞接近了凱特。「嗯～很稀有的腕輪呢。讓我看看？」她抬起了凱特的右手觀察著。<br>    　　「妳看的到？」凱特訝異於這個叫蜜亞的ＰＣ看的到一般人無法看見的腕輪。<br>    　　「當然，你看不見這個很棒的腕輪嗎？雖然看不見形體，但能感覺到這個東西的存在，那就等於看的見了。」<br>    　　「腕輪？蜜亞怎麼回事？可是我什麼都沒看到……」艾克盯著凱特的右手瞧。<br>    　　「謝謝你讓我看稀有的東西。」蜜亞要離開了。「總覺得還會再見面的……應該是吧。那後會有期。」</p><p>蜜亞離開了。但艾克卻也還看著凱特的右手，他露出了懷疑的眼神。</p><p>「嗯～」但他就是什麼都沒看到。「等等～蜜亞，エノコロ草呢～？」</p><p>看著兩人的離去後，凱特再看看自己的右手……<br>    　　看來這次也沒有什麼線索，於是他登出了。</p><h1 id="遊戲系統介面-3"><a href="#遊戲系統介面-3" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>凱特看著ＢＢＳ的討論，有一個名為「這是事件人物嗎？」的標題吸引住他。於是他點了進去。</p><p>【謎之少女】<br>    　　　留言者：ＴＡＯ</p><p>　前幾天，<br>    　　　在Δ茫漠だる　騷靈の　沙海的領域迷宮裡，看到了不可思議的人物。<br>    　　　雖然是一個有著長髮且小小的女孩子，但好像不是ＰＣ，<br>    　　　而且連像白色幽靈那種「咻～」的聲音都沒有……<br>    　　　對了！這麼一提，這有可能是我關掉了ＢＧＭ。</p><p>　也許是我看錯了吧，但我想要其他人的目擊情報！<br>    　　　總覺得很在意啊……</p><p>長髮的女孩子，又像幽靈一樣。凱特很快的便想到被怪物追，且給了一本奇怪的書的女孩。<br>    　　那麼也許有一試的價值吧。</p><h1 id="Δ茫漠だる-騷霊の-沙海"><a href="#Δ茫漠だる-騷霊の-沙海" class="headerlink" title="Δ茫漠だる　騷霊の　沙海"></a>Δ茫漠だる　騷霊の　沙海</h1><p>凱特進入了這個領域。<br>    　　這個領域與其他去的迷宮並沒有什麼兩樣，但是四處都漂浮著奇怪的文字串列。<br>    　　而裡面已經有另一名ＰＣ了。</p><p>「看到了ＢＢＳ後想說來看看，結果卻被管理人的ＮＰＣ給趕走。這裡為什麼不能玩啊(T.T)」</p><p>ＰＣ離開了。<br>    　　雖然對方這麼說，但凱特卻不死心的進入了迷宮。</p><p>「非常感謝您遊戲The World。」迷宮的入口真的有著系統管理者擋著。「這個領域的構成資料因為破損，而變成極為不安定的狀態，無法正常的遊戲。請直接回到地圖上，離開這裡回去城鎮。」<br>    　　「不可以……」凱特直接回絕了管理者。「若在這裡放棄的話，我就沒辦法救他！我要前進去看個究竟。」</p><p>不顧著系統管理ＮＰＣ的話，凱特直接闖入了迷宮。<br>    　　確實內部就如同ＮＰＣ說的話一樣，非常的不穩定，一直不斷有著雜訊傳來。<br>    　　而就在他走到了地下三層的時候，那種討厭的雜訊更加的強烈。</p><p>很快的，他遇到了曾在教堂裡看見的改造怪物。</p><p>（……病毒Bug！？不使用DataDrain無法打倒！！）</p><p>原本很強的怪物在凱特的腕輪作用之下變的不堪一擊。他順利的擊倒病毒Bug。</p><p>「(^^)&#x2F;&#x2F;°°°好～厲～害！」沒想到除了凱特外，還有另外的ＰＣ也進來這裡了。「改變怪物的資料來擊倒真令人不敢相信～為什麼能辦到這樣的事呢？」是一名做米絲特拉兒（ミストラル）的女性ＰＣ。<br>    　　「這是……」<br>    　　「啊……難道我踩到雷了嗎？是不可以問的事嗎？我是因為在ＢＢＳ看到了很有趣的領域才來的……不過……真是個怪地方。若要說是檔案破損的話……怎麼～太怪異了(-_-ﾒ)」米絲特拉兒繼續說。「姑且不論這個，奇怪的事好像也在各個領域裡發生呢。而最近的網路障礙也覺得好像突然間增加許多……太明顯了～嗯？啊～～～！！」</p><p>不知道為什麼，米絲特拉兒突然大叫了起來，並且看往另一個方向。而凱特也馬上隨著她的方向看去。<br>    　　什麼都沒有啊。</p><p>「東西燒焦了啦……(T.T)」看來米絲特拉兒的玩家正在煮東西。「請容我先行告退　m(_ _)m」</p><p>就在她準備離開的時候，好像又想到什麼而回頭了。</p><p>「啊，對了。下次讓我加入你吧，請和我一起玩哦～」她傳送離開了。</p><p>看來這次領域的不穩定來自剛才的病毒Bug，而且也找不到少女的蹤影。<br>    　　於是凱特也離開這裡回到了水之都。</p><h1 id="水の都-マヌ．アク-3"><a href="#水の都-マヌ．アク-3" class="headerlink" title="水の都　マヌ．アク"></a>水の都　マヌ．アク</h1><p>凱特回到城鎮，那裡有著一名穿著奇怪鎧甲且比例很差的ＰＣ。<br>    　　西瓜皮、綠色的巨大鎧甲、重斧……到底是什麼樣的美感讓他把自己的ＰＣ弄成這樣。</p><p>「你有著好眼神。」ＰＣ名是小洋（ぴろし）的男子對著凱特說。<br>    　　「咦？」<br>    　　「相信這雙眼神能夠信賴。」小洋不等凱特回答，就自顧自的說起來了。「我認識的ＰＣ被Δ心なき　過食の　巡礼裡的極惡怪物整慘了好幾次，所以我要去打倒極惡怪物，需要一個證人。可以拜託你嗎？」</p><p>『是……可以啦……』★<br>    　　『呃……不要……』</p><p>「喔，不愧是我看上的人。是嗎，你要接受嗎！是嗎、是嗎，哈哈哈……那麼請到Δ心なき　過食の　巡礼等著。哎呀，真令人高興啊，哈哈哈哈……」</p><h1 id="Δ心なき-過食の-巡礼"><a href="#Δ心なき-過食の-巡礼" class="headerlink" title="Δ心なき　過食の　巡礼"></a>Δ心なき　過食の　巡礼</h1><p>使用著小洋給的片語，凱特來到了這個領域。</p><p>「小洋先生在這個迷宮裡嗎？」</p><p>凱特走到了迷宮的最下層後，找到了小洋，還有他準備要戰鬥的怪物。</p><p>「有著好眼神的人啊！好好的看著！」</p><p>小洋揮動著重斧攻擊上去。不過怪物可硬的咧。</p><p>「頑強！太頑強了啊！……噗！呼、呼……今天的我可和平時不同，以為這種程度的攻擊能打倒我嗎！讓我看看你真正的力量！」</p><p>小洋是拼命的攻擊了，但怪物就是打不倒。他就陷入了回復→沒什麼效果的攻擊→挨打→回復的迴圈裡。</p><p>「要不要緊啊……」凱特在一旁看著。「去幫忙。」<br>    　　「你出手是沒用的！噗啊！」</p><p>雖然小洋這麼說，不過凱特還是出手幫忙了。<br>    　　在合作的攻擊下，兩人打倒了怪物。</p><p>「嗯～真是清爽的戰鬥……戰利品就給你吧。」小洋塞了東西給凱特。<br>    　　「謝……謝謝。」<br>    　　「哈哈哈哈，不用客氣！我有預感會在某個地方再遇見你的。到那一天之前……再會了！即使旅行結束了，頭上的星星依舊閃耀！」小洋離開了。<br>    　　「…………」凱特實在搞不懂這個人。（什麼啊……不過算了。拿到了他的MemberAddress，下次來找他吧。）</p><h1 id="遊戲糸統介面"><a href="#遊戲糸統介面" class="headerlink" title="遊戲糸統介面"></a>遊戲糸統介面</h1><p>送信者：蜜亞<br>    　　　件名：腕輪之力</p><p>你的腕輪之力不是只有DataDrain而已。<br>    　　你知道嗎？</p><p>想知道吧。<br>    　　我在Δ果てなき　大罪の　累壁等著，你一個人來。</p><h1 id="Δ果てなき-大罪の-累壁"><a href="#Δ果てなき-大罪の-累壁" class="headerlink" title="Δ果てなき　大罪の　累壁"></a>Δ果てなき　大罪の　累壁</h1><p>蜜亞所指定的領域是夜晚。雖然看不清楚周圍的景象，但四處都充滿了蟲鳴，讓人的心情頓時放鬆下來。唯一顯著的是，掛在天空中的閃耀明月。<br>    　　可是，這裡和傳聞目擊過少女的領域一樣，也漂浮著文字。<br>    　　還有就是，那同樣的雜訊。</p><p>『嗨！正在等你。其實我也對那個腕輪有興趣，謝謝你來這裡。』蜜亞本人並不在現場，她利用著短訊與凱特對談。『我在迷宮的最深處，可以到這邊來嗎？』<br>    　　「妳……為什麼會知道DataDrain的事呢？」<br>    　　『這個嘛……為什麼呢……』</p><p>蜜亞到這邊便停止通訊了，看來要到她那裡才能得到答案吧。<br>    　　不過這裡果然就跟先前去追尋少女的領域一樣，也有著系統管理員在迷宮前說著這裡資料破損。</p><p>（不能就這樣回去……！！去迷宮的深處看看！！）</p><p>凱特獨自深入迷宮之中。<br>    　　走到地下三層時，蜜亞傳來了短訊。</p><p>『這種氣氛如何呢？你也能夠看見那份損壞吧？但是呢……有什麼要存活下去，就非得破壞某個什麼。人也是一樣的，你知道嗎……？』</p><p>而到地下四層時，蜜亞再次傳來短訊。</p><p>『為了知道腕輪的秘密而來到這裡，但是你並不完全的信任我。不只是一或是零，也有容許在Yes or No之間的曖昧領域。人類真的很有趣呢。』</p><p>凱特不懂蜜亞究竟想要傳達什麼，這是單純對自己的試探，或者是心靈上的攻擊？<br>    　　所以他都沒有回應蜜亞。<br>    　　就算回應了，她大概也不會回答。</p><p>等到凱特走到了第五層後，他看到了一個魔法陣。</p><p>『接近那個魔法陣吧。』蜜亞說。</p><p>魔法陣所出現的不會有別的，就是怪物，一隻巨大的飛鳥。而且還是病毒Bug。</p><p>『來吧……讓我看看腕輪的持有者的力量！』</p><p>如果想見到蜜亞，就只能擊倒怪物，凱特便毫不猶豫的使用了DataDrain擊敗了怪物。</p><p>「那就是DataDrain啊，第一次看到……」在凱特擊敗了怪物後，蜜亞出現了，還帶著艾爾克。<br>    　　「妳說什麼，少愚弄人了！」<br>    　　「生氣了嗎？」蜜亞並不理會凱特的怒氣而直接說下去。「你想知道你持有著多大的力量吧。但要是你太過沒用的話，就算我告訴你犯規的開門法也沒有意義。」</p><p>換句話說，蜜亞之所以要凱特打倒怪物，只是想看看他的實力罷了。</p><p>「犯規的開門法？」<br>    　　「你所抽取的病毒核心是有使用法的，那是能夠打破被保護的領域的障壁的鑰匙。當然這個東西由腕輪持有者以外的人持有時，是沒有任何作用的。若要我教你這個犯規的方法，就到混沌之門來。DataDrain真是有趣呢。」</p><p>蜜亞語畢後，便帶著艾爾克離開了。<br>    　　隨後，凱特也脫離了迷宮。</p><h1 id="水の都-マヌ．アク-4"><a href="#水の都-マヌ．アク-4" class="headerlink" title="水の都　マヌ．アク"></a>水の都　マヌ．アク</h1><p>他到了混沌之門前，蜜亞和艾爾克兩人已經在那裡了。</p><p>「首先把我們加入隊伍，然後進入門裡。」</p><p>凱特在把蜜亞和艾爾克兩人加入隊伍後，進入了混沌之門並且依照蜜亞所說的方法，開始利用著病毒核心修改遊戲資料。很快的腕輪便發動異於DataDrain的能力，把他們送進去了被系統所保護的領域裡。</p><h1 id="Δ閉ざされし-忘卻の-双丘"><a href="#Δ閉ざされし-忘卻の-双丘" class="headerlink" title="Δ閉ざされし　忘卻の　双丘"></a>Δ閉ざされし　忘卻の　双丘</h1><p>一樣是個夜晚的領域，不過這裡可以看到的是整個領域被綠色的外牆所包覆著。</p><p>「之所以會被保護著，一定就是有著什麼，所以才說要用鑰匙去開對吧？」蜜亞很滿意這個結果。</p><p>既然都進來了，於是一行人便探索著這裡。<br>    　　而這個領域裡充滿著飛散的文字，也代表著這裡有著病毒Bug。<br>    　　等到他們走到了迷宮的最深處時，便看到了一個魔法陣。</p><p>「接近魔法陣時，就會出現病毒Bug。而實行DataDrain的話，就能得到病毒核心。你持有著腕輪應該是有什麼理由對吧？而為了知道這點……當然要前進吧？」<br>    　　「我持有著腕輪的……理由……」</p><p>三人合力擊倒了從魔法陣出現的病毒Bug。</p><p>「這個腕輪……其實是我的朋友的東西……我來說明發生至今的原委吧。」<br>    　　「你的事情對我來說怎樣都好。」蜜亞表示她對先前的事沒有興趣。「不過我對於持有腕輪的你想要做什麼非常有興趣。就因為這個理由，所以只要我能幫的上忙，我會盡全力協助你。」<br>    　　「……謝謝妳。」<br>    　　「不用道謝，我只是在做自己想要做的事。」<br>    　　「哪，蜜亞……」艾爾克出聲想要問蜜亞些什麼時，蜜亞卻傳送離開了。「……」</p><p>既然蜜亞都離開了，那艾爾克也沒有留下的必要。他看了凱特一眼後，便離開了領域。<br>    　　隨後，凱特也出去了。</p><h1 id="水の都-マヌ．アク-5"><a href="#水の都-マヌ．アク-5" class="headerlink" title="水の都　マヌ．アク"></a>水の都　マヌ．アク</h1><p>凱特在一登入The World後，便看見了巴爾孟克。</p><p>「又遇見了。你認識歐卡吧？」巴爾孟克在看見凱特便走近了他。<br>  　　「他的事我很清楚，而且是他帶我開始玩這個遊戲的。」<br>  　　「那我要問你，在那個異變之後，就再也沒有連絡了。他現在在做什麼？」<br>  　　「你會相信的話我就說。」<br>  　　「根據你的內容判斷。」</p><p>於是凱特向巴爾孟克說明著這段時間所發生的事。</p><p>「原來如此……但這種事那些是真實的我不知道。不過你最好記住，你的腕輪之力和讓歐卡意識不明的傢伙是一樣的東西！」</p><p>巴爾孟克在留下這句話後，便離開了。<br>  　　這句話非常傷人，凱特不禁抓著自己的右手。</p><p>「這種事情……我當然知道。」<br>  　　「沒有喪氣的空閒囉。」從凱特的後方傳來了女子的聲音，是黑爾芭。<br>  　　「……妳是？」<br>  　　「是敵人或者是同伴吧（笑）……」黑爾芭向凱特敬了禮後，便笑了。「我是多管閒事的警告者。」<br>  　　「妳是寄信給我的人嗎……？黑爾芭？」<br>  　　「這種事別管，請你注意琉斯（リョース）這個人。」<br>  　　「琉斯？」<br>  　　「琉斯是系統的人，他把持有腕輪的你當作病毒。而且……你需要這個吧。」</p><p>黑爾芭給了凱特病毒核心。</p><p>「你一臉為什麼我會知道的表情是嗎，就算沒有透過螢幕我也能想像。我說過囉，『你一直都在被某人看著。』。」<br>  　　「……為什麼要幫我呢？」<br>  　　「幫你？這個該怎麼說呢……也許受到幫助的人是我呢。那再見囉，小男孩。」</p><h1 id="遊戲系統介面-4"><a href="#遊戲系統介面-4" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>ＢＢＳ有了新的留言了。<br>  　　由於先前有人發過看見少女的留言，也許還會有什麼相關討論也說不定，所以凱特便去看看。</p><p>【ＲＥ：謎之少女】<br>  　　　留言者：まりん</p><p>　這個まりん也看到了哦。<br>  　　　穿著白色洋裝的女孩子，<br>  　　　好像，<br>  　　　被拿著巨大十字架的黑色傢伙追著的樣子。<br>  　　　地點是，<br>  　　　Θ靜穩なる　久遠の　白魔<br>  　　　是這樣吧？<br>  　　　可是在那之後就進不去了的樣子了，為什麼呢？</p><p>  　　有了……<br>    　　Θ靜穩なる　久遠の　白魔嗎？<br>    　　凱特正想要進入The World時，傳來了信件送達的聲音。</p><p>  　　送信者：ア＃＊　（奧拉）<br>    　　　件名：生＊＃た＠　（生存下去）</p><p>＠は生＊＃たい。　（我要生存下去）<br>  　　？きたい。　（我要活下去）<br>  　　ただ＠％だけ＊のに。　（就只是這樣而已）<br>  　　＄さ％。モ＃ガ＆が……　（父親，モルガナ……）<br>  　　腕＊を持＋人　あ＠たの助％が＃要＊す。　（持有腕輪的人，你的協助是必須的。）<br>  　　これ＃上の犧＊が增Ｆる前＊、は＃く！　（在犧牲更多之前，快點！）</p><p>  　　不知名的人物又寄信來了，而且仍舊是亂碼。<br>    　　這樣誰看的懂啦。<br>    　　於是凱特並沒有特別搭理這封信，往下一封信看。</p><p>  　　送信者：黑玫瑰<br>    　　　件名：該走囉</p><p>在ＢＢＳ裡有你說的拿著巨大十字架的傢伙，還有白色少女的話題呢。<br>  　　確實是在……<br>  　　Θ靜穩なる　久遠の　白魔<br>  　　裡目擊到的樣子？<br>  　　是不是該去Θ伺服看看了呢？</p><h1 id="高山都市-ドゥナ．ロリヤック"><a href="#高山都市-ドゥナ．ロリヤック" class="headerlink" title="高山都市　ドゥナ．ロリヤック"></a>高山都市　ドゥナ．ロリヤック</h1><p>「喔。」黑玫瑰已經在這個伺服的路由城鎮等著凱特了。「讓女孩子等候可違反規則的哦！（笑）」</p><p>黑玫瑰走近了凱特。</p><p>「要去Θ靜穩なる　久遠の　白魔對吧？我在混沌之門等你，你準備好的話快點過來。」<br>  　　「嗯，會快點（笑）。」</p><h1 id="Θ靜穩なる-久遠の-白魔"><a href="#Θ靜穩なる-久遠の-白魔" class="headerlink" title="Θ靜穩なる　久遠の　白魔"></a>Θ靜穩なる　久遠の　白魔</h1><p>「很順利就進來了嘛……真奇怪……」黑玫瑰想著在ＢＢＳ上看到的，不是說進不來嗎？</p><p>或許是因為凱特腕輪的緣故吧。二人並沒有多想，便深入了迷宮之中。<br>  　　但是……<br>  　　迷宮的深處卻是沒有轉寰餘地的死路。</p><p>（到這裡就沒路了。）凱特想。「沒有……不管是黑色的傢伙或是少女都沒有。」他的口氣有些失望，到底要追到什麼時候才有辦法得到線索。<br>  　　「碰壁了？有這種事嗎？」黑玫瑰看著四周，姑且不論是死路，但就連迷宮裡該有的神像都沒有。「怎麼覺得好像受騙了……不過待在這裡也毫無辦法，回去吧？」</p><h1 id="水の都-マヌ．アク-6"><a href="#水の都-マヌ．アク-6" class="headerlink" title="水の都　マヌ．アク"></a>水の都　マヌ．アク</h1><p>另一方面，蜜亞和艾爾克還是待在水之都的老地方在談話。</p><p>「蜜亞，妳最近好奇怪……為什麼這麼在意那傢伙的事情呢？」艾爾克說。<br>  　　「我要做什麼跟艾爾克你無關吧。」<br>  　　「蜜亞妳……喜歡他嗎？」<br>  　　「喜歡？」蜜亞停頓了約數秒，似乎是不太瞭解。「喜歡是什麼？」<br>  　　「蜜亞……我呢，喜歡蜜亞。」<br>  　　「咦……？這什麼奇怪的感覺。」</p><p>話說到此，艾爾克就沒有再說些什麼了。<br>  　　他跟蜜亞分開後，就到了混沌之門，剛好就遇見了回到這裡來的凱特。</p><p>「喂，你！可以打擾一下嗎？」艾爾克叫住了凱特。「有一個讓人挺在意的領域，而且有點奇怪，我想或許是因為病毒Bug的關係吧。若是這樣的話就非得拜託你。領域是Δ豊穰なる　微笑の　菌糸，要一起去嗎？」<br>  　　「好啊。」凱特很乾脆就答應了。<br>  　　「謝謝你！」</p><h1 id="Δ豊穰なる-微笑の-菌糸"><a href="#Δ豊穰なる-微笑の-菌糸" class="headerlink" title="Δ豊穰なる　微笑の　菌糸"></a>Δ豊穰なる　微笑の　菌糸</h1><p>艾爾克所指定的領域在進入後，並沒有什麼怪異的地方。<br>  　　像是先前看過的漂浮文字，或是莫名其妙的雜訊都沒有。換句話說，這裡應該沒有病毒Bug才對。</p><p>「沒有什麼奇怪的地方呢？」凱特說。<br>  　　「對不起……」艾爾克突然道起歉來。「其實……呃……我有事相求……」<br>  　　「……？」<br>  　　「我把我至今所有收集到的東西都給你，所以……呃……請和我交換那個腕輪！」</p><p>原來艾爾克的目的只是想要單獨和凱特對話，然後想要換到那個讓蜜亞感興趣的腕輪。<br>  　　若是能得到那個腕輪的話，蜜亞的視線就在會自己身上。</p><p>「拜託你！請跟我換！這麼一來……若能成為腕輪的持有者的話，就能和蜜亞如同往常一樣遊玩了。」<br>  　　「……」</p><p>凱特沈默了。如果這只是個單純的東西，那他也想完成艾爾克的願望。但是現在不行。第一是，他完全不知道這是什麼東西，除了曉得部分的能力外，他當然不可能會知道怎麼卸除它。第二，就算可以放棄，那也不會是現在，因為他還得靠這個東西救歐卡。<br>  　　不是放手的時候，也不知怎麼放手。<br>  　　就當凱特想要說些什麼時，雜訊出現了。</p><p>「嗚哇……！」艾爾克嚇了一跳。「什麼？什麼？」<br>  　　「去迷宮吧，也許有什麼……」</p><p>兩人進入了這個領域的迷宮之中。<br>  　　相較起原野的地圖，迷宮很清楚的可以看出資料損毀。</p><p>「之前明明不是這樣的啊。」艾爾克說。「我的謊言竟然成真了……」<br>  　　「謊言？」<br>  　　「為了把你叫來這裡，所以我才這麼說的……」</p><p>就算艾爾克真的謊言成真好了，那未免也太過於湊巧。<br>  　　凱特沒有責怪他，反而是冷靜的看待這個迷宮的變化。<br>  　　也許自己……遇到了一個好機會也說不定。<br>  　　依照先前的經驗，少女的出沒地點幾乎都是產生資料異變的領域。只是因為自己都是經由外部所提供的資訊才會前來探訪，希望能夠得到一絲的希望。<br>  　　但總是事與願違，所謂後知後覺大概就是那種情況吧。雖然有情報，但等到自己過來的時候，根本就找不到少女的蹤影，甚至連一點想要當成是線索的痕跡都沒有。<br>  　　可是這次不一樣了，自己處於正在改變的迷宮裡，不再是被動的情況。<br>  　　那麼自己或許該感謝艾爾克的謊言。</p><p>凱特沒有猶豫，直接就深入了迷宮之中。<br>  　　找到少女，他必須找到少女。<br>  　　於是他加緊了腳步，一心一意的搜尋著這個地方。</p><p>但是……在迷宮深處的不是少女，而是蜜亞。<br>  　　而且在她的面前還有著病毒Bug。</p><p>「蜜亞，妳為什麼會在這裡！？」看到了蜜亞，艾爾克驚呼出聲。<br>  　　「艾爾克！！！」蜜亞似乎也很訝異兩人的出現。<br>  　　「蜜亞在呼喚，蜜亞她在呼喚著我……！」</p><p>蜜亞先行呼喚的不是凱特，而是自己。艾爾克很快的就跑到她的身邊。<br>  　　三人一同擊倒了病毒Bug。</p><p>「艾爾克……你果然在這裡。我在找你。」<br>  　　「妳在……找我？」<br>  　　「我雖然不是很懂……但是艾爾克不在會讓我覺得寂寞。」<br>  　　「蜜亞謝謝妳……」艾爾克喜出望外，沒想到蜜亞會這麼重視自己。「但是妳喜歡的領域變成這樣了。」<br>  　　「理論上，領域這種東西是無限的。所以還能再找到的哦，找到我們喜歡的領域。」<br>  　　「嗯……是啊。」</p><p>蜜亞和艾爾克就這樣自顧自的傳送離開了，根本就無視於被騙來的凱特。</p><p>「………………」</p><p>凱特很無言。<br>  　　不過算了，至少事情解決了，而且他們高興就好，計較這麼多也沒用。<br>  　　於是他回去了路由城鎮。</p><h1 id="水の都-マヌ．アク-7"><a href="#水の都-マヌ．アク-7" class="headerlink" title="水の都　マヌ．アク"></a>水の都　マヌ．アク</h1><p>「我真的可以拿這個東西嗎？」<br>  　　「當然啊！」</p><p>凱特看到了稀有的組合了。<br>  　　是小洋和蜜亞，而且蜜亞似乎給了小洋東西的樣子。</p><p>「喔～～那麼我就……」小洋使用了蜜亞給的東西。「嗚哇！！」他似乎是中了狀態了。<br>  　　「嘻嘻嘻嘻嘻。」蜜亞笑了起來。「想要回復的話，就去Δ鼻曲がる　沸血の　處刑場找回復道具吧。」</p><p>蜜亞在整了小洋後，就直接離開了。</p><p>「喂……喂！」小洋的呼喚對蜜亞是無效的。</p><p>果然天底下沒有白吃的午餐啊，凱特想。</p><p>「……她是給你什麼？」凱特問。<br>  　　「…………變成帥哥的藥。」<br>  　　「……」凱特很想大笑出來，但這樣似乎是太失禮了。「總、總之去Δ鼻曲がる　沸血の　處刑場看看吧。」他很拼命的忍住笑聲。「噗嘻嘻嘻。」</p><h1 id="Δ鼻曲がる-沸血の-處刑場"><a href="#Δ鼻曲がる-沸血の-處刑場" class="headerlink" title="Δ鼻曲がる　沸血の　處刑場"></a>Δ鼻曲がる　沸血の　處刑場</h1><p>很快的，凱特帶著小洋在這裡的迷宮的地下一層裡找到了治療藥．改。</p><p>「這就是回復道具了！快點給我吧！」小洋使用了治療藥．改。「要再更更更更更更……」似乎藥只有一點效果的樣子。<br>  　　（再找其他的寶箱吧。）</p><p>兩人又到了地下二層找到了真．治療藥。</p><p>「絕對是這個啦！快點給我！」小洋使用了真．治療藥。「感覺好像稍微變強了點……」<br>  　　（再找其他的寶箱吧。）</p><p>在地下三層找到了元祖．治療藥。</p><p>「一定是這個了！不會錯的！」小洋使用了元祖．治療藥，總算是回復了。「喔喔！！！」</p><p>就在小洋高興的那一瞬間，狀況又變差了。</p><p>「真遺憾呢（笑）。」凱特實在是不知道該說什麼了。（再找其他的寶箱吧。）</p><p>結果，在最後一層找到了治療藥。</p><p>「……」小洋對這個藥似乎沒什麼信心的樣子，不過得用且用吧。「回復了……」<br>  　　「太好了不是嗎。」<br>  　　「嗯！當作是謝禮，這個傳授給你。」小洋給了凱特『小洋的自傳』。<br>  　　「呃、謝謝……」<br>  　　「頭上的星星會閃耀的啦！」</p><p>既然小洋的困難解決了，凱特便登出了。</p><h1 id="遊戲系統介面-5"><a href="#遊戲系統介面-5" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>凱特在ＢＢＳ看到了新的討論串了，標題是「病毒？」。<br>  　　以一個網路遊戲來說，有病毒似乎也不為過，但是加個問號就令人匪夷所思。<br>  　　於是凱特點進去看。</p><p>【令人擔心】<br>  　　　留言者：ＧＯＮＴＡ</p><p>　怎麼這段期間，在伺服障礙中有個奇怪的障礙相當引人注目呢，這要不要緊啊？<br>  　　　雖然有一部份的傳言是說有人在散布病毒……</p><p>  　　就在凱特看完留言的同時，傳來了信件送達的聲音。他跳出了ＢＢＳ，轉往信箱察看。</p><p>送信者：黑玫瑰<br>  　　　件名：嚇一跳呢</p><p>就是這個。<br>  　　先前我們去Θ靜穩なる　久遠の　白魔時，<br>  　　雖然進入了迷宮的深處，但卻沒有路對吧。</p><p>我覺得很失望的的時候，想到寫那篇留言的人……<br>  　　對方叫まりん對吧？<br>  　　我直接寫信問對方。</p><p>雖然對方不太願意回答我，<br>  　　但在我追根究底之下，竟然是這樣的！</p><p>那些片語不知道是被誰換掉了！<br>  　　所以對方的心情也不太好。<br>  　　那麼真正的片語是這個。</p><p>Θ呪われし　失意の　楽園</p><p>當然要去對吧？</p><p>  　　當然要去啊。<br>    　　凱特在看完信件後，便登入了The World，準備找黑玫瑰。</p><h1 id="高山都市-ドゥナ．ロリヤック-1"><a href="#高山都市-ドゥナ．ロリヤック-1" class="headerlink" title="高山都市　ドゥナ．ロリヤック"></a>高山都市　ドゥナ．ロリヤック</h1><p>但是當凱特和黑玫瑰兩人正準備進入Θ呪われし　失意の　楽園的領域時，卻因為障礙而進不去。</p><p>「病毒核心不夠……」凱特看著無法進入的領域有些苦惱。<br>  　　「大概那個人就是輸入了這個片語，然後就被某人換掉了……」<br>  　　「這麼說，我所寫的也是……」凱特想也許是同一個人所為。<br>  　　「你說被刪除了吧。雖然不是很瞭解為什麼……真是討厭的感覺。」</p><p>既然進不去，凱特也只好再去找別的線索。</p><h1 id="遊戲系統介面-6"><a href="#遊戲系統介面-6" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>送信者：蜜絲特拉兒<br>  　　　件名：久未問候</p><p>你好～～～～<br>  　　最近怎麼都沒看到你呢？<br>  　　那個很厲害的技術我還想看呢。<br>  　　讓我看讓我看！</p><p>  　　呃、這個人到底在想什麼啊？DataDrain可不是好玩的東西耶。<br>    　　凱特看著這封信不禁笑了。<br>    　　反正對方也不是討厭的人，於是凱特回了信給她，說自己最近都在Θ伺服，有機會再一起冒險。</p><h1 id="高山都市-ドゥナ．ロリヤック-2"><a href="#高山都市-ドゥナ．ロリヤック-2" class="headerlink" title="高山都市　ドゥナ．ロリヤック"></a>高山都市　ドゥナ．ロリヤック</h1><p>沒想到凱特才一登入，就看到了蜜絲特拉兒。她好像在跟玩家商談的樣子。</p><p>「饒了我吧……這可是超級珍貴的道具呢，就是9999ＧＰ！沒得談！」<br>  　　「能不能分期付款？」蜜絲特拉兒問。<br>  　　「若是有高利息的話可以。」<br>  　　「嗚哇～高利貸地獄就免了吧……&#96;s(- -;)」<br>  　　「高利貸地獄啊……真討厭的詞彙。」<br>  　　「我親身體驗過……(T^T)」<br>  　　「好，算啦，交涉破裂啦。」</p><p>此時蜜絲特拉兒發現了凱特來到這裡了。</p><p>「啊……你從哪裡開始看起的？(^^;)」她問。<br>  　　「從『能不能分期付款？』那裡開始。」<br>  　　「啊哈哈哈哈。σ(^◇^;)……我是那種道具沒有全部收集完就無法善罷干休的類型啦♪。不然我就會心情糟的跟什麼似的(^_^;)」<br>  　　「是、是嗎……」<br>  　　「不過～在這附近逛個一圈後，腦袋就會冷靜下來了　(<em>^-^</em>)」蜜絲特拉兒離開了。<br>  　　「唷！」生意做不成的玩家轉向和凱特講話。<br>  　　「是？」<br>  　　「我有個『鐵壁之書』喔，有沒有興趣？有吧？有吧？裝備這個道具的話，能夠高機率的使敵人的攻擊無效化喔。」<br>  　　「……」凱特沒什麼興趣的樣子。<br>  　　「999ＧＰ如何呢？」<br>  　　「咦？剛才是要賣蜜絲特拉兒9999ＧＰ。」<br>  　　「騙人～這樣可差了一個數字吧。不過那個是那個，而且剛才的人也不在了。好啦，買啦～會有用的啦。」<br>  　　「不要。」<br>  　　「別這麼說嘛，買啦～能抵擋攻擊呢……不想要嗎？」<br>  　　「但我還是不要。」<br>  　　「喔呀？相當固執的傢伙呢……那麼我也有骨氣的，我什麼都不要了，給你吧。」玩家把東西塞給凱特。「啊，對了……有一個叫做黑爾芭的惡劣駭客，要小心喔。」</p><p>玩家離開後，換成蜜絲特拉兒回來了。</p><p>「剛才的人呢？」<br>  　　「走啦。」<br>  　　「啊～慢了一步……(T T)，人家賣了不要的東西又來了呢。啊，對了！這是我從武器屋那聽來的，說Θ瓦解せる　剎那の　螺旋這個領域好像很危險呢。我們一起去吧，我還想看那個技術呢。」<br>  　　「……」<br>  　　「哪，走吧！真期待。」<br>  　　「嗯……嗯……」</p><p>凱特想，他真的對這個蜜絲特拉兒的天真毫無辦法呢。<br>  　　都聽說很危險了，還打算去。<br>  　　不過也許能得到什麼線索或病毒核心，去去也無妨。</p><h1 id="Θ瓦解せる-剎那の-螺旋"><a href="#Θ瓦解せる-剎那の-螺旋" class="headerlink" title="Θ瓦解せる　剎那の　螺旋"></a>Θ瓦解せる　剎那の　螺旋</h1><p>飛散的文字和雜訊。<br>  　　那麼這裡有改造病毒了。</p><p>「這裡都破損了呢，真是好棒的演出呢。」蜜絲特拉兒好像對這裡的環境很滿意似的。<br>  　　「……」</p><p>兩人到了迷宮的底層後，果真有改造病毒，他們合力擊倒了怪物。<br>  　　凱特拿到了新的病毒核心。</p><p>「那個腕輪好棒哦。」蜜絲特拉兒看著凱特使用著自己不能用的技術，發出羨慕的聲音。「那是在哪裡入手的？我也想要～」</p><p>凱特想想，告訴她也無妨吧。於是他跟蜜絲特拉兒說明至今事情發生的經過。</p><p>「嘿～有這樣的事件啊。」<br>  　　「不是啦，這不是事件……」<br>  　　「啊！下雨了！要去收衣服了！那就這樣，我失陪了！」蜜絲特拉兒完全沒聽凱特要說什麼，就自顧自的離開了。<br>  　　「……」</p><p>凱特想，這個人真的很鮮耶。<br>  　　不過也多虧了她的訊息，拿到了新的病毒核心。</p><p>（這個病毒核心也許能夠入侵Θ呪われし　失意の　楽園。）</p><h1 id="Θ呪われし-失意の-楽園"><a href="#Θ呪われし-失意の-楽園" class="headerlink" title="Θ呪われし　失意の　楽園"></a>Θ呪われし　失意の　楽園</h1><p>凱特和黑玫瑰兩人入侵了這個領域後，確實是個資料破損的地方。<br>  　　原本的肉壁型迷宮因為資料損毀而變成像個滿是毒沼的領域，看起來除了多份陰森外，踩踏起來的感覺也令人噁心。<br>  　　但是在穿過這樣的領域後，底層的盡頭卻是一個純白色的空間。</p><p>「這裡是……」凱特從未在The World看過這樣的地方。</p><p>純白色的空間裡除了兩人外，就只有滿佈在地上的玩具熊，還有一個小朋友睡覺的床舖。<br>  　　在兩人詫異於這裡的環境時，出現了一個男人的聲音。</p><p>『所以我取名為奧拉。若沒有妳，就沒有這個孩子，這個光輝的孩子，奧拉。我們的意志託付於她，我們的未來託付於她，她是我們的……』</p><p>沒多久，聲音消失了。<br>  　　而凱特拿到了一本『ハロルドの手記』。</p><p>「這……什麼啊。」黑玫瑰不懂聲音所要傳達的意思。<br>  　　「我不知道……但是奧拉……不就是那個女孩子嗎。」<br>  　　「你說女孩子……就是那個給了腕輪的人嗎？」<br>  　　「嗯，我是有這種感覺……」<br>  　　「啊，那裡好像有什麼呢。」</p><p>從黑玫瑰所看去的方向，有著一片破碎的東西。<br>  　　兩人把那東西撿起時，再度傳來了聲音。但這次是女聲。</p><p>『背對著被『波濤』所蹂躪的麥田的帶影女孩說著：『一定、一定要回來。』。然而，女孩並不知道。這趟旅行的終點，所等待的真實，會使他們永遠失去他們的大地。』</p><p>兩人手裡拿著那片碑文的碎片。</p><p>「這又是什麼啦，真搞不懂。」黑玫瑰說。<br>  　　「嗯……」</p><p>又是一個無解的謎。<br>  　　苦思無解的話，也只好繼續前進。<br>  　　凱特早就明白這並不是一趟好走的路。<br>  　　為了找尋更新的訊息，兩人便又登出了。</p><h1 id="遊戲系統介面-7"><a href="#遊戲系統介面-7" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>送信者：黑玫瑰<br>  　　　件名：看過ＢＢＳ了嗎？</p><p>標題是ＭＩＳＳＩＮＧ的留言，有發現到嗎？<br>  　　我稍微去調查一下好了。</p><p>  　　ＭＩＳＳＩＮＧ的留言？<br>    　　凱特毫無思索的便去察看了。不過已經有數篇討論，凱特也還是全看再來做判斷。</p><p>【アルフさん】<br>  　　　留言者：メグ</p><p>　最近沒有看到アルフ，我有點擔心。<br>  　　　アルフ還好嗎？</p><p>【ＲＥ：アルフさん】<br>  　　　留言者：ちゃくら</p><p>　這麼一說，確實最近沒看到。<br>  　　　也許是玩膩了吧。</p><p>【ＲＥ：アルフさん】<br>  　　　留言者：メグ</p><p>　嗯～是這樣嗎？</p><p>　最後一次見面的時候，說發現到很有趣的領域呢。<br>  　　　而且還說要突破那裡。<br>  　　　感覺起來不太像是玩膩了。</p><p>【ＲＥ：アルフさん】<br>  　　　留言者：知惠藏</p><p>　你要是知道那裡的資料編碼，去看看吧？</p><p>【ＲＥ：アルフさん】<br>  　　　留言者：メグ</p><p>　我去試過了，但是那裡被保護著而進不去啊(T.T)<br>  　　　就算我寫信也沒回信……<br>  　　　被討厭了吧，嗚。</p><p>  　　凱特看完了所有的留言。<br>    　　又是一個被保護著的領域，那麼這個叫アルフ的難道也出意外了嗎？<br>    　　就在凱特在思考的同時，出現了另一篇新的留言。<br>    　　而且是留言給歐卡的。</p><p>  　　【我是波普（ボブ）】<br>    　　　留言者：波普</p><p>　雖然有點晚了，但我得到『那個東西』囉。<br>  　　　我會在那個地方等著，你帶著朋友來吧。</p><p>　Ｐ. Ｓ.<br>  　　　信件的情況好像怪怪的呢，我在這裡留言應該沒什麼問題吧？</p><p>  　　（這是……是指歐卡帶我去的那個領域嗎……？好，去Δ萌え立つ　過越しの　碧野！）</p><h1 id="Δ萌え立つ-過越しの-碧野-1"><a href="#Δ萌え立つ-過越しの-碧野-1" class="headerlink" title="Δ萌え立つ　過越しの　碧野"></a>Δ萌え立つ　過越しの　碧野</h1><p>討厭的地方，就是這裡讓歐卡變成那樣子。<br>  　　凱特看著領域依然平和，一成不變的依照著設計者給予的程式驅動著。<br>  　　他不禁苦笑了起來，感觸真的很深。<br>  　　如果不曾來過這裡……就好了。<br>  　　上學的時候，也能夠如同往常一樣看到靖彥。</p><p>「啊？你是歐卡的朋友嗎？」ＰＣ名為波普，也就是在ＢＢＳ上留言的人走了過來。「對喔，所以你會知道這個地方。那歐卡呢？」<br>  　　「歐卡他……」凱特向波普說明著。<br>  　　「有這種事……難道說那個傳聞……」<br>  　　「傳聞？」凱特想起了歐卡看到奧拉時也說過這樣的話。「歐卡也說過呢……」但凱特並不清楚是什麼樣的傳聞。<br>  　　「是『The World』裡潛伏著不明究理的東西的事，沒聽說過嗎？」<br>  　　「歐卡在調查那個嗎？」<br>  　　「這我就不清楚了。不過琳達（リンダ）有糾纏著他問東問西的，若是她的話，也許比我知道的更多。我想她會在Δ埋もれし　異教の　熱砂裡。」<br>  　　「謝謝你，我去看看。」<br>  　　「對了，這個……」波普給了凱特『覺醒的秘傳書』。「歐卡他打算讓你使用這個的樣子。」<br>  　　「……」</p><p>凱特看著自己手裡拿著的東西，沒想到歐卡他為自己想到了這麼多。<br>  　　那麼，他也不會輸給他的。</p><h1 id="Δ埋もれし-異教の-熱砂"><a href="#Δ埋もれし-異教の-熱砂" class="headerlink" title="Δ埋もれし　異教の　熱砂"></a>Δ埋もれし　異教の　熱砂</h1><p>在走到了這個領域裡的迷宮的地下二層時，凱特遇到了一名女性ＰＣ。</p><p>「你是歐卡的朋友嗎？」對方的ＰＣ名是琳達，也就是凱特要找的人。<br>  　　「嗯。」<br>  　　「我從波普那裡聽說了，你是來問那個傳聞對吧？」琳達慢慢的述說。「『The World』不是單純的網路遊戲……有著別的目的的『什麼』在蠢蠢欲動中。」<br>  　　「有著別的目的『什麼』是……？」<br>  　　「這個嘛，結論就是這只是個傳聞。要說真的有什麼實在是……」琳達本身似乎是不太相信這個傳聞。「但是呢，歐卡和巴爾孟克則要找出那個『什麼』的真面目而行動著。」<br>  　　「歐卡和巴爾孟克……」<br>  　　「蒼天的巴爾孟克、蒼海的歐卡……這兩個人是持有『フィアナ的末裔』的這兩個名字的最強隊伍。但歐卡竟然……算了，壞事就別說了。那個傳聞你就忘記吧。」<br>  　　「……就算如此，要我放棄是辦不到的。」<br>  　　「……？」<br>  　　「我……因為我是歐卡的朋友。」<br>  　　「原來如此，這是你的理由……那麼你就去Δ孤立せる　沈默の　大蓋看看吧。歐卡在那裡看過奇怪的房間。願夕暮竜保護你。」</p><h1 id="Δ孤立せる-沈默の-大蓋"><a href="#Δ孤立せる-沈默の-大蓋" class="headerlink" title="Δ孤立せる　沈默の　大蓋"></a>Δ孤立せる　沈默の　大蓋</h1><p>凱特來到了這個領域迷宮的深處。<br>  　　如同琳達所說的，真的有個奇怪的房間。而且這個房間……和先前與黑玫瑰一起看到的房間一樣，純白的房間。唯有擺設是不同的，這裡只有一張搖椅，還有就是像是被刻意挖空的圓型空洞。</p><p>「這裡……房間消失了。」</p><p>凱特看著周遭，更是注意著那張搖椅。<br>  　　搖椅本身沒有什麼特別，而是椅子隨著地面被挖穿的形狀被削去了一隻腳，但卻還能站立著。</p><p>「就好像是某個人在這裡用某個東西無理的削去一樣。……待在這裡也沒有什麼辦法，回去城鎮吧。」</p><h1 id="遊戲系統介面-8"><a href="#遊戲系統介面-8" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>送信者：黑玫瑰<br>  　　　件名：找到線索了！</p><p>我和アルフ的朋友交涉成功了。<br>  　　我要和寫那篇留言的メグ在Θ大いなる　最果の　沃土見面，<br>  　　你也過來吧。</p><p>能夠獲得什麼就好了呢。</p><h1 id="Θ大いなる-最果の-沃土"><a href="#Θ大いなる-最果の-沃土" class="headerlink" title="Θ大いなる　最果の　沃土"></a>Θ大いなる　最果の　沃土</h1><p>「啊，有了有了。」黑玫瑰說。</p><p>凱特和黑玫瑰兩人到了這個領域的迷宮深處，找到了黑玫瑰所說的梅格（メグ）。<br>  　　但除了梅格外，還有著另一名男子。梅格正在和男子講話。</p><p>「是……」</p><p>梅格在如此回答男子後，男子就傳送離開了。<br>  　　在看到他們對話結束後，凱特和黑玫瑰便走到了她的身邊去。</p><p>「梅格小姐？アルフ所去的領域是哪裡呢？」黑玫瑰問。<br>  　　「……已經沒關係了。」梅格這麼回答黑玫瑰。<br>  　　「嘿？這什麼？到底是怎麼……」<br>  　　「雖然我剛才在ＢＢＳ上留了那個字詞，但好像很不好的樣子……對不起！」<br>  　　「啊、等……喂！」</p><p>梅格在道歉後，不等黑玫瑰說完就直接傳送離開了。</p><p>「走了啦……不過……你聽到了吧？」<br>  　　「嗯，ＢＢＳ！」</p><h1 id="遊戲系統介面-9"><a href="#遊戲系統介面-9" class="headerlink" title="遊戲系統介面"></a>遊戲系統介面</h1><p>但等到凱特登出去察看ＢＢＳ時，卻發現到該留言已經被刪除了。<br>  　　果然還是晚了一步。</p><p>此時，黑玫瑰來信了。</p><p>送信者：黑玫瑰<br>  　　　件名：真沒力</p><p>留言刪除了……<br>  　　這樣不就完全無法出手了嗎～～！<br>  　　搞什麼，真令人生氣！</p><p>  　　是很令人生氣沒錯啊，好不容易都到這地步了。<br>    　　只是……被刪除就是被刪除，他們也無能為力，就只能再找其他的方法。<br>    　　就當凱特失望的同時，多管閒事的人寄信來了。</p><p>送信者：黑爾芭<br>  　　　件名：親愛的凱特</p><p>「被刪除的留言是　↓　這個。<br>  　　────────────────────────────────────────────<br>  　　梅格<br>  　　Θ選ばれし　絕望の　虛無<br>  　　我看到一個女孩子被持有十字架的黑衣人物追著呢。<br>  　　而アルフ的家人的來信，說他在遊戲之中變成意識不明而住院了……<br>  　　────────────────────────────────────────────</p><p>Θ選ばれし　絕望の　虛無<br>  　　的資料容量擴張起來了。<br>  　　若是現在也許有些什麼哦。」</p><p>（持有十字架的黑衣人物……是那傢伙！是我和歐卡碰到的傢伙！……總算找到了！！）</p><p>此外，那個寫出亂碼的信的人也寄信來了。</p><p>送信者：ア＃＊　（奧拉）<br>  　　　件名：＊や＃　（快點）</p><p>もう、こ＊以上は＊げ＃れない。<br>  　　ス＊ィス＃つかまったら、私は<br>  　　今なら、ま＃間に合う。今＊ら、ま＊間に合<br>  　　う。今な＊、まだ間＊合う。今なら、＊だ間<br>  　　に合う。今＃ら、まだ＃に合う。今なら、ま<br>  　　だ間＊合う。今＊ら、まだ＊に合う。今なら<br>  　　、ま＊間に合う。今＃ら、＃だ＊に合う。</p><p>（已經不能再拖下去了。<br>  　　　被スケィス抓到的話，我……<br>  　　　現在還來得及、現在還來得及、現在還來得及、現在還來得及、現在還來得及、<br>  　　　現在還來得及、現在還來得及、現在還來得及、現在還來得及。）</p><h1 id="高山都市-ドゥナ．ロリヤック-3"><a href="#高山都市-ドゥナ．ロリヤック-3" class="headerlink" title="高山都市　ドゥナ．ロリヤック"></a>高山都市　ドゥナ．ロリヤック</h1><p>凱特在接獲消息後，馬上登入遊戲就準備要去黑爾芭所告知的領域了。</p><p>「打算暪著我去哪裡啊？」黑玫瑰來了。<br>  　　「那傢伙也許在。就是讓歐卡……讓靖彥變成那樣的傢伙。」<br>  　　「你要去打倒他嗎？」<br>  　　「要打倒還是什麼，我不知道……」<br>  　　「當然要打倒！我也去。」<br>  　　「……」凱特沈默了。老實說他並不想帶著黑玫瑰去，他害怕她和歐卡一樣。<br>  　　「不准你說不要。」黑玫瑰就像是看穿凱特的想法一樣，直接就否決了他的想法。</p><h1 id="Θ選ばれし-絕望の-虛無"><a href="#Θ選ばれし-絕望の-虛無" class="headerlink" title="Θ選ばれし　絕望の　虛無"></a>Θ選ばれし　絕望の　虛無</h1><p>凱特還是帶著黑玫瑰來了。</p><p>領域與先前曾去過的並無差異，但是凱特右腕那看不見體的腕輪卻微微的發著綠光。<br>  　　詭異的綠光。<br>  　　是警告，還是共鳴。</p><p>「腕輪……發光了……」</p><p>但不管什麼都好，起碼這個現象所表示的，就是黑爾芭信件上說的沒有錯。<br>  　　這裡有著『什麼』。</p><p>而迷宮的深處所等待的，也並非是讓凱特失望的結果。<br>  　　奧拉，就站在他的面前。</p><p>「奧拉……！？」<br>  　　「送到了吧……我的信。但是……沒來得及……」<br>  　　「等等！我有事情想要問妳……」</p><p>血紅的十字架佇立在奧拉的身後，宛如死神的黑色身影則伸出了他的手。<br>  　　奧拉像是領悟這樣的結果一般，沈靜的閉上雙眼，等候著死神揮下他的鎌刀。</p><p>「住手－－－！！」</p><p>凱特無力阻止一切，奧拉那『沒來得及』的預言就在他的面前發生。<br>  　　從歐卡身上曾看過的紅光自消失的奧拉身上釋出，一樣的消失天際。<br>  　　怎麼這樣，怎麼又這樣！<br>  　　凱特對眼前的對手充滿了敵意。</p><p>而對方似乎也不打算放過凱特，把十字架的矛頭對準了他。<br>  　　第一相，死之恐怖．スケィス。</p><p>凱特握緊了拳頭，下定決心拿起了他的雙劍。<br>  　　他不會像第一次一樣只會顫抖不知所措，現在的他要戰鬥。<br>  　　光是逃避什麼都沒有。<br>  　　不戰就無法繼續前進。<br>  　　就像黑玫瑰說的一樣，打倒他。</p><p>劍光交錯的瞬間，凱特也沒有忘記他右手的腕輪。<br>  　　現在回想起來，當初奧拉會把那本已化為腕輪的書交給歐卡，也許就是因為這東西可以打倒他。<br>  　　那麼，這場戰鬥必須依靠的不是一般程式所創造出來的武器。而且那規則外且無法捉摸的形體。</p><p>綠光閃動，腕輪的力量自凱特的右手湧現。<br>  　　他舉起了右手，對準著眼前這奪走他人一切的惡魔。<br>  　　那就讓對方嘗嘗被奪走的滋味。<br>  　　DataDrain！</p><p>スケィス的構成資料被凱特的腕輪吸取，原本覆蓋在身上石狀鎧甲應聲而裂，毫無防備的他被凱特的雙劍刺入核心。<br>  　　資料破損就只有毀滅一途，スケィス就像液體一樣溶化並且攤散在地面。</p><p>結束了嗎？凱特想。<br>  　　但是事情並不如他所想的那麼容易。</p><p>スケィス所溶成的液體開始產生像是沸騰一樣的泡泡，就好像有熱源從地底竄出，讓液體發出『啵、啵』的聲音。<br>  　　隨即而來的是震動，震動，再震動。<br>  　　因為擊敗スケィス而化為無的空間從地面開始迸裂，冒出像是樹木枝枒的東西。那宛如來自地獄叫喚的手一樣，頻頻的往天空伸展。直到震動停止的同時，凱特發現到那來自天空的陰影，他抬頭張望產生陰影的來源。<br>  　　詫異。<br>  　　除此之外，他無從產生任何的情感。<br>  　　或者是說，沒有空間和時間讓他能有任何的感覺。<br>  　　那是什麼？</p><p>紫藍色的詭異枝枒所構成的形體在天空中張牙舞爪，而在那枝枒之上的則是一個骷髏。<br>  　　骷髏就趁著凱特訝異之時，發動了攻擊。<br>  　　他不過只吹了一口氣，凱特便被擊飛至數尺遠。</p><p>此時，黑爾芭出現了。<br>  　　漂浮在空中的她馬上就操縱著法杖發動魔法，保護倒在地上無力反擊的凱特。<br>  　　這個人不能死。<br>  　　她輕輕一揮，凱特便被傳送出這個非規則之內的領域。<br>  　　<br>  　　「クビア……」</p><p>黑爾芭看著那空中的怪物喃喃自語後，不打算戀戰便隨即離開了。</p><p>  　　『我們什麼都不知道，而且這個……我們的戰爭，這才是真正的開始。』</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PS2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PSV|SD2Vita&amp;VitaTools</title>
    <link href="/2023/12/26/PSV-SD2Vita-VitaTools/"/>
    <url>/2023/12/26/PSV-SD2Vita-VitaTools/</url>
    
    <content type="html"><![CDATA[<h1 id="SD2Vita卡套制作"><a href="#SD2Vita卡套制作" class="headerlink" title="SD2Vita卡套制作"></a>SD2Vita卡套制作</h1><h2 id="材料准备-amp-介绍"><a href="#材料准备-amp-介绍" class="headerlink" title="材料准备&amp;介绍"></a>材料准备&amp;介绍</h2><p>目前普遍的实现方案是用卡套+TF卡来实现游戏的海量存储，原装记忆棒有点贵的</p><p>我用的是TB上买的十来块一个的白色卡套（大部分都是这个吧），实际上就是 TF 转 PSV游戏卡 的马甲卡套</p><h2 id="格式化卡套"><a href="#格式化卡套" class="headerlink" title="格式化卡套"></a>格式化卡套</h2><ol><li>将带有 TF 卡的 卡套 插入机器中</li><li>启动 VitaDeploy 应用程序</li><li>选择 <code>Miscellaneous</code></li><li>选择 <code> Format a storage device</code></li><li>确认一下选中的是 <code>SD2Vita</code> 并设置为 <code>TexFAT</code> 这个文件系统</li><li>选择 <code>Format target storage</code></li><li>退回上级 Vita Deploy 菜单，然后选择 <code>Reboot your device</code></li></ol><h2 id="安装卡套插件YAMT"><a href="#安装卡套插件YAMT" class="headerlink" title="安装卡套插件YAMT"></a>安装卡套插件YAMT</h2><p>YAMT（Yet Another Mount Tool）是PS Vita的多用途内核插件，允许通过SD2Vita适配器将microSD卡用作存储设备。SD2Vita 是一款 microSD 到游戏卡适配器，可插入设备的游戏卡插槽中。</p><p>通过使用 YAMT 内核插件，您使用的 USB 驱动器或 microSD 卡将像索尼存储卡一样安装</p><p>想要让卡套正常运行，就需要安装 YAMT 插件</p><ol><li>打开 VitaDeploy</li><li>按 App Downloader</li><li>选择 YAMT Installer</li><li>选择顶部的 <code>Download the selected apps</code></li><li>再次确认以安装 <code>YAMT.vpk</code></li><li>完成后 关闭 VitaDeploy 应用程序</li><li>启动桌面上新安装的 YAMT </li><li>选择 <code>Install the lite version</code></li><li>完成后，等设备重新启动</li></ol><h2 id="配置YAMT"><a href="#配置YAMT" class="headerlink" title="配置YAMT"></a>配置YAMT</h2><ol><li>进入系统设置</li><li>导航到 <code>设备</code> -&gt; <code>存储设备</code></li><li>启用 <code>Use YAMT</code> 以启用 YAMT 驱动程序</li><li>设置 <code>ux0:</code> 为 <code>默认</code></li><li>设置<code>uma0:</code> 为 <code>SD2Vita</code></li><li>按住电源按钮并完全关机</li></ol><h2 id="复制文件到卡套"><a href="#复制文件到卡套" class="headerlink" title="复制文件到卡套"></a>复制文件到卡套</h2><p>这部分主要是把机身内置存储的一些文件同步到卡套+TF卡里，以实现无缝的切换</p><ol><li>PSV，启动！</li><li>打开 VitaShell 应用程序</li><li>导航到分区ux0，由于我们之前的配置，这里目前指的是机身内部存储</li><li>按下方向键以突出显示文件夹或文件，按下△调出菜单</li><li>选中 <code>Mark all</code> 选择分区中的所有文件夹和文件</li><li>再按一次△调出菜单</li><li>选择<code>Copy</code></li><li>出现提示时再按一次确认</li><li>退出分区ux0进入分区uma0，由于我们之前的配置，这里是非官方存储设备（卡套+TF）的存储分区</li><li>按下△调出菜单</li><li>选择 <code>Paste</code> 并等待完成</li><li>完成后，退出 VitaShell 并打开系统设置</li><li>导航到 <code>设备</code> -&gt; <code>存储设备</code></li><li>设置 <code>ux0:</code> 为 <code>SD2Vita</code></li><li>设置<code>uma0:</code> 为 <code>内置存储</code></li><li>重启设备，大功告成</li></ol><h1 id="游戏安装"><a href="#游戏安装" class="headerlink" title="游戏安装"></a>游戏安装</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>现在市面上流行的 Dump 出来的文件格式一般是两种：</p><ul><li>NONPDRM</li><li>MAI</li><li>vpk</li></ul><h2 id="安装工具箱-amp-必要插件-amp-MaiDumpTool"><a href="#安装工具箱-amp-必要插件-amp-MaiDumpTool" class="headerlink" title="安装工具箱 &amp; 必要插件 &amp; MaiDumpTool"></a>安装工具箱 &amp; 必要插件 &amp; MaiDumpTool</h2><h3 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h3><p>很好用的一个工具箱，具体下载这里不做记录</p><p>下载好工具箱的 vpk 文件后，彻底关机 psv 后取出 TF 卡，之后插入读卡器连接电脑</p><p>把工具箱的 vpk 丢到根目录</p><p>把 TF 卡插回 PSV 后进入 VitaShell 安装 vpk</p><h3 id="必要插件"><a href="#必要插件" class="headerlink" title="必要插件"></a>必要插件</h3><p>想要运行未签名授权的游戏，需要三个插件，这三个在工具箱里都有</p><p>在工具箱的 安装常用插件 里的 NONPDRM、repatch、reF00D 三个插件</p><h3 id="MaiDumpTool"><a href="#MaiDumpTool" class="headerlink" title="MaiDumpTool"></a>MaiDumpTool</h3><p>MAIDumpTool 是针对 Mai 格式的文件的安装工具</p><p><a href="https://github.com/BeniYukiMai/MaiDumpTool">BeniYukiMai&#x2F;MaiDumpTool</a></p><p>下载完了 vpk 之后也是先进 VitaShell 进行安装</p><h2 id="NONPDRM"><a href="#NONPDRM" class="headerlink" title="NONPDRM"></a>NONPDRM</h2><p>这类格式一般命名都是游戏的编号ID</p><p>文件直接放在 SD:&#x2F;app 目录下</p><p>但是我这里用读卡器读取 SD2Vita 的 TF 卡里是访问不到 app 文件夹的，目录也没有被隐藏</p><p>所以推荐的方式是：<strong>把整个目录丢到根目录下，然后之后通过 VitaShell 移动到 app 下</strong> （由于是同一张卡之间的移动，因此数据传输还是很快的，反正是比 FTP 或者是 USB 从电脑直接传到 psv 来得快的多）</p><p>之后还需要在 VitaShell 中将光标移动到 ux0 的顶部第一个或者第二个文件夹，按下 Δ 呼出菜单，分别选择更新 licence 以及 刷新 livearea</p><p>之后退出就可以在主页看到对应游戏的气泡</p><h2 id="MAI"><a href="#MAI" class="headerlink" title="MAI"></a>MAI</h2><p>Mai 格式的游戏，同样也需要顶层文件夹命名为游戏的编号</p><p>之后放入 SD:&#x2F;mai （这里我没有，新建了一个）</p><p>之后在机器内进入 MaiDumpTool 选择第二项，看提示信息安装即可</p><h2 id="VPK"><a href="#VPK" class="headerlink" title="VPK"></a>VPK</h2><p>这种其实就不用说了，一般自制程序都是 VPK 格式，少数游戏也是</p><p>还有的是移植游戏， VPK 仅仅只是一个程序启动器，具体请参见<a href="#%E7%A7%BB%E6%A4%8D%E6%B8%B8%E6%88%8F">运行移植的游戏</a></p><h1 id="移植游戏"><a href="#移植游戏" class="headerlink" title="移植游戏"></a>移植游戏</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>PSV 最出彩的或者说最吸引我的，除了天国的 SCEJ 为 PSV 量身定制的很有意思的独占游戏外，就是 PSV 逆天的玩家生态和玩家自己移植的游戏了</p><p>一般来说都会有安装文档，按照玩家官方提供的都没什么问题</p><p>因此这里只是简单记录一下通用的部分</p><h2 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h2><p>针对移植游戏，必备的插件如下：</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PSV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PSV|Ensō CFW 降级固化</title>
    <link href="/2023/12/26/PSV-Enso-CFW-%E9%99%8D%E7%BA%A7%E5%9B%BA%E5%8C%96/"/>
    <url>/2023/12/26/PSV-Enso-CFW-%E9%99%8D%E7%BA%A7%E5%9B%BA%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>基于 <code>vita.hacks.guide</code> 编写，由于折腾的机器太多怕以后忘记，写下作为折腾记录</p><p>在 PSV 领域内， 目前最好的 CFW 解决方案是 Ensō </p><p>Ensō 允许通过在启动时运行漏洞来设置自制环境，从而方便地在您的设备上访问自制软件</p><p>相比其他 CFW 解决方案（如 HENkaku 或 h-encore）更方便，因为它不需要您在每次手动重启后在设备上触发漏洞利用</p><p>Ensō 适用于固件版本为 3.65 或以下的所有设备，而更高固件版本的设备可以降级到 3.65 以达到相同的结果</p><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>我是海淘买入的，日本卖家原先之前都是正版游玩，因此是最新的系统3.74</p><p>为了折腾能够顺利进行，需要插上电并且接入网络（不需要接入 psn 只要接入国际互联网即可）</p><h1 id="正式折腾"><a href="#正式折腾" class="headerlink" title="正式折腾"></a>正式折腾</h1><h2 id="启动-HENIo"><a href="#启动-HENIo" class="headerlink" title="启动 HENIo"></a>启动 HENIo</h2><p>通过 psv 打开浏览器，输入链接 <code>http://jailbreak.psp2.dev</code></p><p>之后点击中间的 <code>Unlock my Vita</code></p><p>然后点击右下角的 <code>Unlock</code></p><p>之后就会触发漏洞，等他自动跳转</p><p>应该会看到一个标题为 <code>henlo-bootstrap</code> 的界面</p><h2 id="安装-Henkaku-和-VitaDeploy"><a href="#安装-Henkaku-和-VitaDeploy" class="headerlink" title="安装 Henkaku 和 VitaDeploy"></a>安装 Henkaku 和 VitaDeploy</h2><ol><li>按<code>install henkaku</code>启用自制软件</li><li>按 <code>install VitaDeploy</code></li><li>按 <code>exit</code></li></ol><h2 id="配置-HENkaku"><a href="#配置-HENkaku" class="headerlink" title="配置 HENkaku"></a>配置 HENkaku</h2><p>上一步做完会退回到主界面，这时进入系统设置</p><ol><li>导航到 <code>HENkaku Settings</code></li><li>勾选 <code>启用不安全的自制软件</code></li><li>关闭“设置”应用程序</li></ol><h2 id="固化安装-Enso"><a href="#固化安装-Enso" class="headerlink" title="固化安装 Ensō"></a>固化安装 Ensō</h2><p>这一步主要是安装固化，同时降级到3.65</p><p>在之前我们已经安装了 <code>VitaDeploy</code> 在主界面找到他并进入</p><ol><li>点击 <code>Install a different OS</code><ul><li>如果没有看到带有此选项的绿色菜单，请确保您已在 HENkaku 设置中启用不安全的自制程序</li></ul></li><li>点击 <code>Quick 3.65 Install</code><ul><li>注意：此过程必须连接到互联网才能使用，同时在此过程中不要让 Vita 进入睡眠模式</li></ul></li><li>等待组件下载</li><li>下载完按X确认</li><li>阅读屏幕上显示的警告并等待 20 秒</li><li>再按一次确认进行固化</li></ol><p>之后系统会自动安装3.65的固件，完成之后会重新启动，至此已经大致结束了</p><h1 id="最后的设置"><a href="#最后的设置" class="headerlink" title="最后的设置"></a>最后的设置</h1><h2 id="安装自制程序签名"><a href="#安装自制程序签名" class="headerlink" title="安装自制程序签名"></a>安装自制程序签名</h2><p>这部分主要是为了保证能让</p><ol><li>启动 VitaDeploy 应用程序</li><li>点击 <code>应用程序下载器</code></li><li>选择以下应用程序：<ul><li>iTLS 安装程序</li></ul></li><li>点击菜单顶部的 &#96;&#96;</li><li>等待应用程序完成下载和安装，完成后退出</li><li>打开桌面上安装好的 iTLS-Enso 应用程序</li><li>选择 </li><li>等待设备重启</li></ol><h2 id="禁用更新-amp-PSN设置"><a href="#禁用更新-amp-PSN设置" class="headerlink" title="禁用更新&amp;PSN设置"></a>禁用更新&amp;PSN设置</h2><p>禁用系统的自动更新</p><ol><li>启动系统设置</li><li>导航到 <code>System</code> -&gt; <code>Auto-Start Settings</code></li><li>取消选中 <code>Download Update File for System Software</code></li><li>关闭系统设置</li></ol><p>修改接入PSN的伪装版本</p><ol><li>启动系统设置</li><li>导航到 <code>HENkaku Settings</code></li><li>勾选 <code>启用PSN伪装</code></li><li>勾选 <code>启用版本伪装</code></li><li>导航到 <code>伪装版本</code></li><li>在框中输入 <code>3.74</code>（如果将来发布新的固件版本，需要找到这里更改对应的伪装版本才能访问PSN）</li></ol><p>至此系统层面的折腾就结束了，下一篇文章会介绍如何安装常见的工具、用TF卡转PSV卡套实现存储扩容以及游戏安装</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PSV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Graphics|Blender</title>
    <link href="/2023/10/18/Computer-Graphics-Blender/"/>
    <url>/2023/10/18/Computer-Graphics-Blender/</url>
    
    <content type="html"><![CDATA[<h1 id="Blender-Fundamentals"><a href="#Blender-Fundamentals" class="headerlink" title="Blender Fundamentals"></a>Blender Fundamentals</h1><p>这部分主要简单介绍 Blender 这个软件的基本概念</p><p>这个软件主要是用于 3D 动画以及 3D 建模的，经常用于影视行业和游戏</p><p>它还可以进行视频编辑、合成、绘画、雕刻、视觉效果、模拟（流体、烟雾、粒子和布料）、3D 打印、2D 动画和实时渲染</p><h2 id="基本制作流程"><a href="#基本制作流程" class="headerlink" title="基本制作流程"></a>基本制作流程</h2><p>首先我们需要明确一个概念性的东西，就是一个动画或者是视觉效果图，在 blender 中需要进行以下几个阶段</p><ul><li>3D建模阶段</li><li>动画阶段</li><li>材质阶段</li><li>渲染阶段</li></ul><h2 id="建模常用操作"><a href="#建模常用操作" class="headerlink" title="建模常用操作"></a>建模常用操作</h2><p>shift + A 新建物体</p><p>注意在我们新建物体之后左下角有一个物体的详细属性设置，如果需要调整的话需要在这个时候调整，不然后期需要修改的话，就只能重新新建了</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231112110101689.png" alt="image-20231112110101689"></p><h2 id="视角相关"><a href="#视角相关" class="headerlink" title="视角相关"></a>视角相关</h2><p>滚动滚轮 &#x3D; 缩放视角</p><p>按住滚轮拖动 &#x3D; 旋转视角</p><p>shift + 滚轮拖动 &#x3D; 平移视角</p><p>alt + 滚轮拖动 &#x3D; 快速切换各个正交视图</p><p>(用这个快捷键组合的话，每切换一次，需要按住放开鼠标中键一次，即<strong>按住alt — 按住中键拖动 — 放开中键，完成一次切换</strong>，要再切换的话，需要重复上述操作，觉得麻烦的话，可以用下面的<code>~</code>按键替代)</p><p>~ &#x3D; 呼出快速切换视角菜单</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231112110703080.png" alt="快速呼出视角切换的菜单"></p><h2 id="物体相关"><a href="#物体相关" class="headerlink" title="物体相关"></a>物体相关</h2><p>blender 界「三大操作」</p><ul><li>Rotate 绕轴旋转 + XYZ + 度数</li><li>Scale 沿轴放缩 + XYZ + 度数</li><li>G(Translate) 沿轴平移 + XYZ + 度数</li></ul><p>（上述的三个操作中如果不指明具体的XYZ，默认是XYZ三个方向都进行变换）</p><p>全选所有物体 &#x3D; A</p><p>删除选中物体 &#x3D; X</p><p><font color='red'>Shift + D(Dulplicate) + XYZ &#x3D; 沿轴快速复制选中物体</font></p><h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><p>创建新文本就是在 Shift + A 中</p><p>想要编辑文本就是选中，然后进入编辑模式（可以直接按 TAB 切换，再次按下就是返回上一次的模式）</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231112112548884.png" alt="输入文本就能进行编辑"></p><p>此外在文本属性这块可以进行各种变换</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231112112822735.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231112113029252.png"></p><h2 id="属性编辑器"><a href="#属性编辑器" class="headerlink" title="属性编辑器"></a>属性编辑器</h2><p>在 blender 界面中右下角的这一块面板其实就是最重要的属性编辑器，里面都是建模建出来的重要属性需要设置</p><p>这里重点说一下常用的属性</p><h3 id="物体属性"><a href="#物体属性" class="headerlink" title="物体属性"></a>物体属性</h3><p>这个黄色框框的就是物体属性</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/v2-c8e109a2d7b43b832d13ac89dd2d6818_720w.webp"></p><p>可以利用关键帧 + 设置物体位置 的方式来制作最简单的动画</p><h3 id="物体数据"><a href="#物体数据" class="headerlink" title="物体数据"></a>物体数据</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231114155013756.png"></p><p>这个时候通过「物体数据属性」中的设置可以更加光滑</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231114155120885.png"></p><h3 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h3><p>修改器玩法很多，大部分都是基于不改变物体原始形状的前提来产生效果</p><ul><li><strong>阵列修改器</strong></li></ul><p>可以依据某个物体，按某个特定偏移距离批量创建物体副本。</p><p>例如，你可以叠加两个阵列修改器来生成矩阵：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231114155253006.png"></p><ul><li><strong>倒角修改器</strong></li></ul><p>可以给物体生成圆润的边缘：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231114160140669.png"></p><ul><li><strong>线框修改器</strong></li></ul><p>可以让物体变成线框：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231114160209823.png"></p><h2 id="时间轴相关"><a href="#时间轴相关" class="headerlink" title="时间轴相关"></a>时间轴相关</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231114160240222.png" alt="时间轴基本组成"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231114160403484.png" alt="如何插入关键帧"></p><p><strong>同时，可以根据自己的需要选择插入关键帧还是单项关键帧</strong></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231114160438356.png" alt="关键帧和单项关键帧的区别"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231025230340318.png"></p><p>最下方的 bar 显示了当前的一些操作，可以组合 shift 和 alt 进行更高级的功能</p><p> <img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231025231124256.png"></p><p>右上角的面板可以自由更换和选择</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231025231335145.png"></p><p>在边缘可以选择分割当前的工作区</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231025231458325.png"></p><p>还可以通过连接面板来删除面板，左键单击连接，然后再次单击要删除的面板</p><p>左键单击面板边缘并拖动可以调整其大小</p><p>还可以通过向上或向左拖动面板的右下角来创建新面板，以分割面板。 </p><p>Ctrl + &lt;space&gt; 最大化面板，再次按 Ctrl + &lt;space&gt; 可返回正常面板视图</p><h1 id="Moving-and-orientating"><a href="#Moving-and-orientating" class="headerlink" title="Moving and orientating"></a>Moving and orientating</h1><p>按下 t 和 n 可以分别呼出左右两侧的设置工具栏</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231026221114239.png" alt="image-20231026221114239"></p><p>Shift A - 允许您在光标位置添加对象</p><p>Shift S - 呼出 pie menu</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231026221904016.png" alt="Shift S呼出menu虽然看不懂"></p><p>Z - 选择渲染着色的方式</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231026221838798.png" alt="呼出Z"></p><p>以上呼出的菜单都可以通过右键单击进行取消</p><h1 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h1><p>我们这边以一个最简单的小球为研究对象，探讨基于关键帧生成来制作一个简单的动画</p><h2 id="关键帧插入"><a href="#关键帧插入" class="headerlink" title="关键帧插入"></a>关键帧插入</h2><p>通过选中物体，之后可以先通过 N 设置物体的属性，此时就默认我们是在第 1 帧的情况下所设置的属性，比如这里我们更改坐标来实现球的运动效果</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231027100840908.png" alt="在某一帧修改物体的属性"></p><p>设置完毕属性之后我们按下 I 进行关键帧的插入，这里会有依据很多种属性的方式来进行插入，这里我们选择基于 location 的方式</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231027162049459.png" alt="关键帧的插入"></p><p>我们可以在下方的帧数控制中输入10或者手动定位到10，这就表示我们定位到了第10帧的位置上</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231027162152159.png" alt="定位位置"></p><p>在第10帧的位置上我们修改了小球的Z轴位置后，就可以继续设置关键帧，还是按下I(insert)来在当前位置（第10帧）插入关键帧</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231027184037840.png" alt="拖动位置"></p><p>通过重复上述的操作，我们就可以制作出多帧的场景，blender会自动帮我们连接和生成这几个关键帧之间的动画部分</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231104203406039.png" alt="几个关键帧连成的动画"></p><h2 id="给物体着色"><a href="#给物体着色" class="headerlink" title="给物体着色"></a>给物体着色</h2><p>这部分主要是修改物体的 base color 属性来实现物体的着色</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231104203707335.png" alt="物体着色"></p><h2 id="生成动画"><a href="#生成动画" class="headerlink" title="生成动画"></a>生成动画</h2><p>制作完毕我们就可以直接生成动画了</p><p>但是默认的质量大小很大，需要压缩一下画质</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231104203747996.png" alt="压缩画质"></p><h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><h2 id="Move-Basic"><a href="#Move-Basic" class="headerlink" title="Move Basic"></a>Move Basic</h2><p>想要实现模型的移动我们需要向模型追加骨骼选项</p><p>骨骼在实际渲染时不可见，但可以使网格变形（或移动模型）</p><p>一组骨骼可以组合在一起形成骨架</p><p>将骨架添加到模型并计算出如何使模型变形的过程称为绑定(rigging)</p><p>您可以通过手动移动骨架来设置位置 之后通过在 blender 中填充关键帧之间的间隙来控制骨架，这种方法其实就是创作出了动画</p><p>另一种方法是使用运动捕捉系统记录的数据来控制骨架，这称为动作捕捉</p><p>这里，我们将学习绑定和动作捕捉的基础知识</p><h2 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1:"></a>Demo1:</h2><p>主题：Rigging a cylinder with bones and a controller</p><p>这里我们用 骨骼 和 控制器 装配圆柱体</p><p>通过add方式选择追加 amature 来创建骨骼</p><p>之后我们通过平移以及旋转的方式嵌入实体中</p><p>在实体内部排好所有的骨骼后，一个关键的操作是先 shift + 左 选中实体，然后 shift + 左 选中所有的骨骼，之后 ctrl + P 选择</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231111211327841.png" alt="合体操作"></p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PS2|Star Ocean - Till The End Of Time</title>
    <link href="/2023/10/08/PS2-Star-Ocean-Till-The-End-Of-Time/"/>
    <url>/2023/10/08/PS2-Star-Ocean-Till-The-End-Of-Time/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面的简介"><a href="#写在前面的简介" class="headerlink" title="写在前面的简介"></a>写在前面的简介</h1><p>本篇文章仅供自用</p><p>由于SO3无论是无印还是DC一直没有汉化，因此在巴哈姆特找到完整的剧情小说自用</p><h1 id="海達IV-ハイダⅣ"><a href="#海達IV-ハイダⅣ" class="headerlink" title="海達IV (ハイダⅣ)"></a>海達IV (ハイダⅣ)</h1><p>（葛蘭帝爾度假飯店）<br>Fayt找了個位置坐下來。<br>Fayt：唉～<br>Sophia 拿了一些飲料出現。<br>Fayt：哇！<br>Sophia：嗯，那去。(Sophia給Fayt 一罐飲料)<br>Fayt：啊，嗨！Sophia？妳嚇了我一跳。我以前妳還在海邊游泳呢。<br>Sophia：我是在等你啊，但你一直沒來，你說你要先去玩幾場遊戲才來的。<br>Fayt：呃？抱歉！我沒打算玩那麼久的，我有點玩上隱了。<br>Sophia：好吧！我也猜想如此。你來海達前不是說你還有很多功課要做嗎？<br>Fayt：(站起身)但我今天打的超順的！然後你知道嗎？我還升級許多呢。<br>Sophia：是，是。真好啊！<br>Fayt：嗯？今天是不是有人心情不好啊？<br>Sophia：你想呢？你寧可去玩遊戲也不肯陪我去海邊！<br>Fayt：Sophia？<br>Sophia：哼！<br>Fayt：你沒在生氣吧？<br>Sophia：我才沒生氣！<br>Fayt：你想去海邊嗎？<br>Sophia：我游夠了。當某個我認識的人將他的時光花在遊戲上的時候。<br>Fayt：然後呢？要不要在飯店裡逛逛？我猜這一定很有趣，你怎麼說？來嘛！拜託啦！我求妳啦～<br>Sophia：嗯，好吧。看你這麼渴望我陪你，我想可以吧！<br>Fayt：太好了，咱們走吧，不要浪費時間。<br>Sophia：Ok!<br>過了一會兒，Fayt不耐煩的在Sophia房間外等著。<br>Fayt心想：她還真慢啊！我猜她一定是故意要我等的。<br>Sophia由房間出來，換了一件藍色牛仔褲及粉紅色無袖上衣。<br>Sophia：嗨，Fayt！<br>Fayt：花了真久時間啊！這些時間妳都在幹嘛？<br>Sophia：只是換件衣服。我沒花那麼久的時間吧？加上你也讓我等啊，這是你應該的。<br>Fayt：是，是！<br>Sophia：(牽起Fayt的手)走吧？<br>Fayt：好，只要別拉斷我的手。<br>Fayt及Sophia去散步。他們走進了馬戲團的休閒室。</p><p>活潑少女：哇～你們是誰？這是羅希帝斯的更衣室啊！嗯？啊！我知道了，你想要我的簽名是吧？唉，該讓我的影迷開心一下。平常的話，若是有人像這樣闖進來我會非常生氣，但是你又長的帥，我就當這次是例外。<br>Fayt：啊？嗯？你說羅希帝斯？<br>活潑少女：什麼？你沒聽過我們馬戲團的名字？現在你不能不知道了。嘿，你叫什麼名字？<br>Fayt：Fayt，但是… …<br>Sophia：我叫Sophia。<br>活潑少女：我知道了。<br>活動少女跑到Fayt的身後，拿出一支黑筆在Fayt衣服後面寫字。<br>活潑少女：給我最親愛的。幻影精靈，琶琵塔羅希帝斯。完成！<br>活潑少女寫完後，Sophia看著Fayt衣服後面。<br>Sophia：(訝異)這什麼？<br>Fayt：啊！嘿，妳不能就這樣隨便寫在別人衣服上啊。<br>活潑少女：啊？什麼？我以為你要我的簽名。<br>Sophia：沒有人說過任何想要簽名的話啊。<br>活潑少女：啊！但是，你確定嗎？但是我以為… …那你是要我媽媽的簽名？還是我爸的，你不可能是來要高內納小丑的，或是俄什斯大力士的，對吧？<br>Fayt：不，我們不是來要任何人的簽名。<br>活潑少女：啊？那你是來推銷的囉？不對，現在想起來，你看起來就像是那種一生中從沒做過很實在的事。我知道了，你是來討債的吧！你們來太早了，那筆債是到下個月，他們說好的。<br>Fayt：不，不是啦！不過誰是羅希斯帝？什麼是什麼幻影精靈？<br>活潑少女：嗯嗯～所以，你們兩個只是迷路了？<br>Fayt：我們不算是迷路。<br>活潑少女：啊！不會吧，你們是強盜。<br>Fayt：不，我們也不是。<br>活潑少女：那你們是什麼？你們不是我的影迷，你們不是來討債的，你們也不是迷路，那你們闖進別人的房間做什麼？<br>Fayt：嗯，抱歉，我們闖進你的房間。我們只是散個步，逛一下這個地方，對不對Sophia？<br>Sophia：嗯。<br>活潑少女：散步？<br>Fayt：對，只是散步。<br>活潑少女：闖進別人的房間不叫做散步！那是強盜、迷路的小孩、跟蹤狂或是樂團迷的行為。<br>Fayt：嗯，好啦。我們… …迷路了。<br>Sophia：走吧，我們離開這裡吧，Fayt。<br>Fayt：好主意。<br>活潑少女：所以你們的確是迷路了，這解釋了一切。我還以為你們是我第一個影迷。無所謂，我還想奇怪，我都還沒開始表演。<br>Fayt：你是個表演者？<br>活潑少女：沒錯！我們是羅希帝斯馬戲團，我們帶給你快速的未來影像。我是你的導遊精靈，琶琵塔羅希帝斯。(日文原名Souffle)<br>Peppita：如果你們要簡單的解釋，我們是個馬戲團，而我的工作類似主持人。<br>Fayt：喔？所以這件有妳簽名的襯衫，不久後也許會值不少錢唷。<br>Peppita：那當然！這可是我第一個簽名。<br>Fayt：第一個？<br>Peppita：明天是我的發表會。六個月內，你可以用你這件襯衫買下一整個星球呢。<br>Fayt：哦，是嗎？真令人吃驚，一整個星球。我應該要好好保存這件襯衫。<br>Peppita：嘿！你不相信我？<br>Fayt：不，我相信你。我敢保證妳將是舞台上的新巨星。<br>Peppita：嘻嘻，謝啦。我現在心情好多了，我給你一個禮物，就當做是我送給我第一個影迷吧。(Peppita 給Fayt一張門票)<br>Fayt：啊？門票？<br>Peppita：是啊，我們的秀是在明天。你可別忘了！當你看完我們的表演，你就會想要寶貝那件襯衫一輩子。<br>Fayt：謝啦。我很期待你們的表演。<br>Peppita：太棒了！明天見了，Fayt。<br>Fayt及Sophia離開，他們來到遊樂室。</p><p>Fayt心想：我剛想起，這家飯店有進新款的模擬戰鬥遊戲平台，我們現在有些時間，或許我該說服Sophia陪我玩一兩場遊戲。<br>Fayt及Sophia來到VR遊戲室的入口。<br>Sophia：又是遊戲？你不是剛才才玩嗎？一直玩遊戲的話小心你會變成頭腦簡單四肢發達的人。<br>Fayt心想：嗯，怎麼辦？試著說服Sophia嗎？<br>Fayt：Sophia妳要不要也試玩看看，很好玩的。<br>Sophia：但這不是那種模擬戰鬥遊戲？不是要打架的嗎？不要，我不喜歡這種遊戲。<br>Fayt：別擔心，我會保護妳的。<br>Sophia：但是？<br>Fayt：我不會讓妳做任何危險的事情，我向妳保證。來嘛，試試看。<br>Sophia：這個嘛，好吧。如果你都這麼說了，我想我就試試看。<br>Fayt：就這樣決定了。既然妳是個初學者，那我們從最簡單的等級開始吧！妳應該寧可選擇遠距離使用徽章術的角色也不要選擇那種在前線打鬥的角色吧。<br>Sophia：是啊？這不會痛吧？<br>Fayt：別擔心，初學者等級根本不會痛，真的。<br>Sophia：好吧，我試試看。<br>Fayt啟動入口旁的設備。<br>Fayt：我們準備好了。<br>走進了VR遊戲中心。<br>電腦：歡迎來到模擬戰鬥系統，請設定您的戰鬥數值(等級)。<br>Fayt：Sophia妳想怎麼辦？我們從最基本的開始，妳想看看說明嗎？<br>Sophia：我不知道？我應該看看嗎？<br>Fayt：也許吧，不然就不好玩了。<br>Sophia：好吧。<br>當Sophia 讀完說明。<br>Fayt：開始玩吧，電腦開始。<br>電腦：玩家一，Fayt Leingod；角色，劍術高手，阿多尼斯卡蘭；玩家等級，AAA。玩家二，Sophia Esteed；角色，火燄女巫，賽西里亞法米納；玩家等級，E。戰鬥場，荒野之城里西提亞。妖怪等級，E。設定完成。繼續？<br>Fayt：嗯，我們準備好了。<br>電腦：準備啟動。若是遊戲發現玩家出現危險，模擬戰爭遊戲將中止。<br>Fayt：我已經知道了，開始吧！<br>電腦：確認。遊戲開始！<br>Fayt及Sophia打贏了這一場。之後… …</p><p>Sophia：唉，累死了。<br>Fayt：但很好玩對吧？<br>Sophia：嗯，是不錯啦。<br>Fayt：(跳過第二場)要不要停下來，出去吃點東西？妳看起來有點累。<br>Sophia：好啊，我真的很累。<br>Fayt：哈哈，你需要多一點運動。<br>Sophia：哼，我就是太胖了。<br>Fayt：沒有人那樣說。我們出去找我爸媽吧。<br>Sophia：好。<br>沒過多久，可以感覺到手把的振動。<br>Fayt：什麼？<br>電腦：發現二級震動，為了您的安全系統暫時關閉。為您帶來不便，敬請見諒。<br>Fayt：地震嗎？(心想：但是海達IV是個穩定沒有任何的活動地殼構造的世界，這應該不是地震。)<br>忽然又有震動。<br>Sophia：啊～<br>Fayt：哇～<br>電腦：這是緊急警報。海達IV目前正遭到不名飛船的攻擊。請所有人立即聽從最鄰近的電腦設備中的疏散說明。再度說明，請所有人立即… …<br>Fayt：電腦！發生什麼事情了？<br>電腦：第七操縱星站、海達III及海達IV目前正受到不名飛船的攻擊。第七操縱星站已派出戰艦回擊，然而敵方數量龐大，無法立即給予海達IV支助。<br>Fayt：不知名飛船的攻擊？<br>電腦：請等待影像顯示。<br>看到一艘紅色戰艦於空中，有些建築物受到攻擊毀滅。<br>Fayt：難以相信？<br>電腦：因緊急考量，所有傳輸系統將直接連接疏散站。請立即跟隨標誌疏散。再重複一遍，請立即… …<br>Sophia：(害怕) Fayt？<br>Fayt：別怕，Sophia。我會一直在妳身邊。<br>Sophia：謝…謝謝。<br>Fayt：(心想：但誰會攻擊呢？我從沒見過那型式的飛船。不知道爸媽還好吧。我應該先關心眼前的事，我們應該先逃離這裡。)(轉向Sophia)我們走吧！<br>Sophia：嗯。<br>Fayt及Sophia離開，出了VR遊戲中心。<br>Sophia：嘿，Fayt。我很擔心你父母，你認為他們應該還好吧？<br>Fayt：我不知道。我們應該快點早到安全的地方。我的確是很擔心我父母，但我們應該關心我們目前的狀況。<br>Sophia：你說的對。<br>Fayt及Sophia離開。<br>公共職務人員：喔，NO。我該怎麼辦。我應該要放輕鬆，輕鬆。第一件事要做的是，離開這個地方～<br>公共職務人員往外跑，一個小孩及他母親也跟著跑。Fayt及Sophia來到傳輸系統室。</p><p>短髮飯店人員：因為目前的緊急狀況，所有的傳輸系統已轉接運送旅客前往特別層樓。在那有一大型傳輸系統前往緊急避難中心。在確認所有旅客安全抵達避難中心，傳輸阻隔系統將會啟動。請各位以有秩序的速度疏散。<br>Fayt及Sophia站入一傳輸系統前往緊急疏散中心。在那… …<br>Fayt：嘿！<br>鏡頭轉向逃離的人群。<br>Sophia羅勃特叔叔，京子阿姨！<br>Robert：我真高興你們安全到這。<br>Fayt：你們也是啊，爸。<br>Ryoko抱住Sophia。<br>Ryoko：真令人感到放鬆。之前我實在是太擔心了。<br>Fayt：爸，發生什麼事了？是阿爾丁的攻擊嗎？<br>Robert：大概不是。他們持有的武器，好像是… …<br>Fayt：像是什麼？<br>Robert：這不重要。我們應該要先逃離這裡，快走吧。<br>Fayt一行人向前走。<br>男兵：請在這稍後。<br>Robert：出了什麼事嗎？<br>男兵一：這裡有大排長籠的人等著使用前面的傳輸系統。你們可能要在這等一會兒。<br>Robert：原來如此，那我們就在這等。</p><p>忽然.. …<br>男兵二：可惡！他們怎麼到這裡的！(轉向Fayt一行人)快點往前走！！！<br>Sophia：(向Fayt) 我們快逃離這裡吧。<br>Fayt：嗯。<br>敵人出現。<br>敵兵：他們在這！<br>男兵二：(向Fayt一行人說)快逃！<br>敵人打倒我方軍人。<br>Ryoko：Robert？<br>Robert：嗯，如我所想。<br>Fayt：爸？<br>Robert：你們兩個先逃。<br>Sophia：Robert!叔叔？<br>Robert：快點離開這裡。<br>Fayt：但是…<br>Ryoko：快離開！你必須保護她。<br>Robert：沒錯。你們快逃，不要擔心我們。</p><p>Robert：我們很快就是趕到避難中心。<br>Fayt：你不會騙人吧，爸。<br>Robert：不會騙人的。<br>Fayt：那我們走吧，Sophia！<br>Sophia：Okay!</p><p>Fayt離開，Sophia離開前先向Robert及Ryoko行禮。<br>敵兵：他們跑了！用昏迷機器(不太確定該怎麼翻，只能照意義翻)。<br>當Fayt及Sophia逃離時，他們與Incapacitator Vasses戰鬥。贏了一些後，他們被包圍。<br>Fayt：可惡！<br>Sophia：我好害怕喔。<br>Fayt：別擔心，站到我後面。<br>Sophia：嗯，好。<br>Fayt心想：我們該怎麼辦？這些東西打也打不完…嗯？<br>忽然有人打倒那些Incapacitator Vasses。<br>Fayt：什麼跟什麼？<br>？？？：嘿，Fayt、Sophia。你們還好吧？有受傷嗎？<br>Sophia：這不是… …<br>Fayt：Peppita!？<br>Peppita：我只是來看看發生什麼事了，就看到你們有麻煩。<br>Ursus：小姐？！<br>Peppita：你要幹嘛啦Ursus？哎呀？<br>忽然更多的Incapacitator Vasses出現。<br>Peppita：吼！這不是我們需要的啦，Ursus，麻煩你了。你們兩個走啦！<br>Fayt一行人打敗Incapacitator Vasses，那之後… …<br>Peppita：還來啊！<br>Fayt一行人再打。<br>Peppita：呼，太簡單了。<br>Fayt：謝謝你們的幫助。<br>Peppita：沒問題！但我們是該離開這裡的，應該會來更多的那種東西的。那邊都被搞的像災難似的。我們快走。<br>Fayt：災難？但我爸媽！<br>Sophia：(擋住Fayt的路)嘿！等一下啦，Fayt。別想了，你沒聽到她説的話嗎？那邊太危險了。<br>Fayt：但是！<br>Sophia：(也擋住Fayt)別想了！<br>Peppita：你們兩個快點，我已經說過那邊太危險了。<br>Sophia：拜託阻止他，他說他要回去。<br>Peppita：什麼？回去那裡？<br>Fayt：我爸媽還在那裡，我要回去幫助他們。(Peppita擋他的路)走開！讓路！<br>Peppita：你沒聽到我說的話嗎？那麼就像是地獄的景像啊！<br>Sophia：太危險了。<br>Fayt：你們兩個給我讓開啊！<br>Peppita：嗚！我受夠了！Ursus。<br>Ursus把Fayt抓起來扛在肩上。<br>Fayt：放我下來，放我下來。<br>Peppita：你聽著，如果我們不離開這，我們都會死翹翹的。<br>Fayt一行來到傳輸中心前往避難中心。</p><h1 id="緊急避難施設"><a href="#緊急避難施設" class="headerlink" title="緊急避難施設"></a>緊急避難施設</h1><p>避難中心<br>男兵：歡迎來到第五艾魯巴避難中心。這是個位於海達IV地底的疏散避難中心。請在你被安置的房間中等待救援來臨。您可以隨意走動，但這裡有些限制地區，請向臨近的人員詢問更多說明。<br>Fayt點頭。<br>Peppita：好吧，那我們也該走了。(過了一會兒)喂！打起精神嘛。<br>Peppita及Ursus 離開。<br>Sophia：Fayt？<br>Fayt：要不要走，反正我們在這也沒有什麼事要做。<br>Sophia：嗯，好啊。我肯定你父母一定很安全，不要擔心。<br>Fayt：嗯，我知道。走吧！<br>男兵：等一下。你被安排在第506號房，請記得。<br>Fayt：Okay.。506號房，我記得了。<br>男兵：我預算救援飛船很快就到達，請放輕鬆等待。<br>Sophia：好。<br>Fayt及Sophia前往第509號房。<br>Piccolotto：我很慶幸所有人都安全。我們該討論我們的生意計劃，嗯？<br>Peppita：咦？Fayt？</p><p>Piccolotto：啊，你父母他們？<br>Gonnella：唉，別管他們了，反正我們也幫不了什麼忙。嘿，至少你還活著嘛。<br>Peppita：啊，Gonnella！你該注意一下你的嘴巴。<br>Fayt：不，沒關係。就像他所說的，就算我想也幫不了他們。假如我能變得更強些。<br>Sophia：Fayt？<br>Ursus：力量是不夠的，你不可能贏過他們的。<br>Dulcinea：他說的對，這不是你的錯。我想他們都是訓練過的軍人，我們不可能贏過像他們一樣的人。<br>Piccolotto：你知道嗎？就算你父母沒抵達這個疏散中心，並不表示說你父母已經喪命了啊。他們也許正躲在某個地方呢，所以不要放棄希望。<br>Gonnella：也或許他們被抓起來了或什麼的。<br>Peppita：Gonnella！！！<br>Ursus：若是被抓起來也沒關係，你可以去救他們啊。<br>Piccolotto：反正你目前也不能做什麼事，只能在這等。我們都不知道外面發生什麼事了。<br>Fayt：是啊，你說的對。<br>Dulcinea：為什麼不回你的房間休息一下，你現在也累到什麼事也做不了。<br>Peppita：你也可以待在我們這裡休息啊。你不會覺得跟大家在一起比較安全嗎？<br>Fayt：謝謝，但我很好。我想好好把事情的經過想一遍。<br>Peppita：嗯，好吧。</p><p>Fayt及Sophia向Peppita行禮後離開。Fayt及 Sophia前往第506號房。Sophia感到有些累。<br>Fayt：Sophia，你還好吧？<br>Sophia：嗯！我想吧。<br>Fayt：妳一定很累了，妳應該休息一下。<br>Sophia：好吧。<br>Fayt帶Sophia到她的床前，Sophia蓋上棉被。<br>Sophia：對不起。<br>Fayt：別擔心。<br>Sophia：嗯，Fayt？<br>Fayt：什麼事？<br>Sophia：你可以陪我直到我睡著嗎？我不想單獨一個人。<br>Fayt：好，我會留下。放輕鬆睡一下吧！<br>Sophia：謝謝。<br>Sophia睡著了。<br>Fayt：晚安。<br>Fayt走到他的床也跟著睡著。到了半夜3點52分，Fayt醒過來。<br>Fayt心想：我在哪？喔，對喔，海達被攻擊了。現在才凌晨三點52分。<br>忽然警報響起。<br>Fayt：現在又怎樣了。<br>Sophia醒來。<br>Sophia：Fayt！那是什麼聲音？<br>Fayt：聽起來他們好像準備要公告些什麼東西。<br>原本已關燈的房間被打開電源。<br>官方公告：這是給所有民眾更新的公告。我們現在得知海達IV的攻擊來至凡帝(原名：Vendeen)。<br>Fayt心想：凡帝？他們不是那股正與阿爾丁戰爭的軍事力量嗎？前些時候他們拒絕與聯盟政府合作，但那卻沒有任何公開的戰爭啊？<br>官方公告：第七操縱星站試著保護海達IV但卻被凡帝阻撓。目前，潘葛拉克提克執行局正召集附近區域的飛船，但是凡帝軍團還是操縱著這整個地區。我們建議所有人緊急疏散登上救援梭前往第六操縱星站。請不要慌張，請至附近的電腦系統詢問詳細資訊。<br>Fayt：Sophia，我們該走了，妳還好吧？<br>Sophia：嗯，我很好。休息一下讓我平靜下來。<br>Fayt：再撐一下，當我們到第六操縱星站後我們就安全了。<br>Sophia：好。<br>Fayt走向電腦。<br>Fayt：電腦，告訴我Robert及Ryoko Leingod目前的所在地。<br>電腦：您所尋找的目標所在地目前不名。<br>Fayt：什麼意思叫不名？<br>電腦：Robert Leingod及Ryoko Leingod兩人失蹤於銀河年曆772-12141923。<br>Fayt：失蹤？然後呢？<br>電腦：資訊系統目前出現科技上的問題，確認程序無法進行。<br>Fayt：什麼？<br>Fayt及Sophia搭上傳輸系統來到通運飛船海雷。</p><h1 id="阿里亞斯-アリアス-II"><a href="#阿里亞斯-アリアス-II" class="headerlink" title="阿里亞斯(アリアス)II"></a>阿里亞斯(アリアス)II</h1><p>阿里亞斯II(拯救人質由訓練場歸回時)<br>女兵：Lady 妮爾，妳沒事耶！<br>妮爾：是的，我很好。抱歉讓你們擔心了，Clair呢？<br>女兵：她人在總部，她可是很擔心妳呢，我想她現在會想見妳。</p><p>菲特一行人到官邸會議室。<br>Clair：妮爾！<br>妮爾：抱歉讓妳久等了。<br>Clair：你們兩個也很好。我想謝謝你們，若沒有你們前去幫助，我們她們也不會平安回來。<br>菲特：不用謝。<br>克里夫：我們也沒做什麼，只是件小事。<br>妮爾：別這麼說。若不是你們，我們也無法打敗黑軍第二指揮官。<br>Clair：你們打敗了黑軍的Shelby。<br>妮爾：沒錯。<br>Clair：我不敢相信。<br>克里夫：是啊，但是那個愛現他那閃閃發亮盔甲的傢伙還四處悠哉。<br>菲特：你是指那個Albel傢伙吧！<br>克里夫：光想就夠讓我熱血沸騰，下一次遇到他我可不能讓他那麼簡單就逃走！<br>Clair：Albel？你是指人稱邪惡Albel的…<br>妮爾：訝異是吧！我倒是慶幸我們能活著回來。<br>菲特：他有那麼強嗎？<br>妮爾：是的。抱歉了克里夫，但就連我也不確定你能夠贏過他。<br>克里夫：啊！我聽夠了。<br>Clair：好了，說夠了。我想你們一定都很累，我讓人去準備晚餐，不會太久。</p><p>晚餐<br>妮爾：所以你還不想幫助我們是吧？<br>菲特：我還在想。製作武器的這件事，我怎麼想就怎麼不對。<br>Clair：我懂。你不需要立即回答，你可以等到皇城時再決定，這中間的時間夠你想了吧。<br>妮爾：Clair，我想我還是跟他們一起去皇城吧！你覺得可以嗎菲特？<br>菲特：當然，這不是妳的任務嗎？<br>妮爾：的確。</p><p>在阿里亞斯外<br>妮爾：我們先到一個在東北方叫做波特尼的城，等我們買好了需要的物品後再繼續往皇城走。<br>菲特：好，知道了。<br>克里夫：我也瞭了。<br>妮爾：(對Clair)我馬上就回來。<br>Clair：好的，我們很快就會見面的。你們一路上小心啊。<br>菲特：你們也是。<br>Farleen：我們會的。<br>Clair：是的，還請幫我們多看照妮爾。<br>Tynave：願愛普拉思在你身邊領導你們的旅程。<br>Farleen：願愛普拉思在你身邊。<br>菲特一行人前往波特尼。</p><h1 id="交易城市-ペターニ"><a href="#交易城市-ペターニ" class="headerlink" title="交易城市(ペターニ)"></a>交易城市(ペターニ)</h1><p>交易城市波特尼<br>克里夫：所以這就是波特尼。<br>菲特：這個城市的感覺跟阿里亞斯完全不一樣。<br>妮爾：是的，這是因為這裡離水都皇城很近，再加上這裡也是通往聖麥特(Sanmite)共同國，所以這裡是中央商業交流地帶。<br>克里夫：可以了解，難怪這裡這麼熱鬧。<br>妮爾：我有些事情要辦，在我回來前你們可以隨意走走。我們到時就在這個中央商場碰面。<br>菲特：好。<br>克里夫：沒問題。<br>菲特來到中央商場。<br>菲特：這裡就是我們該碰面的中央商場吧！我該做些什麼呢？我想趁著其他人來之前我先休息一下，最近我老覺得疲憊。</p><p>菲特：我覺得累也很渴。研發武器啊，我是知道大家的感受但是…我該怎麼做呢？<br>女子：你還好吧？你生病了嗎？<br>菲特：嗯，沒有，我很好。只是四處逛逛走得有點累了。<br>女子：真的嗎？那你是有權力在這休息。<br>看到女子的臉。<br>菲特：蘇菲雅？妳在這做什麼？<br>女子：啊？<br>菲特：嗯？<br>女子：嗯？抱歉，我想你可能是認錯人了。我叫愛米拉。<br>菲特：Ameena？<br>Ameena：對啊。<br>菲特：抱歉，只是妳長的真的很像我認識的人，我剛剛還以為…<br>Ameena：喔，抱歉。剛剛你大叫時把我嚇了一跳了。<br>菲特：抱歉。<br>Ameena：沒關係呀，嗯…<br>菲特：我叫菲特，菲特 Leingod，很高興認識妳。<br>Ameena：菲特 Leingod？<br>菲特：是的。<br>Ameena：很高興認識你，我叫Ameena Leffeld。<br>菲特：請多指教，Leffeld小姐。<br>Ameena：叫我Ameena就好了，在這大家都這樣叫我的。<br>菲特：好，Ameena，那妳就叫我菲特吧！<br>Ameena：啊，好，謝謝。Leingod先…不對，我是說菲特。<br>菲特心想：她真讓我想起蘇菲雅，就連聲音也很像似。<br>Ameena：拜託不要這樣看我嘛，我害我臉紅了。<br>菲特：喔，抱歉，只是妳真的長得很像她…<br>Ameena：真的嗎？她是誰啊？<br>菲特：我的一個老朋友。<br>Ameena：她人呢？她去逛街了嗎？<br>菲特：不，她在很遠的地方，所以我看到妳才會這樣驚訝。她不可能會在這的。<br>Ameena：原來如此。(咳嗽)<br>菲特心想：嗯？<br>Ameena：我曾經也有一個這樣的朋友，他跟你也差不多年紀。<br>菲特：曾經？<br>Ameena：是啊，我已經很多年沒看到他了。我是在這個城市出生的，但是我以前曾住在艾里葛雷夫。<br>菲特：艾里葛雷夫？<br>Ameena：我們曾交換信件，但當戰爭開始後就寄不成了，我現在根本就不知道他在哪。他最後一封信告訴我說他想當一個研究員。<br>菲特：是嗎？<br>Ameena：但是我相信我們會有相見的一天。<br>菲特：我也相信你們將會相遇。<br>Ameena：謝謝。(咳嗽x3)<br>菲特：妳感冒了嗎？妳從剛剛坐下來就一直咳了。<br>Ameena：我很好，只是一點感冒，沒什麼。<br>菲特：喔，是嗎。這一籃花是做什麼的啊？<br>Ameena：這個？這是我的工作啊，我種花拿出來賣。<br>菲特：妳在賣花？<br>Ameena：是的。我一個人生活，也只有這個我能做。我拿我在自家花園種的花或是到山上摘草藥來賣。<br>菲特：妳一個人住？妳父母呢？<br>Ameena：他們都死於戰爭了。<br>菲特：抱歉，我不該問的。<br>Ameena：沒關係，我已經習慣了。況且住我隔離的婦人也很照顧我。<br>菲特：我很抱歉。<br>Ameena：請不要擔心。所以菲特，你來這旅遊嗎？你不像是這裡的人。<br>菲特：嗯，不算是旅遊。我準備要去水都皇城。<br>Ameena：只有你一個人？<br>菲特：不，我還有兩個人和我同行。<br>Ameena：真的嗎？喔，等一下。這個給你。<br>菲特：妳確定？妳在賣這些，我可以付妳錢啊。<br>Ameena：不用，這不是拿來賣。這是我的，是個護身符。<br>菲特：護身符？<br>Ameena：是的，這已是這個地方的傳統。我們叫它愛里莎夫人，這種花代表著月光及風之女神。大家說當你帶著這種花，愛里莎的力量會一直保護著你。<br>菲特：哇，真神奇。<br>Ameena：我就是帶著這個平安的從艾里葛雷夫回到這裡。<br>菲特：我不能收下這樣對妳來說很貴重的東西。<br>Ameena：沒關係，我已經不需要了。<br>菲特：謝謝妳，Ameena。我們小心帶著它的。<br>Ameena：麻煩你了。<br>菲特及Ameena一起笑了出來。<br>克里夫：嘿，你在幹嘛啊？<br>菲特：喔，是你們兩個啊。<br>克里夫及妮爾歸來。<br>克里夫：泡妞嗎？<br>菲特：嗯，不是啦，她只是剛好長得像我認識的人，嗯…<br>克里夫：你嘛幫幫忙啦，你應該可以再掰出更好的東西吧。下次我教你一些！<br>菲特：(生氣)我告訴過你，我不是喜歡上她啦！<br>克里夫：嘿，冷靜一下。連個玩笑也開不起，如果你不想被我們捉弄，那就不要在這親密親密了。<br>菲特：誰在這親密親密了啊？<br>妮爾：所以？<br>菲特：幹嘛？<br>妮爾：你不把她介紹給我們認識？<br>菲特：喔，她叫Ameena，在這城中賣花。<br>Ameena：嗨，我叫Ameena。<br>菲特：Ameena，這兩人就是和我同行的人，克里夫及妮爾。<br>克里夫：Ameena，還真個好聽的名字，妳好啊，我叫克里夫 Fittir，妳也可以說我是這小鬼的保鑣。<br>妮爾：妮爾 Zelpher。<br>Ameena：很高興認識你們。<br>妮爾：(看到愛里莎夫人)那是朵很稀有的花啊，你怎麼會有的呢？<br>菲特：喔，這是Ameena送我的。<br>克里夫：啊？稀有的花。<br>妮爾：這花叫愛里莎夫人。戰爭已經將大部份產這種花的地方給毀了，所以這種花現在實在很難見。在愛普拉思的傳說中，這種花代表著愛里莎女神，現在人們把它當做旅行用的護身符，就有點像是琶米拉許願符或是在戰場上祈求勝利的爾利尼亞花圈。<br>克里夫：哇，那還真棒啊！妳確定要把這麼寶貴的東西送給他？<br>Ameena：是的，我已經不需要了。抱歉，我該回去工作了。<br>菲特：喔。<br>Ameena：我先走了，跟你們談話我很愉快。祝你們有個安全的旅程前往水都皇城。<br>菲特：謝謝，現在是個困難的時機，請保重。<br>Ameena：謝謝。<br>菲特：我相信妳一定能與妳的朋友相見的。<br>Ameena：願愛普拉思在你身邊。再見！<br>離開時Ameena不停咳嗽。<br>克里夫：嘿，她生病了嗎？她咳的還真嚴重。<br>菲特：嗯，她說她只是感冒。<br>克里夫：是嗎？<br>妮爾：好了，你們兩個，別在這聊天，我們去旅館休息吧！<br>菲特：好主意。<br>妮爾：波特尼有兩間旅館，在東邊的那一個有些問題，所以我們到西邊的那一個休息。<br>克里夫：問題？<br>妮爾：那是間便宜的旅館，再加上它附有酒吧。恕我直說，但那家旅館有些來路不名可疑的老顧客，這裡雖然是水都國，但是我們並不想要不必要的麻煩。<br>菲特：那好，我們就去西邊的那一個旅館。<br>菲特一行人到旅館。<br>櫃台人員：這家旅館只供預約優先，如果你想待在這，最快還需要等上六個月才有空房。喔？Lady 妮爾！妳也要待在這嗎？沒有問題，我們立刻為妳準備房間。祝你們住的慶幸(？)。<br>妮爾：好了，我們已經checked in了。我們的房間應該已經空出，我想我先去看看我一個駐此城中的部屬，你們兩個就隨後走走，但記住不要惹麻煩。<br>克里夫：好！不要太擔心，我是不知道他啦，但妳認為我會惹麻煩嗎？<br>菲特：嘿，你幹嘛擔心我？<br>妮爾：我只是有話直說。這個地方是個商業地區，也吸引了不少奇怪的人前來。像你們這種人很容易跟人打起來的。<br>克里夫：如果真發生，我絕對會讓對方嘗點苦頭的，放心好了。<br>妮爾：我就是在擔心這個。<br>克里夫：喔，嗯。<br>妮爾：(嘆氣)好，我先走了，我天黑前會回來。<br>妮爾離開。<br>克里夫：我想我去酒吧走走，你就自己去找點事做吧！<br>菲特：我想我會的。<br>克里夫離開。<br>櫃台人員：我們正在為你們準備房間，抱歉帶來不便，請再稍點一會兒。<br>菲特離開旅館到一巷子。<br>年輕女子聲音：是的。<br>中年婦女：當然了。<br>菲特心想：這聲音？<br>中年婦女：啊，真仁慈啊。<br>年輕女子聲音：嘻嘻。<br>菲特：心想：那是Ameena。<br>年輕女孩的聲音：我當然很好了。<br>中年婦女：那種是常發生的。<br>年輕女子的聲音：是啊，我同意妳說的。<br>菲特心想：這從這間屋子裡傳來的。<br>菲特走入屋中。<br>菲特：對不起。<br>Ameena：喔，菲特？<br>菲特：嗨，Ameena。<br>Ameena：你在這做什麼啊？<br>菲特：我只是走走，以為聽到妳的聲音。<br>Ameena：還真巧啊。<br>中年婦女：這誰啊？<br>Ameena：喔，這是菲特。他準備要前往水都皇城。<br>中年婦女：喔，到水都皇城？是要去朝拜嗎？<br>Ameena：不，他只是要去那而已。我以為你已經出發了？<br>菲特：還沒，我們打算在波特尼待一晚，明天一早出發。<br>Ameena：真的嗎？明天一早，那我就不能去送別了。<br>菲特：那沒關係，妳不需要特地來替我們送行。對了，妳明天有事嗎？<br>Ameena：是的，我們兩個明天打算要去山裡採花。<br>菲特：山裡採花？拿去賣嗎？我以為妳自己有種。<br>Ameena：這些不花是買不到的，我們一定要親自去採花拿來做許願符才會靈驗。<br>菲特：許願符？<br>Ameena：你可能沒聽說過，這是這裡的另一個傳統，跟愛里莎夫人一樣。這就是那束花要拿來做的。<br>菲特看了桌上的花束。<br>Ameena：你由神山中採下琶米拉花，然後將它們與願望綁起來。你可知道琶米拉花很難找的。<br>菲特：啊。(心想：就像蘇菲雅一樣喜歡找那些四葉幸運草。)<br>中年婦女：人說，當你找到一千朵時，月光及雨之女神琶米拉會聽到你的願意，只要你的願望像眼淚般純潔。<br>菲特：她真能達成願望？<br>Ameena：是的。<br>中年婦女：對我們來說，我們都希望戰爭能結束，大家想的都一樣，所以我打們打算要做許願符，但是目前為止還沒有達成願望。<br>菲特：這也妳所許的願望嗎？<br>Ameena：我？<br>中年婦女：這女孩是希望能再見到她失散已久的朋友，這可是她第一個願望，當然她也是希望戰爭停止的。<br>Ameena：不要告訴他這些啦。<br>菲特：啊，妳的老朋友是吧？<br>Ameena：嗯，我有提過他吧，我真的很想再見他一面。除了這個我也許了其他的願望，像是我的病…<br>菲特：妳剛剛說什麼？<br>Ameena：嗯，沒事，沒事。<br>菲特：我希望如此，希望妳能達成願望。<br>Ameena：謝謝。我一定要相信我的願望能成真，要是放棄一切都完了。<br>菲特：是啊。<br>Ameena：我有信心。<br>菲特：啊，我想我該走了，妳要保重啊Ameena。<br>Ameena：你也保重，菲特。如果你有經過波特尼，別忘了來找我喔。<br>菲特：我會的。<br>Ameena：願愛普拉思在你身邊。<br>中年婦女：多保重，願愛普拉思在你身邊。<br>菲特：再見！<br>菲特回到旅館與妮爾說話。<br>妮爾：你逛夠了嗎？<br>菲特：嗯。<br>妮爾：那好，你也該休息一下。我知道會很累，但是我們明天一大早如同計劃前往水都皇城。<br>半夜菲特躺在床上沒有睡。<br>菲特心想：Ameena，蘇菲雅？不知道她現在怎麼樣了，她會不會也在擔心我呢？<br>克里夫：睡不著？<br>菲特：嗯，說到Ameena就讓我想起蘇菲雅。我希望她平安逃脫，我也很擔心Ameena，希望她的感冒不要越來越嚴重。<br>克里夫：我不怪你擔心蘇菲雅，但你也沒辦法做什麼。我們應該集中精神在我們現在能做的事。<br>菲特：嗯，我知道。<br>克里夫：Ameena的事也一樣，你越想幫就只會讓事情變得困難罷了。<br>菲特：晚安！<br>克里夫：晚安。</p><p>第二天<br>妮爾：所以你們有睡好嗎？<br>克里夫：還不錯，這個地方很適合像我一樣的紳士。<br>菲特：？<br>妮爾：如你們所說的，真好笑是吧！我們現在是該出發前往水都皇城了。<br>克里夫：嘿，等一下，妳怎麼說得好像我信任我一樣！<br>菲特一行人離開旅館。<br>中年婦女：是你們！好險，我還以為你們已經走了！<br>菲特：你是Ameena的鄰居是吧，怎麼了？<br>中年婦女：請幫幫我啊，Ameena她…<br>菲特：Ameena？她怎麼了？<br>中年婦女：Ameena本來在神山上，忽然病發啊。她連動都不能動，而我也沒有力量抬她回到這。所以我一個人先回找人幫忙。<br>克里夫：病發？所以她的確是有生病囉。<br>中年婦女：應該是吧！Ameena一直都是個體弱多病的女孩，喔，我不該帶她上山去的。<br>菲特：那她在哪昏倒？<br>中年婦女：在往聖麥特Sanmite途中的山上，在有動物足跡的尖石西方的一座森林中。你們能去幫她嗎？<br>妮爾：尖石？那應該是戴格斯森林了。在城的西方！<br>菲特：西方是吧！<br>當菲特準備一個人離開時…<br>克里夫：嘿，等一下啊！<br>菲特：克里夫及妮爾，你們在這等我，我去救Ameena。<br>克里夫：哈，你想我們會讓你一個人去？<br>妮爾：不可能。除此之外，戴格斯森林佈滿了土匪強盜，我想我們三人一起去比較安全。<br>菲特：土匪？<br>克里夫：那可不好啦，我們得快點到那個什麼戴格什麼什麼森林去！<br>菲特：走吧！<br>菲特等人離去。<br>中年婦女：一路順風！<br>菲特一行人來到戴格斯森林。</p><h1 id="戴格斯森林-ダグラスの森"><a href="#戴格斯森林-ダグラスの森" class="headerlink" title="戴格斯森林(ダグラスの森)"></a>戴格斯森林(ダグラスの森)</h1><p>戴格斯森林<br>菲特一行人遇上一小妖精。<br>Fairy：我就快要離開這個世界了。<br>菲特：妖精？<br>妮爾：他們可是很稀有的，就連我也是第一次見到一個。<br>Fairy：喔，他們一定會把給生吃了！<br>克里夫：嘿，別看我，我可不吃小蟲子的。<br>Fairy：真沒禮貌，我又不是蟲。<br>菲特：妳還好嗎？<br>Fairy：如果我能感受到山中霧氣打在我的臉上，喝下這山中的清泉之水，我就會感覺好多的。<br>菲特：好，我們去拿些泉水。<br>菲特一行人拿水妖精喝。<br>菲特：那！泉水。.<br>妖精喝下。<br>Fairy：呼，感覺好多了，謝謝你們！我來告訴你們一個小秘密。你們知道這個森林中有些樹會變成妖怪喔，他們都會擋你的路，他們會的。<br>菲特：原來如此，那我們該怎麼做？<br>克里夫：把它們燒了？<br>Fairy：才不是呢，你這個笨蛋。我來當你們的導遊，那些樹妖是敵不過我的眼睛的。</p><p>月影族的藏身處。<br>菲特：這裡該不會是土匪的藏身處吧！也許他們把Ameena帶到這裡。<br>克里夫：在去查看之前，我們是不會知道的。<br>妮爾：是啊，要進去看看嗎？<br>菲特：好。<br>妮爾：我去查看附近，你們兩個進去。<br>菲特及克里夫走入木屋。<br>？？？：誰在那！你們是誰？(打嗝)<br>菲特：這不是Ameena。<br>克里夫：這傢伙是什麼啊？<br>菲特：我猜被這些土匪綁起來的小孩？別擔心，我們不會傷害你的。<br>？？？：那你們一定要救我，放我出去！<br>菲特：發生什麼事了？你為什麼會在這？<br>？？？：我沒做錯什麼啊。(哭)<br>菲特：這裡除了你之外就沒有其他人呢？<br>？？？：沒有。(打嗝)<br>菲特：所以你沒看到一個女孩在這附近？她叫做Ameena。<br>？？？：？(過了一會兒)嗚！吼，先別管其他的事，你們這群笨蛋，快我把放出去啦！<br>菲特：啊？<br>？？？：糟了，嘻嘻。<br>克里夫：露出真本性了吧！他也只是個小鬼。<br>？？？：被發現了。<br>菲特：再說啊。<br>？？？：我會乖乖的，請你們放我出來嘛。<br>菲特：你究竟是誰啊？<br>？？？：我？我叫羅傑，叫我Sir 羅傑。我是個隊長，我可是非常重要的人物，你知道嗎？<br>克里夫：夠了，這些資料就夠了。謝喔！<br>羅傑：閉嘴！你這個超級不中用的傢伙。如果有人向你求救，你應該出手幫忙的，你是該關心一下他人，至少那是我爸告訴我的，而他說的總是對的。 喔，拜託啦，你們竟然這樣無情，你們這群大壞蛋。<br>菲特：真不可思議。<br>妮爾進入。<br>妮爾：怎麼了，發生什麼事？<br>菲特：妳可以這麼說。<br>羅傑：咦？這樣美妙的聲音是從哪來的？<br>妮爾：還有其他人在這？<br>羅傑：哇，漂亮妹妹。喔，拜託妳幫幫可憐的我離開這個籠子啊！<br>妮爾：…這小孩是誰？是跟土匪一夥的嗎？<br>羅傑：不，妳搞錯了，小姐，其實我呢…<br>菲特：看來Ameena不在這，我們走吧！<br>克里夫：嗯，聽起來不錯。我對這小鬼感到厭煩了！<br>妮爾：你可以再說一次也沒關係。<br>菲特：是啊！<br>羅傑：你們真的太無情了，我在向你們求救啊！<br>有人進屋。<br>？：什麼？你們是誰？<br>是月影族的人。<br>羅傑：嘿，你們看，那些笨蛋回來！我的手下會把你們碎屍萬段的，你們最好開始禱告吧！<br>土匪：你剛剛說什麼？<br>克里夫：他剛剛說手下？不會是指…<br>菲特：我想那應該是指我們吧。<br>妮爾：我想也是。<br>三人嘆氣。<br>土匪：你們找死！<br>羅傑：太晚了，我們不會對你手下留情的。手下們，上！<br>菲特等人打敗土匪。妮爾將羅傑放出。<br>羅傑：你們幫了我大忙，謝啦！<br>克里夫：？，什麼？這傢伙有尾巴？<br>羅傑：這有什麼好大驚小怪的，我告訴你，我的尾巴還是我認識的人中最柔軟的呢。<br>妮爾：你是由聖麥特共合國來的曼諾迪可斯Menodix族的。<br>羅傑：小姐說的一點也沒錯。<br>菲特：聖麥特共合國？<br>妮爾：水都國西北方的國家。你應該看到不少與人類不太一樣的人在波特尼出現，他們都是由聖麥特來的。<br>菲特：啊？<br>妮爾：但是能在這找到一個曼諾迪可斯族的人是很奇怪的。大家都知道他們從不離開他們所居住的高原。<br>羅傑：小姐妳瞧，這其實是很複雜的。<br>克里夫：複雜？才怪。<br>菲特：為什麼那些土匪要把你關在這呢？<br>羅傑：那是個秘密。你知道嗎，真正的男人，有些事是連他的女人也不能知道的。<br>克里夫：啊？秘密？我們才剛救了你啊。<br>妮爾：真是個怪小孩，我們把他留下，我可不想聽他的故事。<br>羅傑：啊，啊？<br>妮爾：我們沒興趣。<br>羅傑：喔，但是我希望你們聽啊！小姐。<br>克里夫：可不可以有人阻止我掐死這小鬼的啊！<br>菲特：所以你為什麼會被抓呢？<br>羅傑：我們在打賭。<br>菲特：賭？<br>羅傑：對啊。我們的小組與在索發里歐Surferio敵對的人打賭看誰在是真正的男子漢。<br>妮爾：打賭？那你是要做什麼的呢？<br>羅傑：勇氣考驗。我們賭看哪一方混入傳說中在戴格斯森林中的月影土匪，偷走他們的寶藏。<br>克里夫：所以結果是你被抓起來了。<br>羅傑：閉嘴啊笨瓜！<br>菲特：我們知道你怎麼到這的，那你回去時小心一點。<br>羅傑：那你們來這是做什麼的？應該不是要清除那些土匪嗎？<br>菲特：我們是來找人？<br>羅傑：找人？一個女孩？<br>菲特：啊？是啊。<br>羅傑：我瞭了。要不然我來幫你們的幫。<br>克里夫：啊？<br>羅傑：我說我要幫助你們，你這個大笨蛋。況且我比你們還了解這座森林。<br>菲特：謝謝，但是…<br>羅傑：啊？你們要拒絕我這種令人難以抗拒的人？<br>克里夫：你一定有什麼計劃，你確定你真的要幫助我們？<br>羅傑：可惡！<br>克里夫：如我所想。<br>妮爾：我們聽聽看他的回答。你究竟是想要什麼？<br>羅傑：嗯，小姐… 嗯… …是這樣的啦…<br>菲特：說吧，我們不會生氣的。<br>羅傑：你瞧，我其實還沒拿到打賭要求的寶藏。<br>克里夫：寶藏？<br>羅傑：沒錯！一具金雕像。<br>克里夫：那為什麼不去拿呢？<br>羅傑：我也希望我能拿到，但是卻在土匪的頭目身上，我只知道他在這森林中的某個地方。<br>菲特：我知道了。<br>克里夫：所以你的意思是你打算利用我們，如果幸運的話，我們幫你拿到那個寶藏，是吧！<br>羅傑：你可以這麼說啦。<br>妮爾：為什麼不行，或許我們需要他的力量啊。<br>克里夫：妳腦子有問題嗎？<br>妮爾：Ameena倒在這森林也有一段時間了，我們需要立刻找到她把她帶回城中。如果這小孩真的知道這個森林的路況，他可以帶我們啊。<br>克里夫：嗯，也許吧。<br>羅傑：沒錯。<br>克里夫：好吧。<br>菲特：嗯，羅傑你會幫助我們吧？<br>羅傑：我欠你們一個人情。放心，包在我身上！<br>克里夫：但你們的打賭呢？你還沒完成吧。<br>羅傑：呃…<br>妮爾：別說你忘了。<br>羅傑：嘿，又沒有關係。我就幫你們找人，或許我會遇上我在找的人。我幫你們找那女孩，那如果我們遇上土匪頭目，你們就幫我把他打倒，這樣大家都開心了啊。<br>菲特：好，那我們快點。<br>羅傑：走走走！<br>菲特離開，羅傑走一走撞上某個人。<br>？：嗚！<br>羅傑：喔…(起身)小心一點啊… …你…<br>頭目：什麼？<br>菲特：這個會是頭目嗎？<br>妮爾：是他沒錯。<br>克里夫：的確是，他看起來就很邪惡。<br>頭目：你就是剛才那個小鬼，你在這做什麼？我們不是把你關起來了嗎？<br>羅傑：你把我關在牢中的這比帳，你想你要怎麼還！只有老婦人才能抓到這傢伙的！<br>頭目：你在說什麼？回去你的籠子裡。<br>羅傑：你把我當傻瓜嗎？第一，我如果回到那籠子裡，我怎麼能贏那男子漢的比賽呢。<br>頭目：照我的話去做，還有這個男子漢比賽又是什麼鬼玩意兒。<br>羅傑：就是比賽看誰才是男子漢啊，笨蛋。<br>頭目：什麼？<br>羅傑：別管那些五四三的，快把你的寶藏拿來。<br>克里夫：等一下，沒有人告訴我須要搶寶藏啊？<br>羅傑：啊？我不是說了嗎？<br>妮爾：你一句也沒說啊。<br>羅傑：嗯，管他的。閉上嘴把寶藏拿來，別浪費時間，快拿來。<br>頭目：你在開什麼玩校，我為什麼要把我的寶藏給你。<br>羅傑：你真的什麼也不懂，你還真是個呆瓜。快把寶藏拿來！<br>頭目：你說誰呆瓜了。我受夠你了，我要把你給打成碎片！<br>羅傑：哈，你不可能贏過我的。你們！打架時間到囉。<br>克里夫：喂喂？<br>菲特：我能先問你一件事嗎？你有看到一個到這採花的女生嗎？<br>頭目：我不知道，就算知道也不會告訴你們。你們到這開我玩笑，長得邪惡又不是我的錯。<br>克里夫：喔喔，他聽到我們說的話了。<br>妮爾：看似如此，我想我們傷了他的心了，看來你是該安靜一下。<br>克里夫：就算真是如此，他也挺感性的。我是不會再多說話，但是他真的長的很邪惡啊！妳想呢？<br>頭目：你這個…<br>菲特一行人打敗頭目。</p><p>羅傑：耶，我又得到一勝了！看你能怎樣呢，路西安Lucien(他的對手)。<br>菲特：恭喜你。<br>羅傑：我要謝謝妳啊，小姐。<br>克里夫：喂，等一下。那我們是什麼？站著好看的嗎？<br>羅傑：喔，我應該…嗯，謝囉。<br>克里夫：應該？<br>羅傑：我猜我是應該要謝謝你啦！<br>克里夫：？?<br>羅傑：某個角度來講也是種謝謝啊。<br>克里夫：？?<br>羅傑：又不是我… …不想謝你。<br>克里夫：？<br>羅傑：嗯，幹的好！<br>克里夫不理他。<br>羅傑：好啦，好啦，非常謝謝你可以了吧！<br>克里夫：這樣才對嘛。<br>妮爾：別管這兩人了，我們應該快點找到Ameena。<br>菲特：妳說的對。<br>菲特及妮爾先走人。<br>克里夫：喂！<br>羅傑：等一下啊！<br>菲特一行人到森林深處。<br>菲特：這裡是霧的來源地？<br>羅傑：不管怎樣，這裡很是可疑。<br>克里夫：接下來要幹嘛？<br>妮爾：有東西接近了。<br>羅傑：看來是麻煩上身了。<br>打敗BOSS。<br>妮爾：霧消失了。<br>菲特：快點，我們要快點找到Ameena。<br>菲特一行人到花叢地區找到昏迷的Ameena。<br>菲特：Ameena！Ameena！<br>羅傑：這就你們要找的人嗎？<br>克里夫：是啊。(面向菲特) 怎樣，她還好嗎？<br>妮爾：她還在呼吸，但是她已經病入膏肓。<br>菲特：我們快帶她回去吧！<br>Ameena：嗯，喔…<br>羅傑：那我們後會有期了，高興你們找到這女孩啊。<br>菲特：謝謝，我們感激你的幫助。<br>羅傑：別說了，好事是該一直做下去的。那再見囉！<br>羅傑離開。<br>克里夫：我們快回去吧！<br>菲特：嗯。</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PS2</tag>
      
      <tag>SO3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>夜读|好文摘录</title>
    <link href="/2023/06/14/%E5%A4%9C%E8%AF%BB-%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/"/>
    <url>/2023/06/14/%E5%A4%9C%E8%AF%BB-%E5%A5%BD%E6%96%87%E6%91%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="那些不发朋友圈的人"><a href="#那些不发朋友圈的人" class="headerlink" title="那些不发朋友圈的人"></a>那些不发朋友圈的人</h1><p>于丹曾说：<strong>“一个人越炫耀什么，内心便越缺什么。”</strong></p><p>一个人在某种程度上表现的更加突出，这样可能是自我保护的一个途径。</p><p>人生在世，无论做什么事，都要学会低调，不要太高调，也不要太张扬，否则很容易招致祸端。</p><p>尤其是在职场，如果你的言语过于锋芒毕露，就会招致自己的麻烦。</p><p>所以，在职场上，我们要学会淡然处之，这样才能在职场上走得远一些。</p><p><strong>我们每个年龄段的人都有属于自己的喜欢的生活方式。所以不要因为在意别人的眼光而改变自己的生活方式。</strong></p><p><strong>做一个心系自己，不刻意讨好谁，不刻意将就谁，不刻意与谁攀比，在自己的领域里光彩照人的人。</strong></p><p>一个人要成功，首先要做到的就是认真做事，认真做人，认真做事，才能做好自己的事情。</p><p>在工作中，如果你能够认真对待每一件事情，你就会发现，你的事业会一帆风顺，你的生活也会充满阳光。</p><p><strong>曾经年少轻狂的我们，这样盲目的期待想要得到外界的任何一丁点儿的承认</strong>，到最后才知道：<strong>我们的世界从头到尾是自己的，与别人无关。</strong></p><p><strong>只有当我们畅游在自己的世界里，把思想当做翅膀，才能更加充实，自由自在。</strong></p><h1 id="比考试更重要的事情"><a href="#比考试更重要的事情" class="headerlink" title="比考试更重要的事情"></a>比考试更重要的事情</h1><h2 id="比成绩更重要的是成长"><a href="#比成绩更重要的是成长" class="headerlink" title="比成绩更重要的是成长"></a>比成绩更重要的是成长</h2><p>考试是个点，人生是条线。 <strong>没有人因考试赢得所有，也没有人因考试输掉一切。</strong></p><p>高考，考研真正的意义在于经历这场人生的历练和成长。</p><p>我的一个朋友说过：“无论结果，考过研和没考过研的人是完全不一样的”。</p><p>成长不是意味着更漂亮的分数，而是代表着更开阔的视野、更坚韧的人格。</p><p>在你往后的每一步，不管遇到什么难题，只要想起高考和考研时的自己，你就总能鼓起勇气，奋力一搏。</p><p>你会发现，高中三年努力的习惯，会贯穿你的一生。它教会你坚持，也教会你隐忍。</p><p>这些精神会融化进你的骨血之中，伴随你走过未来的每一个阶段，让你沉淀出更好的自己。</p><h2 id="比成功更重要的是成人"><a href="#比成功更重要的是成人" class="headerlink" title="比成功更重要的是成人"></a>比成功更重要的是成人</h2><p>从小到大听的一句话：<strong>先成人，再成才</strong></p><p>很多人都以为，所谓成功，不外乎事业上的辉煌，物质上的华美，学历上的优越。<strong>却忘了，首先是成为一个优良的人。</strong></p><p>高考之后，你会脱离父母的怀抱，走进一片新的天地。</p><h1 id="值得重视的品质"><a href="#值得重视的品质" class="headerlink" title="值得重视的品质"></a>值得重视的品质</h1><h2 id="微笑"><a href="#微笑" class="headerlink" title="微笑"></a><strong><strong>微笑</strong></strong></h2><p>人生在世，谁没有烦恼忧愁，谁没经历过挫折与不顺呢？</p><p>爱笑的人也并不是生活上万事如意，而是他们明白，击败苦难的永远不会是沮丧，而是乐观与微笑。</p><h2 id="自律"><a href="#自律" class="headerlink" title="自律"></a>自律</h2><p>真正的自律，<strong>不是一味强迫自己去做本不愿意做的事情</strong>，而是发自内心的喜欢，<strong>打心底里认可自己需要去做</strong>，并为止不断付出努力。</p><p>诚然，自律的初期是痛苦的，但当你把它内化成一种本能习惯后，就会享受到它所带来的快乐和价值感。</p><p>就像有人说的，<strong>自律不一定难，假装自律才难</strong>。</p><h2 id="豁达"><a href="#豁达" class="headerlink" title="豁达"></a>豁达</h2><p>人生不是一马平川，生活不是斑斓童话，我们难免会遭遇荆棘坎坷。这时，需要<strong>以豁达的心态重新审视</strong>生活。</p><p>不管身处任何环境，都可以安顿自己的身心。</p><p><strong>心大了，事情就小了</strong>。</p><h1 id="最好的状态"><a href="#最好的状态" class="headerlink" title="最好的状态"></a>最好的状态</h1><h2 id="乐观"><a href="#乐观" class="headerlink" title="乐观"></a>乐观</h2><p>我们无法决定每件事的结果，却可以决定自己的心态。</p><p>如果总是消极悲观，便会觉得生活处处不顺心；当你积极乐观地面对挑战，就会发现生活其实处处是阳光。</p><p>乐观的人，能够拿得起，也能放得下。他们即使身处逆境，也相信自己一定可以战胜困难；即使遭遇失败，也会笑着说“没关系，下次再来”。</p><p>用微笑迎接每一天的到来，把平淡的日子过得简单又充实。</p><h2 id="知足"><a href="#知足" class="headerlink" title="知足"></a>知足</h2><p><strong>幸福是感受出来的，不是比较出来的</strong>。生活中，要懂得知足，不去做无谓的攀比。</p><p>一个懂得知足的人，<strong>不会为已经过去的事纠结不已，也不会为尚未发生的事忧心忡忡</strong>。他们专注于当下，感受此时此刻的幸福，懂得珍惜眼前人。</p><h1 id="心情不好时，不妨先接纳情绪"><a href="#心情不好时，不妨先接纳情绪" class="headerlink" title="心情不好时，不妨先接纳情绪"></a>心情不好时，不妨先接纳情绪</h1><p>我们的情绪，就像一根管道。</p><p>当它堵住时，<strong>要做的是及时疏通，而非时刻控制</strong>。</p><p>如果你不断去压抑它，最终坏情绪累积到一定量，就会在某一天彻底爆发出来。</p><p>其实，人生的常态是喜忧参半。</p><p><strong>我们没办法让每一天都过得都很顺心</strong>，也没有办法让每一刻都过得都很如意，更没有办法让这一生都活在无忧无虑中。</p><p>重要的<strong>不是去对抗那些不开心，而是适当地去释放自己的情绪</strong>。</p><p>心情不那么美好时，去吃一点喜欢的东西，去做一点喜欢的事，或者去一个喜欢的地方。</p><p>不要像发条一样，把自己崩得太紧，要学会给自己解压。</p><hr><p>许多时刻，我们可能对情绪有一个误区。总以为好的情绪才是被接纳的，坏情绪是应该被摒弃的。</p><p>但就像每一个人都有自己的缺点和不足一样，<strong>一切情绪都有它们存在的意义</strong>。每一种情绪的存在都是有原因的，它们<strong>不能用单纯的“好”或“坏”来评判</strong>。</p><p>有时，坏情绪，也是一种好的提醒。</p><p>坏情绪不是为了伤害我们而出现的，它们用自己的存在，提示、保护、唤醒着我们。</p><p>要先学会接受它，明白究竟是为什么不开心、不舒服、不自在，然后才能更好地调整和修复。</p><p>当你处于坏情绪中，<strong>勇于表达自己的感受</strong>并不是懦弱的表现，当心事有了倾诉对象，烦恼也会减半。适当的倾诉不但可以释放我们的坏情绪，还可以得到他人的建议，帮助我们获得解决问题的新方法。</p><p>我们<strong>真正抵制的从来不是情绪，而是不能太过“情绪化”</strong>。</p><hr><p>正确处理情绪的方式<strong>不是逃避，而是面对</strong>。</p><p>要学会去看见、去了解、去认识你的不好情绪，看它真正的源头所在，才能真正去疏通。</p><p>坏情绪，恰恰是一面镜子。<strong>它本身不是最大的问题，而只是帮你反映出存在的问题</strong>。</p><p>不要再压抑情绪，去真正了解它想表达的，是治愈自己的第一步。</p><h1 id="做好小事，挺过难事，静成大事"><a href="#做好小事，挺过难事，静成大事" class="headerlink" title="做好小事，挺过难事，静成大事"></a>做好小事，挺过难事，静成大事</h1><p>人生总会有各种各样的经历，总会遇到各种各样的事。</p><p>学着在经历中<strong>修炼性情、磨练心智、沉淀心境</strong>，是我们获得成长的关键。</p><h2 id="小事，修炼性情"><a href="#小事，修炼性情" class="headerlink" title="小事，修炼性情"></a><strong>小事，修炼性情</strong></h2><p>在工作生活中，难免会遇到一些看似无关紧要的小事。</p><p>一个人能否有所成长，关键在于<strong>怎么看待小事</strong>。做好小事，不仅能增加自己的成就感，还可以使自己的性情变得更加沉稳。</p><p>人生本就是由一件件小事叠加而成的，要成就一番大的事业，首先要从小事做起。把小事做好，才能把大事做成。</p><p>更难得的是，我们还能从中<strong>磨练自己，修炼心性。一个心性沉稳的人，会走得更远</strong>。</p><h2 id="难事，磨炼心智"><a href="#难事，磨炼心智" class="headerlink" title="难事，磨炼心智"></a><strong>难事，磨炼心智</strong></h2><p>人生不会总是一帆风顺，难免遇到风风雨雨。</p><p>遇到这些难事，其实是对自身的一种磨炼。</p><p>只有熬过人生苦难的人，才能<strong>让自己的心智变得更加成熟和坚韧</strong>，也更加明白什么该珍惜，什么该远离。</p><p>真正厉害的人，会把逆境当成命运的馈赠。</p><h2 id="大事，沉淀心境"><a href="#大事，沉淀心境" class="headerlink" title="大事，沉淀心境"></a><strong>大事，沉淀心境</strong></h2><p>遇到大事，无需逃避，不必退缩。要学会沉淀心境，平稳心态。</p><p>所谓<strong>静而后能安，安而后能虑，虑而后能得</strong>。</p><p>当你心境淡然时，才能真正的去思考问题，解决问题。</p><p><strong>不必去计较一时的得失</strong>，完成好每一天的任务，沉淀自己。就像种子要发芽需要默默地汲取足够多的养分。</p><p>每天努力耕耘，必有收获的那一天.</p><hr><p><strong>人这一生会遇到很多事，可不管怎样，这一过程都让我们渐渐成长</strong>。人生本就是一场历练。</p><p>在小事中精进，使我们愈发沉稳；在难事中磨炼，使我们愈发成熟；在大事中沉淀，使我们愈发强韧。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈&amp;人生哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>夜读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode|Tree Problem Sets</title>
    <link href="/2023/06/11/LeetCode-Tree-Problem-Sets/"/>
    <url>/2023/06/11/LeetCode-Tree-Problem-Sets/</url>
    
    <content type="html"><![CDATA[<h1 id="整体思路框架"><a href="#整体思路框架" class="headerlink" title="整体思路框架"></a>整体思路框架</h1><h2 id="关于前序中序后序遍历的思考"><a href="#关于前序中序后序遍历的思考" class="headerlink" title="关于前序中序后序遍历的思考"></a>关于前序中序后序遍历的思考</h2><p>二叉树<strong>本质上其实就是一个二叉链表</strong>，针对二叉树的前序中序后序 递归遍历，我们实际上也可以用在数组和链表当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverseArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array,<span class="hljs-type">int</span> idx)</span>&#123;<br><span class="hljs-comment">//递归终止条件</span><br>     <span class="hljs-keyword">if</span>(idx==array.length)&#123;<br>          <span class="hljs-keyword">return</span>;<br>     &#125;<br>     traverseArray(array,idx+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverseLinkedList</span><span class="hljs-params">(ListNode head)</span>&#123;<br>     <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span>;<br>     &#125;<br>     traverseLinkedList(head.next);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Leetcode</tag>
      
      <tag>Labuladong</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode|Array Problem Sets</title>
    <link href="/2023/05/20/Leetcode-Array-Problem-Sets/"/>
    <url>/2023/05/20/Leetcode-Array-Problem-Sets/</url>
    
    <content type="html"><![CDATA[<h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><h2 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></h2><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230520210035964.png" style="zoom: 67%;" /><h3 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h3><p>首先一个很暴力的思路就是把所有不重复的元素都找到，然后 copy 到一个新的数组里，这种做法最暴力，同时空间利用率也是最低的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicatesViolet</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//开一个新数组来存取元素</span><br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br><span class="hljs-comment">//记录上一个被标记的重复的元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>res[<span class="hljs-number">0</span>] = prev;<br><span class="hljs-comment">//记录新数组存取的索引idx</span><br><span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//遍历原始数组如果发现有之前不一样的，就存储到新的数组里</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br><span class="hljs-keyword">if</span> (nums[i] != prev) &#123;<br>res[++idx] = nums[i];<br>prev = nums[i];<br>&#125;<br>&#125;<br><span class="hljs-comment">//因为会检查原有数组的元素，因此需要把新数组的元素重新复制进去一遍</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; idx; i++) &#123;<br>nums[i] = res[i];<br>&#125;<br><span class="hljs-keyword">return</span> idx + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双指针的快慢指针进行优化"><a href="#双指针的快慢指针进行优化" class="headerlink" title="双指针的快慢指针进行优化"></a>双指针的快慢指针进行优化</h3><p>上述的操作完全可以优化，通过对数组进行原地修改数据就可以实现，省去了额外的O(n)空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//快慢指针</span><br><span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//快指针在前面探路</span><br><span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br><span class="hljs-comment">//只要发现不重复的元素，就更新 slow 并且存储</span><br><span class="hljs-keyword">if</span> (nums[slow] != nums[fast]) &#123;<br>                   <span class="hljs-comment">//慢指针充当了暴力方法中的 被标记的重复的元素</span><br>nums[++slow] = nums[fast];<br>&#125;<br>fast++;<br>&#125;<br><span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题的一个核心思想其实就是 <font color='red'>记录上一个标记的重复的元素，遇到新的元素存取下来</font></p><p><font color='red'>通过快慢指针优化了多的空间</font></p><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230521194752836.png" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br><span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//双指针的快慢指针思想</span><br><span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br><span class="hljs-comment">//只要不是要被删除的元素，就原地赋值到慢的那个指针的位置</span><br><span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>nums[slow++] = nums[fast];<br>&#125;<br>fast++;<br>&#125;<br><span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="还是经典的快慢指针思想"><a href="#还是经典的快慢指针思想" class="headerlink" title="还是经典的快慢指针思想"></a>还是经典的快慢指针思想</h3><p>其实和上面的本质思想是差不多的</p><p>采取快慢指针的做法，<font color='red'>快指针扫描数组，只要是不是被删除的元素，就更新到慢指针上</font></p><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230522155801238.png"></p><h3 id="快慢指针思想适用于原地删除和移动数据的操作"><a href="#快慢指针思想适用于原地删除和移动数据的操作" class="headerlink" title="快慢指针思想适用于原地删除和移动数据的操作"></a>快慢指针思想适用于原地删除和移动数据的操作</h3><p>在这一题中，看似是移动所有的0</p><p>实际上<font color='red'>我们可以把移动的过程等价转化为：先删除，之后再进行一轮赋值</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//先把所有非零的数据移动到前面，相当于删除所有0</span><br><span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br><span class="hljs-keyword">if</span> (nums[fast] != <span class="hljs-number">0</span>) &#123;<br>nums[slow++] = nums[fast];<br>&#125;<br>fast++;<br>&#125;<br><span class="hljs-comment">//之后把所有的0补上</span><br><span class="hljs-comment">//非0数据的长度是slow，下标到slow-1，因此从slow下标开始全部置0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> slow; i &lt; nums.length; i++) &#123;<br>nums[i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h1><h2 id="最经典的二分搜索"><a href="#最经典的二分搜索" class="headerlink" title="最经典的二分搜索"></a>最经典的二分搜索</h2><p>太经典了所以直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> tar)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (nums[mid] == tar) &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; tar) &#123;<br>right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; tar) &#123;<br>left = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//没找到</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230605113114798.png" alt="题目信息"></p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>首先看到题目的<font color='red'>数组有序</font>，我们就应该想到使用<strong>二分</strong>，或者是<font color='red'>类似二分的左右指针思想</font></p><p>这题也是给一个target数，其实很符合二分的应用场景</p><p>我们可以类似的使用二分的思想，左右指针分别指向两个数据，每一次循环都不断调整左右指针和的范围，如果左右指针和比target大了，说明要往小的找，也就是左移right；如果左右指针和比target小了，说明要往大的找，也就是右移left。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = numbers.length - <span class="hljs-number">1</span>;<br><span class="hljs-comment">//题目要求是不能返回重复的元素，因此left和right指针不能重合</span><br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-comment">//类比二分计算mid的操作，这里借用的是二分的思想</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[left] + numbers[right];<br><span class="hljs-keyword">if</span> (sum == target) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<span class="hljs-comment">//左右指针的数据和比target大了，说明要变小，right指针左移</span><br>right--;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>left++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230609210239610.png"></p><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>有了之前的左右指针技巧积累，这题基本就是秒杀的了</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = s.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (l &lt; r) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[l];<br>s[l] = s[r];<br>s[r] = temp;<br>l++;<br>r--;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230609212445951.png"></p><h3 id="暴力思路"><a href="#暴力思路" class="headerlink" title="暴力思路"></a>暴力思路</h3><p>首先这题可以通过暴力的方式来处理，枚举所有的子串，然后判断所有子串是否为回文串，如果是回文，维护一个最长回文子串的变量用于记录结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>       <span class="hljs-keyword">if</span> (s.length()==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-type">String</span>  <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt;=s.length(); j++) &#123;<br>                   <span class="hljs-comment">//data就是所有的子串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> s.substring(i, j);<br>                   <span class="hljs-comment">//判断子串是否是回文</span><br><span class="hljs-keyword">if</span> (checkPalindrome(data)) &#123;<br>                        <span class="hljs-comment">//如果是更新记录</span><br><span class="hljs-keyword">if</span> (res.length()&lt;data.length())&#123;<br>res=data;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>  res;<br>&#125;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkPalindrome</span><span class="hljs-params">(String s)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>,r=s.length()-<span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>           <span class="hljs-keyword">if</span>(s.charAt(l)!=s.charAt(r))&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>           l++;<br>           r--;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230609225310260.png" alt="TLE了，悲"></p><h3 id="从中心扩散的双指针"><a href="#从中心扩散的双指针" class="headerlink" title="从中心扩散的双指针"></a>从中心扩散的双指针</h3><p>由于是回文串，最简单的回文串可以通过左右双指针来进行判断</p><p>但是这里是要求出<strong>所有的回文串</strong>同时还要是<strong>子串</strong>，子串连续的位置可以任意定，因此<strong>左右指针相向行驶的情况就不能覆盖到所有的子串</strong></p><p>针对这一个限制我们可以尝试<strong>从中心往外扩散的双指针技巧</strong></p><p>对于任意的回文串，长度可能是奇数或者是偶数，但是从回文串的<strong>中心</strong>（长度为偶数就认为有两个中心，其实都是相等的字符）出发一定都保证扩散的过程中是回文的。</p><p>因此我们可以<strong>枚举所有的中心点</strong>，<strong>在每一个中心点都找最长的奇数长度回文子串和偶数长度回文子串</strong>，不断更新记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-type">String</span>  <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> findPalindromeFromCenter(s, i, i + <span class="hljs-number">1</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> findPalindromeFromCenter(s, i, i);<br>s1=s1.length()&gt;s2.length()?s1:s2;<br>res=res.length()&gt;s1.length()?res:s1;<br>&#125;<br><span class="hljs-keyword">return</span>  res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在s中寻找以l和r为中心的最长回文串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">findPalindromeFromCenter</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br><span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;<br><span class="hljs-comment">//双指针向两边展开</span><br>l--;<br>r++;<br>&#125;<br><span class="hljs-comment">//此时l和r内部的串就是最长回文串（l和r端点不包含在内，因此是subString(l+1,r)）</span><br><span class="hljs-keyword">return</span> s.substring(l+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>如果说二分的应用场景适用于有序数组，看到有序数组就要想到二分。</p><p>那么前缀和这一个算法技巧则是适用于频繁出现  <strong>计算某个区间内元素的和</strong> 的情况</p><p>先用一个简单题来感受一下</p><h2 id="区域和检索，数组不可变"><a href="#区域和检索，数组不可变" class="headerlink" title="区域和检索，数组不可变"></a>区域和检索，数组不可变</h2><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变 - 力扣（LeetCode）</a></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230610104242146.png"></p><h3 id="最暴力的做法，可能会TLE"><a href="#最暴力的做法，可能会TLE" class="headerlink" title="最暴力的做法，可能会TLE"></a>最暴力的做法，可能会TLE</h3><p>最暴力的做法就是不用前缀和数组，每一次sumRange的时候都通过一轮遍历计算sum，之后相减得到结果，这种做法很明显是要O(n)的时间的</p><h3 id="前缀和数组做法"><a href="#前缀和数组做法" class="headerlink" title="前缀和数组做法"></a>前缀和数组做法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-comment">//前缀和数组</span><br><span class="hljs-type">int</span>[] preSum = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-comment">//初始化前缀和数组</span><br>preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; preSum.length; i++) &#123;<br>preSum[i] = nums[i-<span class="hljs-number">1</span>]+preSum[i - <span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>          <span class="hljs-comment">//O(1)的查询处理</span><br><span class="hljs-keyword">return</span> preSum[right+<span class="hljs-number">1</span>] - preSum[left];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意几个关键点：</p><ul><li>前缀和数组的长度要比原始数组长度多1个单位，<font color='red'>我们约定，preSum[i]记录的是从nums[0]-nums[i-1]的所有元素之和</font></li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230610110453891.png" alt="前缀和数组举例"></p><ul><li>在最终返回结果的时候，需要注意索引关系<ul><li>以left&#x3D;2,right&#x3D;4为例，实际上计算的是nums[2]~nums[4]之间所有的元素之和</li><li>对应的preSum[5]&#x3D;nums[0]~nums[4]</li><li>而preSum[2]&#x3D;nums[0]~nums[1]</li><li>preSum[5]-preSum[2]就是我们想要的结果，nums[2]~nums[4]</li><li>因此最终结果通过找出规律应当是<strong>preSum[right+1]-preSum[left]</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Leetcode</tag>
      
      <tag>Labuladong</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给未来的自己</title>
    <link href="/2023/04/26/%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
    <url>/2023/04/26/%E7%BB%99%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h1><ul><li>很多道理实际上你不懂，试着去实际做一做，收获会更多</li><li>少上点网，多些自己的思考，在网上寻求答案只会让自己变得更糟糕</li></ul><h1 id="关于抱怨"><a href="#关于抱怨" class="headerlink" title="关于抱怨"></a>关于抱怨</h1><p>抱怨本质上屁用没有，首先不能给你带来钱，更重要的是，<strong>并不能从本质上解决问题</strong></p><p>抱怨唯一的作用就在于，<strong>只会让别人觉得你是一个很爱抱怨的人</strong></p><p>当你向别人抱怨的时候，<strong>无形之中就强迫着别人，要和你一起唉声叹气</strong>，又或者是无形中给他人带来压力，要想一些语句来安慰你的情绪。实际上别人没有责任，也没有义务去听着你一起唉声叹气，更没责任要照顾你的情绪。</p><p><strong>实际上你只是把原本应当用来解决这个给你带来抱怨的问题的精力，全部花在了抱怨上。</strong></p><p>所以，遇到一些烂事屁事的时候，前几秒钟，先稳定情绪。之后，<strong>一切以如何解决这个屁事为导向，尽量站在旁观者的角度，分析这个问题。（怎么解决？如果下次再发生，如何避免？）</strong></p><h1 id="心态的调整：我允许"><a href="#心态的调整：我允许" class="headerlink" title="心态的调整：我允许"></a>心态的调整：我允许</h1><p>从知乎上看到的一段诗句，很喜欢，就记录了下来👇</p><p>我允许任何事情的发生。</p><p>我允许，</p><p>事情是如此的开始，</p><p>如此的发展，</p><p>如此的结局。</p><p>因为我知道，</p><p>所有的事情，都是因缘和合而来。</p><p>一切的发生，</p><p>都是必然。</p><p>若我觉得应该是另外一种可能，</p><p>伤害的，只是自己。</p><p>我唯一能做的，就是允许。</p><p>我允许别人如他所是。</p><p>我允许，</p><p>他会有这样的所思所想，</p><p>如此的评判我，如此的对待我。</p><p>因为我知道，</p><p>他本来就是这个样子。</p><p>在他那里，</p><p>他是对的。</p><p>若我觉得他应该是另外一种样子，</p><p>伤害的，只是自己。</p><p>我唯一能做的，就是允许。</p><p>我允许我有了这样的念头。</p><p>我允许，</p><p>每一个念头的出现，</p><p>任它存在，任它消失。</p><p>因为我知道，</p><p>念头本身并没有意义，</p><p>也与我无关，</p><p>它该来会来，</p><p>该走会走。</p><p>若我觉得不应该出现这样的念头，</p><p>伤害的，只是自己。</p><p>我唯一能做的，就是允许。</p><p>我允许我升起了这样的情绪。</p><p>我允许，</p><p>每一种情绪的发生，</p><p>任其发展，任其穿过。</p><p>因为我知道，</p><p>情绪只是身体上的觉受，本无好坏。</p><p>我越是抗拒，</p><p>它越是强烈。</p><p>若我觉得不应该出现这样的情绪，</p><p>伤害的，只是自己。</p><p>我唯一能做的，就是允许。</p><p>我允许我就是这个样子。</p><p>我允许，</p><p>我就是这样的表现。</p><p>我表现如何，就任我表现如何。</p><p>因为我知道，</p><p>外在是什么样子，只是自我的积淀而已。</p><p>真正的我，</p><p>智慧具足。</p><p>若我觉得应该是另外一个样子，</p><p>伤害的，只是自己。</p><p>我唯一能做的，就是允许。</p><p>我知道，我是为了生命在当下的体验而来。</p><p>在每一个当下时刻，</p><p>我唯一要做的，</p><p>就是全然地允许，</p><p>全然地经历，</p><p>全然地享受。</p><p>看，</p><p>只是看。</p><p>允许，一切如其所是。</p><h1 id="将Goal转化为Identity"><a href="#将Goal转化为Identity" class="headerlink" title="将Goal转化为Identity"></a>将Goal转化为Identity</h1><p><a href="https://www.bilibili.com/video/BV1sc411Q767">来源：别让琐碎填充你的生活：立刻改变，再适应改变</a></p><p>在生活中大大小小的选择和困难时，我们可以尝试将一个个的 Goal 在心中转化为基于自我认知的 Identity</p><p>比如，我要完成这个 ddl ：</p><ul><li>不是想着把他当作一个任务目标，<strong>虽然我很排斥他，但是我不得不硬着头皮去完成</strong>，因为他是一个关键的任务</li><li>而是告诉自己，我<strong>正擅长抽丝剥茧的处理问题，我很想看看我能从中学到什么东西</strong></li></ul><p>将当下工作中的目标和任务，转化成基于自身的认知肯定，不仅可以帮助我们更有动力的完成任务，也能保证在这一过程中经历失败和挫折时，也能有继续行动下去的勇气和毅力</p><ul><li>我的工作是开发，学习技术栈不是我的工作任务或者是目标，而是我把学习新的技术当作丰富自身的一种途径并且我享受不断学习新技术新知识的过程，我总能努力挤出时间来学习新的技术新的知识</li><li>我是一个积极上进的人，不会逃避困难并且非常乐意接纳它们</li></ul><p>思想的力量是很强大的，像这样将 Goal 转化为 Identity，可以让我们对自身进行更多的肯定和认知</p><p><strong>我们如何看待我们自己，决定了我们会成为什么样的人</strong></p><p>改变不一定要等到未来，我们可以立即改变，然后适应这种改变</p><h1 id="不要抬头而是埋头"><a href="#不要抬头而是埋头" class="headerlink" title="不要抬头而是埋头"></a>不要抬头而是埋头</h1><p><a href="https://www.bilibili.com/video/BV1e94y1A7ZB?t=4503.8">来源：Lunaticmosfet</a></p><p>很多时候我们觉得焦虑内耗，可能是因为我们都在抬头环顾四周</p><p><strong>当我们环顾世界的时候，世界是不会发生改变的</strong></p><p>只有当我们<strong>真正埋头去做一些事情</strong>的时候，在这个过程中也能察觉到世界的变化，我们自己的想法也会发生变化</p><p>很多时候我们关注自己的内心，实际上也是在关注这个世界，是一体两面的</p><p>可能因为个人性格原因，当面对一项比较重大的任务时，往往就会焦虑内耗，总是把事情往坏的方向去想</p><p>究其原因其实还是在于想得太多，但是做的太少。<strong>想都是问题，做才有答案</strong></p><p>本站的 Solgan 也是在时刻提醒自己 ———— 与其感慨路难行，不如马上出发</p>]]></content>
    
    
    <categories>
      
      <category>杂谈&amp;人生哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>夜读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初代XBOX|拆除法拉电容</title>
    <link href="/2023/01/29/%E5%88%9D%E4%BB%A3XBOX-%E6%8B%86%E9%99%A4%E6%B3%95%E6%8B%89%E7%94%B5%E5%AE%B9/"/>
    <url>/2023/01/29/%E5%88%9D%E4%BB%A3XBOX-%E6%8B%86%E9%99%A4%E6%B3%95%E6%8B%89%E7%94%B5%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="简单开箱"><a href="#简单开箱" class="headerlink" title="简单开箱"></a>简单开箱</h1><p>年前从一个出坑的老玩家手里收下了这台箱说全对号的初代 XBOX 和世嘉 DC，然后他之前也是分别收藏了两台初代 XBOX 和 DC，最近可能是打算出坑吧，就打算各留一台，刚好我也是那天搜索N64的时候，其实我那个时候是想买配件来的，因为 N64 机器到了，我想买点配件，刚好看他在卖这个 N64 的机器，然后后面也就顺带问了一下有没有卖 XBOX ，结果刚好他有，他就这个出给我了。</p><p>一台 DC 加一台初代 XBOX 配件什么全部都是齐全的，总共加起来算上包装，足足有快 9 公斤，我当时收这个到付的运费也是肉疼。</p><p>由于 DC 当年日烧有点严重，我打算做个漂白大保健，但是现在还在假期，快递还没上班，因此等着我把机器重新翻新了之后再来详细聊聊。（挖坑x2）</p><p>简单开箱，首先是箱子。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/80805317f5446cb9c8ab69e43b4ed9a61e5aa07c.jpg@942w_435h_progressive.webp" alt="满满的质感"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/97bda99b5ecaf81332a8f5e73a9ec2d22110846e.jpg@942w_435h_progressive.webp" alt="原装色差盒，输出初代 XBOX 顶配的画质必备"></p><p>通过这个色差盒，能够把初代 XBOX 最好的画质展现出来，初代XBOX支持 HDTV 最高支持 1080i 但是大部分情况下游戏都是 480P，少部分游戏会有 720P，但跟同时期的 PS2 &#x2F; NGC 比起来已经是画面最好的一个级别了。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/1dbcdea3b6e9941d600b34a784fde0e62c5a0b80.png@734w_1032h_progressive.webp" alt="初代的Duke公爵手柄"></p><p>我自己也买了两个初代 XBOX 的公爵手柄，当时是迎合欧美人的习惯来这个设计的一款手柄，所以普遍比较大，但是实际用了下来，个人感觉手感还是非常不错的。</p><h1 id="拆机拆除电容"><a href="#拆机拆除电容" class="headerlink" title="拆机拆除电容"></a>拆机拆除电容</h1><p>初代 XBOX 有一个非常致命的问题，微软当时设计这个主板的时钟记忆电池的时候，并没有采取像 PS2 &#x2F; DC 那样，采取这种纽扣电池&#x2F;电池座的这种设计，而是采取一个法拉电容来保存当前机器的时间，官方数据是大约在机器断电超过 4 个小时之后，这个电容就会完全释放，也就是说断电 4 个小时之后，如果没有接上电源的话，机器的时间就会自动回到生产的那一天，微软你做得好啊，这下真成时光机了（</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/fc82dbee3e92fb67eec351c9e5f80ea04df37662.png@942w_456h_progressive.webp" alt="顶盖打开，左边是光驱（据说当年甚至可以用PC的光驱来平替）右边是改装的硬盘"></p><p>上面说的这些并不是大问题，无非就是时间不对。但是这个电容会随着时间的推移而慢慢老化漏液，最终会腐蚀主板，有的严重的会导致机器主板完全被腐蚀，机器根本开不了机。可以算是所有初代XBOX机器的一个通病。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/faf9544bfeb3ab457207db3fa9602a591c1c8406.png@942w_395h_progressive.webp" alt="因为过年物流停业，硅脂只能下次再换"></p><p>好在我之前的这个卖家本身用的时间不长，大概也就10个小时左右的使用时间，改完机器之后可能就吃灰了，因此我这里下面需要进行机器的拆机加上电容拆除。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/e0c26ed48e0e3b51d0ec95c4d05482fe9d8c2c7f.png@942w_434h_progressive.webp" alt="可以看到红色圈出的这一块，已经有点腐蚀漏液了"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/92565f38cc0ac9fe9db0b743540c8c1d1106dff0.png@942w_464h_progressive.webp" alt="万恶之源"><br><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/99812789aebf1827717d85eea75e96ad252d1e52.jpg@942w_2042h_progressive.webp" alt="拆除之后用IPA清洗"></p><p>经过 IPA 多次清洗之后，顺带给机器做个大保健。</p><p>原样装回，开机。</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XBOX</tag>
      
      <tag>OG XBOX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wii U|破解指南#02</title>
    <link href="/2023/01/04/Wii-U-%E7%A0%B4%E8%A7%A3%E6%8C%87%E5%8D%97-02/"/>
    <url>/2023/01/04/Wii-U-%E7%A0%B4%E8%A7%A3%E6%8C%87%E5%8D%97-02/</url>
    
    <content type="html"><![CDATA[<h1 id="书接上回"><a href="#书接上回" class="headerlink" title="书接上回"></a>书接上回</h1><p>上回我们进行了 Wii U 的完整 Tiramisu Hack 流程，现在已经在主机中通过 Mii Maker 来运行 Homebrew Channel(下文简称 HBC )了，基本上所有机器的 Hack 都是通过在 CFW 的环境基础上运行 Homebrew Channel 的自制软件。</p><p>这期主要的任务如下：</p><ul><li><p>修改 vwii 系统，给 vwii 系统下刷一个 Homebrew Channel</p><ul><li>同时打上 vwii 特供的 cIOS （注意：如果你之前有自己破过 wii 主机的话就知道这一步也是必须的，<strong>但是给 wii 打的 cIOS 不能适用于 wiiu vwii，我们需要单独配置</strong>，按照教程走就好。</li><li>为 IOS 80 打上补丁。</li></ul><p>如果你觉得上述 cIOS 和 IOS 80 是什么不太懂，下文会有一个基本的讲解，只需要知道他是干什么的即可。</p></li><li><p>给 vwii 系统安装 PS1 模拟器 wiisxr ，<strong>运行我最喜欢的恶魔城月下夜想曲</strong>。</p></li></ul><h1 id="vwii-破解"><a href="#vwii-破解" class="headerlink" title="vwii 破解"></a>vwii 破解</h1><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><ul><li>把上回我们做好的 SD 卡继续拿来用，<strong>不需要格式化</strong>。</li><li>vwii homebrew channel (hbc一键安装工具)<ul><li>传送门 <a href="https://github.com/TheLordScruffy/vwii-compat-installer/releases">https://github.com/TheLordScruffy/vwii-compat-installer/releases</a></li><li>下载打包好的 <code>compact_installer.elf</code> 放入 <code>SD:/wiiu/apps/</code> 目录下</li></ul></li><li>d2x cIOS installer (cIOS 补丁安装)<ul><li>传送门 <a href="https://wiiu.hacks.guide/docs/files/d2x_cIOS_Installer.zip">https://wiiu.hacks.guide/docs/files/d2x_cIOS_Installer.zip</a></li><li>将压缩包所有内容拖到 SD 卡根目录，他会自动覆盖 merge.</li><li>之所以需要打 cIOS 主要是为了将系统的 IOS 改为自制的（已黑化），这是之后运行 USB Loader&#x2F;Wiiflow 等 homebrew 软件来读取 USB&#x2F;SD 中 wii 游戏的必要条件。</li></ul></li><li>Patched IOS 80 Installer IOS 80 补丁<ul><li>传送门 <a href="https://wiiu.hacks.guide/docs/files/Patched_IOS80_Installer_for_vWii.zip">https://wiiu.hacks.guide/docs/files/Patched_IOS80_Installer_for_vWii.zip</a></li><li>将压缩包所有内容拖到 SD 卡根目录，他会自动覆盖 merge.</li><li>这个主要是为了在vWii之下，将”非正版”的 Wiiware 或 VC 游戏从 SD 卡的频道启动，(不占用主机记忆体)，必须将官方的 IOS80 改成 cIOS80(否则无法自SD卡的频道启动)。</li><li>非法修改或者错写修改 IOS 80 会导致 vwii 变砖，但是按照步骤来是没有问题的，注意之后不要擅自修改，看到有修改的时候自己留个心眼。</li></ul></li></ul><h2 id="为vwii刷上HBC"><a href="#为vwii刷上HBC" class="headerlink" title="为vwii刷上HBC"></a>为vwii刷上HBC</h2><p>这部分很简单，有手就行。</p><ul><li>首先 Wii U 开机，按照上回的步骤此时应该已经自动进入 Tiramisu 的 CFW 环境了。</li><li>点击 Mii Maker 进入 Wii U 的 HBC.</li><li>这个时候在列表里找一个没有图标的可执行文件，这就是我们之前放入 apps 目录下的 compat_installer.elf ，点击 load 即可。</li><li>进入程序后按下 A 确认安装 HBC 到我们的 vwii 中。</li><li>当屏幕上出现 <code>Install succeeded</code> 之后按下 HOME 按键退回 Wii U Menu.</li><li>这个时候就已经装好了，我们可以点击 vwii 的图标进去，这个时候理论上应该已经有 HBC 的 Channel 图标了。</li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230104173622256.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230104173445036.png"></p><h3 id="我应该不是最后一个知道的"><a href="#我应该不是最后一个知道的" class="headerlink" title="我应该不是最后一个知道的"></a>我应该不是最后一个知道的</h3><p>在修改 vwii 的时候我才发现原来 Wii U 的 Gamepad 摄像头两边是自带红外摄像头的，理论上直接用 Gamepad 就可以通过  Wii 直柄来玩，任天堂你做的好啊（喜</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230104173641523.png"></p><h2 id="打上cIOS"><a href="#打上cIOS" class="headerlink" title="打上cIOS"></a>打上cIOS</h2><p>在开始之前请确保你的 SD 卡上除了 apps 文件夹外没有任何的 <code>.wad</code> 文件，按照我之前的步骤来不可能会有，如果有了并且出事情了概不负责（</p><p>步骤也很简单：</p><ul><li><p>首先开机，进 vwii.</p></li><li><p>启动 vwii 桌面上的 Homebrew Channel.</p></li><li><p>启动 d2x cIOS Installer.</p></li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230104173952002.png"></p><ul><li>进去之后按任意键开始，设定以下选项，千万不要选错：<ul><li>Select cIOS: <code>v10 beta52 d2x-v10-beta52-vWii</code></li><li>Select cIOS base: <code>56</code></li><li>Select cIOS slot: <code>249</code></li></ul></li><li>按下 <code>A</code> 键来安装。</li><li>设定以下选项：<ul><li>Select cIOS: <code>v10 beta52 d2x-v10-beta52-vWii</code></li><li>Select cIOS base: <code>57</code></li><li>Select cIOS slot: <code>250</code></li></ul></li><li>按下 <code>A</code> 键来安装。</li><li>设定以下选项：<ul><li>Select cIOS: <code>v10 beta52 d2x-v10-beta52-vWii</code></li><li>Select cIOS base: <code>58</code></li><li>Select cIOS slot: <code>251</code></li></ul></li><li>按下 <code>A</code> 键来安装。</li><li>三个全部打完了 按下 <code>B</code> 键来退出。</li></ul><h2 id="为-IOS-80-打补丁"><a href="#为-IOS-80-打补丁" class="headerlink" title="为 IOS 80 打补丁"></a>为 IOS 80 打补丁</h2><p>正如前文提到的，IOS 80 擅自修改或者是错写修改会使 vwii 变砖，<strong>同样如果你在打补丁的过程中主机断电了</strong>（比如突然来个停电什么的）那么 vwii 大概率是砖了（悲）。但是别急，在上篇文章中我们备份了 Wii U NAND，<strong>可以从 NAND 中提取 vwii 的 IOS 80 然后通过 FTP 连接 Wii U的方式覆盖打上 NAND 里的原厂 IOS 80 来救回</strong>，一般来说没人这么惨吧（</p><p>这部分也很简单，点几下的事情。</p><ul><li>上一步退出回到 vwii 的 HBC，选择 <code>Patched IOS 80 Installer</code> 启动。</li><li>阅读警告信息并等待 30 秒，不看警告，<strong>DO ANYTHING AT YOUR OWN RISK</strong>.</li><li>按下任意键来安装。</li><li>等一会，直到它提示 <code>IOS80 Installation is complete!</code>.</li><li>按下任意键来退出。</li></ul><h1 id="运行我最喜欢的月下夜想曲"><a href="#运行我最喜欢的月下夜想曲" class="headerlink" title="运行我最喜欢的月下夜想曲"></a>运行我最喜欢的月下夜想曲</h1><h2 id="材料准备-1"><a href="#材料准备-1" class="headerlink" title="材料准备"></a>材料准备</h2><ul><li>WiiSXR 和超频插件<ul><li>传送门 <a href="https://mega.nz/file/A3Yx0SjQ#6OIPdoQCptZZaW_462OUWOPVhimPUt5126xuwW3XQAo%E3%80%81">https://mega.nz/file/A3Yx0SjQ#6OIPdoQCptZZaW_462OUWOPVhimPUt5126xuwW3XQAo、</a></li><li>把压缩包的所有内容复制到 SD 卡根目录下</li></ul></li><li>PS1 BIOS<ul><li>SCPH 1001</li><li>传送门 <a href="https://hexrom.com/psx-playstation-bios-scph1001-bin/download/">https://hexrom.com/psx-playstation-bios-scph1001-bin/download/</a></li><li>把 <code>SCPH1001.bin</code> 放入 SD:&#x2F;wiisxr&#x2F;bios&#x2F; 目录下</li></ul></li><li>游戏 ROM<ul><li>把游戏 ROM 放在 SD:&#x2F;wiisxr&#x2F;isos 下</li></ul></li></ul><p>准备好之后就可以开机了</p><h2 id="超频插件"><a href="#超频插件" class="headerlink" title="超频插件"></a>超频插件</h2><p>由于 Wii U 默认进入 vwii 系统后 CPU 频率会将为 wii 的频率，在运行大多数的模拟器游戏都会有点卡顿，为了解决这一个问题，我们使用超频插件，超频插件同样也是通过 HBC 启动，进入 HBC 之后点击插件 load ，会重新退回 Wii U Menu，这个时候就已经解锁了 CPU 频率，进入 vwii 也是以 Wii U 的频率满速跑。</p><h2 id="Wii-U-主页的forwarder"><a href="#Wii-U-主页的forwarder" class="headerlink" title="Wii U 主页的forwarder"></a>Wii U 主页的forwarder</h2><p>在我们的材料准备中其实压缩包里还放了安装在 Wii U 上的快速定向 Channel，本质作用就是帮我们开启 vwii 中 HBC 对应的 wiisxr，效果就是我们如果安装在 Wii U 主机了之后，下次直接点击主页的 ticket 就可以一步到位，不用再去点 vwii 和 vwii 里的 HBC 启动 wiisxr 了。</p><p>forwarder 已经打包成 wup 格式，和安装 Wii U 原生游戏一样，我们这里直接通过 WUP Installer 来安装，注意这种 forwarder 一般都安装在 NAND 中。</p><h2 id="运行-WiiSXR"><a href="#运行-WiiSXR" class="headerlink" title="运行 WiiSXR"></a>运行 WiiSXR</h2><p>WiiSXR 是运行 Wii 上的 PS1 模拟器，在之前的材料准备中我们已经把 BIOS 和 ROM 都放在了 SD:&#x2F;wiisxr 下，现在我们直接进入 vwii 的 HBC 启动 wiisxr ，这里运行我最喜欢的恶魔城月下夜想曲。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230104185652842.png"></p><p>躺床上用 Gamepad 玩，同时电脑采集游戏画面就实现了~</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WiiU</tag>
      
      <tag>Hack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wii U|Reset Parental Control</title>
    <link href="/2023/01/02/Wii-U-Reset-Parental-Control/"/>
    <url>/2023/01/02/Wii-U-Reset-Parental-Control/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近托日本的 hxd 带了一台 Wii U，由于是二手物品，而且任天堂有一个万恶的家长监护机制，而这位原先的机主又恰好设置了家长监护XD，想要再去联系到对方确实不是很现实，而不解除家长监护机制就无法进行 Tiramisu 的 hack，因此这篇文章记录一下如何解除Parental Control 机制，nds&#x2F;3ds&#x2F;switch 同样适用。</p><p>由于我的 3ds&#x2F;switch 买的都是全新的，ndsi有幸没有被上锁，因此都没有试过用下面这个方法解锁，只有 Wii U 亲自试过，如果有成功的话可以说一声~</p><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><p>废话不多说，首先我们需要准备的是：</p><ul><li>设置&#x2F;查看你的 Wii U主机当前日期，这个可以不需要修改为最新的，只需要记住当前主机的日期即可。</li><li>我们这里用国外大佬制作的 mkey 来反向解密，具体逻辑这里不再赘述，有兴趣的可以<a href="https://github.com/dazjo/mkey">查看文档</a>，不想看的直接进入部署好的网站 <code>https://mkey.salthax.org</code> 即可。</li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230102220840536.png"></p><p>选择好你的机型，这里我们以 Wii U 为例</p><ul><li>切换到 Wii U ，按照如下步骤</li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230102221313013.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230102221405498.png"></p><p>记住这个 inquiry number 很重要，本来是需要提供给老任官方来解决的，但是这里我们直接解密这个salt key 得到 master number</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230102221446734.png"></p><p>返回到网站，输入我们的 inquiry number ，可以得到 master key</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230102221127209.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230102221601176.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230102221612885.png"></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WiiU</tag>
      
      <tag>Hack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode|Linked List Problem Sets</title>
    <link href="/2022/12/29/Leetcode-Linked-List-Problem-Sets/"/>
    <url>/2022/12/29/Leetcode-Linked-List-Problem-Sets/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文为 Labuladong 算法小抄 的第一章节，<strong>手把手刷链表算法</strong>的部分，个人刷题帖子。</p><p>每七天一更新，一天一题，第七天把前六天的题目重新回顾一遍。</p><h1 id="双指针技巧"><a href="#双指针技巧" class="headerlink" title="双指针技巧"></a>双指针技巧</h1><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">题目</a></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221229232848482.png"></p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>很简单的一个思路，本题的具体实现其实和 归并排序 中的 <code>merge</code> 部分一脉相承，是一个很经典的双指针算法。</p><p>两个指针指向两个升序链表，每一次我们都比较哪一个小，维护一个新的链表，把每一次指针指向的最小的那个元素加入到新维护的链表中即可。</p><p>最终记得和归并排序的 merge 处理一样，我们还需要进行扫尾操作</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> list1;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> list2;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dummy;<br><span class="hljs-keyword">while</span> (c1 != <span class="hljs-literal">null</span> &amp;&amp; c2 != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (c1.val &gt;= c2.val) &#123;<br>dummy.next = c2;<br>c2 = c2.next;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>dummy.next = c1;<br>c1 = c1.next;<br>&#125;<br>dummy = dummy.next;<br>&#125;<br><span class="hljs-keyword">if</span> (c1 == <span class="hljs-literal">null</span>) &#123;<br>dummy.next = c2;<br>&#125;<br><span class="hljs-keyword">if</span> (c2 == <span class="hljs-literal">null</span>) &#123;<br>dummy.next = c1;<br>&#125;<br><span class="hljs-keyword">return</span> res.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Leetcode</tag>
      
      <tag>Labuladong</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NJU-ICS|习题课#01</title>
    <link href="/2022/12/12/NJU-ICS-%E4%B9%A0%E9%A2%98%E8%AF%BE-01/"/>
    <url>/2022/12/12/NJU-ICS-%E4%B9%A0%E9%A2%98%E8%AF%BE-01/</url>
    
    <content type="html"><![CDATA[<h1 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h1><h2 id="编译和执行"><a href="#编译和执行" class="headerlink" title="编译和执行"></a>编译和执行</h2><p>程序最终由代码变为可执行文件实际上是跨越了<strong>编译、链接和加载执行</strong>这几个阶段的。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221207173428183.png"></p><ul><li><p>广义上的编译</p><ul><li>广义上的编译其实指的是 <code>.c</code> 文件转化为 <code>.o</code> 文件这一整套过程。</li></ul></li><li><p>狭义上的编译</p><ul><li>而狭义上的编译指的是 <code>.i</code> 转化为 <code>.s</code> 这一段过程，剩下的其实是由<strong>汇编器，连接器</strong>来实现的。</li></ul></li></ul><p>通过 <code>man gcc</code> 我们很容易得出编译器提供了一些接口来实现仅让编译停留在某一阶段的功能</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221212154136715.png"></p><p><strong>剧透</strong>：课程最后我们会知道其实 gcc 实际上确实是涵盖了所有的阶段，并且以<strong>外部指令</strong>的形式来调用。</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>首先我们先来看预编译阶段。</p><p>针对 c 语言而言，预编译阶段本质其实是<strong>字符串的拼接</strong>(和 shell 的设计哲学差不多)，又叫做<strong>元编程</strong>。</p><h3 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h3><h4 id="include另外的用处"><a href="#include另外的用处" class="headerlink" title="include另外的用处"></a>include另外的用处</h4><p><code>#include</code> 我们都知道是用来引用头文件的，在 c 语言中 <code>#include</code> 其实就是预编译阶段的一个例子，本质其实是把头文件的代码拼接到此文件中。</p><p>下面我们来看一个例子：</p><p><code>a.c</code> 主函数，引用了 <code>a.inc</code> 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<br>        <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;a.inc&quot;</span></span><br>        );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>a.inc</code> 内容如下，又引用了 b</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">#include <span class="hljs-string">&quot;b&quot;</span><br></code></pre></td></tr></table></figure><p><code>b</code> 内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;HelloWorld \n&quot;</span><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc a.c<br>.\a.exe<br>HelloWorld <br></code></pre></td></tr></table></figure><p>可以看到上述的一个例子其实就打破了我们对于 <code>#include</code> 最基本的认识，这正是预编译阶段的最好体现，并且在很多大型的工程项目中都会出现 <code>xxx.inc</code> 文件的情况其实本质就是被引用的外部文件内容。</p><h4 id="verbose"><a href="#verbose" class="headerlink" title="verbose"></a>verbose</h4><p>我们想要详细看下编译时候的各种过程，<code>gcc</code> 默认是不显示的，因此我们可以通过 <code>--verbose</code> (啰嗦)的方式来查看 gcc 的详细任务，其中包含了下面这段</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#include &quot;...&quot; search starts here:</span><br><span class="hljs-comment">#include &lt;...&gt; search starts here:</span><br> G:/DeveloperTools/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include<br> G:/DeveloperTools/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed<br> G:/DeveloperTools/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include<br></code></pre></td></tr></table></figure><p>这就解释了我们在预编译阶段的 <code>#include</code> 中到底头文件是从那里得来的。</p><h3 id="inclde-lt-gt-和-include””的区别"><a href="#inclde-lt-gt-和-include””的区别" class="headerlink" title="#inclde&lt;&gt;和#include””的区别"></a>#inclde&lt;&gt;和#include””的区别</h3><p><code>#include&lt;&gt;</code> 表示会引用系统自带的标准库文件，<code>#include&quot;&quot;</code> 除了系统的文件外还会包含指定目录的 c 文件。</p><h3 id="预编译一些有意思的code"><a href="#预编译一些有意思的code" class="headerlink" title="预编译一些有意思的code"></a>预编译一些有意思的code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> aa == bb</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码预编译之后执行的结果其实是 <code>Yes</code> ，这确实是很违背常理的一个操作。</p><p>具体原因在于 预编译的阶段其实本质上是变量的复制黏贴。</p><ul><li><code>#include</code> → 粘贴文件</li><li><code>aa</code>, <code>bb</code> → 粘贴符号</li></ul><p>而由于我们上面 <code>aa</code> 和 <code>bb</code> 没有定义，因此这里其实第一个 if 这儿是 <code>if 1==1</code> 其实是成立的，因此会输出 <code>Yes</code> 。</p><h3 id="宏展开"><a href="#宏展开" class="headerlink" title="宏展开"></a>宏展开</h3><p>宏展开其实有点递归嵌套的意思在里面，如果使用恰当，我们可以玩的很花。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAMES(X) \</span><br><span class="hljs-meta">  X(Tom) X(Jerry) X(Tyke) X(Spike)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(x) puts(<span class="hljs-string">&quot;Hello, &quot;</span> #x <span class="hljs-string">&quot;!&quot;</span>);</span><br>  NAMES(PRINT)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Hello, Tom!<br>Hello, Jerry!<br>Hello, Tyke!<br>Hello, Spike!<br></code></pre></td></tr></table></figure><p>因此我们可以得出：宏定义的本质其实是：反复粘贴，直到没有宏可以展开为止</p><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>其实 c 语言很接近我们的汇编语言了，基本上只需要用一些简单的代码转换即可看懂。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>将多个汇编完成的机器指令(二进制目标代码)拼接在一起</p><ul><li>自己写的其他文件中的 c 函数</li><li>系统库中提供的函数例如 printf</li></ul><h2 id="加载执行"><a href="#加载执行" class="headerlink" title="加载执行"></a>加载执行</h2><p>计算机本质其实是一个状态机。</p><p>C 代码的连续一段总能对应到一段连续的机器指令。</p><p>C 代码执行的状态总能对应到机器的状态。</p><p>代码、变量 (源代码视角) &#x3D; 地址 + 长度 (机器指令视角)</p><p>内存 &#x3D; 代码 + 数据 + 堆栈</p><p>C 里<strong>所有的数据都可以理解成是地址</strong> (指针) + <strong>类型 (对地址的解读)</strong></p><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="代码可读性"><a href="#代码可读性" class="headerlink" title="代码可读性"></a>代码可读性</h2><p>人类不可读版</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*signal(<span class="hljs-type">int</span> sig, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">int</span>)))(<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>人类可读版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">sighandler_t</span>)</span>;<br></code></pre></td></tr></table></figure><p>注意这里的 <code>typedef</code> 指的是起别名。</p><blockquote><p>Programs are meant to be read by humans and only incidentally for computers to execute. — <em>D. E. Knuth</em></p><p>程序首先是拿给人读的，其次才是被机器执行。</p></blockquote><h2 id="实现数字电路模拟器"><a href="#实现数字电路模拟器" class="headerlink" title="实现数字电路模拟器"></a>实现数字电路模拟器</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>假设我们现在要实现一个数字电路模拟器，一个最简单的数字累加功能。</p><p>因为是实现模拟器，数字电路本质其实就是 <strong>状态 (存储) 和 计算</strong>。因此我们的基本思路就是<strong>通过程序来模拟状态的存储以及计算</strong>。</p><p>我们都学过数字电路基础，因此这个地方通过真值表以及数逻知识可以很容易地得出如下的计算状态</p><ul><li>状态 &#x3D; 变量<ul><li><code>int X = 0, Y = 0;</code></li></ul></li><li>计算<ul><li><code>X1 = !X &amp;&amp; Y;</code></li><li><code>Y1 = !X &amp;&amp; !Y;</code></li><li><code>X = X1; Y = Y1;</code></li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面是最初的版本实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FORALL_REGS(_)  _(X) _(Y) </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOGIC           X1 = !X &amp;&amp; Y; \</span><br><span class="hljs-meta">                        Y1 = !X &amp;&amp; !Y;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE(X)       static int X, X##1;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UPDATE(X)       X = X##1;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(X)        printf(#X <span class="hljs-string">&quot; = %d; &quot;</span>, X);</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  FORALL_REGS(DEFINE);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 模拟时钟信号</span><br>    FORALL_REGS(PRINT); <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>); sleep(<span class="hljs-number">1</span>);<br>    LOGIC;<br>    FORALL_REGS(UPDATE);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实现的基本思路很简单，首先对于所有的寄存器都先初始化，<strong>之后每一次时钟信号来临的时候，先打印出当前的状态，然后模拟计算，之后更新状态，以此重复操作。</strong></p><h3 id="新增需求"><a href="#新增需求" class="headerlink" title="新增需求"></a>新增需求</h3><p>我们现在要新增一个需求，为了实现这个需求，新增了一个标识位 Z 来表示开关的状态。</p><p>这里其实就体现出了上面代码的可维护性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FORALL_REGS(_)  _(X) _(Y) _(Z)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOGIC           X1 = !X &amp;&amp; Y; \</span><br><span class="hljs-meta">                        Y1 = !X &amp;&amp; !Y; \</span><br><span class="hljs-meta">                        Z1 = !Z</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE(X)       static int X, X##1;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UPDATE(X)       X = X##1;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT(X)        printf(#X <span class="hljs-string">&quot; = %d; &quot;</span>, X);</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  FORALL_REGS(DEFINE);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 模拟时钟信号</span><br>    FORALL_REGS(PRINT); <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>); sleep(<span class="hljs-number">1</span>);<br>    LOGIC;<br>    FORALL_REGS(UPDATE);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要求改 <code>FORALL_REGS()</code> 中以及 <code>LOGIC</code> 中的定义即可完成新的需求的迭代。</p><h2 id="实现-YEMU-全系统模拟器"><a href="#实现-YEMU-全系统模拟器" class="headerlink" title="实现 YEMU 全系统模拟器"></a>实现 YEMU 全系统模拟器</h2><h3 id="最小的计算机"><a href="#最小的计算机" class="headerlink" title="最小的计算机"></a>最小的计算机</h3><p>在书上其实提到了一个<strong>最简单的计算机系统</strong>，他只有五个 <strong>8 bit</strong> 的寄存器，一个 程序计数器，一个 <strong>16 byte</strong> 的内存。</p><p>同时它定义的指令集如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">       <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>   <span class="hljs-number">3</span> <span class="hljs-number">2</span>   <span class="hljs-number">1</span> <span class="hljs-number">0</span><br>mov   [<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>] [ rt] [ rs]<br>add   [<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>] [ rt] [ rs]<br>load  [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>] [   addr  ]<br>store [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>] [   addr  ]<br></code></pre></td></tr></table></figure><p>虽然是一个很简单很低配置的计算机，实际中根本不可能存在，但是我们依然可以利用它来学习 <strong>一个计算机是如何运作的</strong>。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221212222446581.png"></p><ul><li>每一次其实都是从 PC 中取出指令的地址。</li><li>然后执行指令，具体<strong>内存中指令的内容需要对照我们的指令集进行查找解释</strong>(一般来说是需要对寄存器或是内存进行数据操作的)。</li><li>然后执行完了更新我们的寄存器数据，等待下一个时钟周期。</li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221212222603095.png" alt="课件中的提炼"></p><p>理论上我们可以 <strong>枚举</strong> 出这个最简单的计算机中所有的状态取值，因为每一位的 bit 我们都可以枚举出来。</p><h3 id="如何用代码来实现"><a href="#如何用代码来实现" class="headerlink" title="如何用代码来实现"></a>如何用代码来实现</h3><p>内存是 16 byte，算上 PC 一共有 5 个寄存器，因此我们的内存模型最多只需要分配 21 bytes &#x3D; 168 bits 的空间。</p><p>我们很容易写出如下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NREG 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NMEM 16</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint8_t</span> u8; <span class="hljs-comment">//uint8_t 指的是我们无论是在 64/32 位的机器上都可以得到这个类型的数据为无符号 8bit 的整数数据</span><br><span class="hljs-comment">//然后我们定义了 8 bit 长度的 pc，寄存器数组 R（长度为4），内存数组 M （长度为16），单位都是 8bit 也就是 byte</span><br>u8 pc = <span class="hljs-number">0</span>, R[NREG], M[NMEM] = &#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>补充：</p><ul><li>对于现在的计算机系统，8 bit 我们需要知道有一个和他一样长度的数据是 <code>char</code> </li><li>除了 <code>uint8_t</code> ，在后续的框架代码中其实我们还会大量看见 <code>intptr</code> 这个类型，这个类型的意思指的是我们的整数类型数据的指针<strong>承接形式</strong>，因为我们都知道在 64&#x2F;32 位机器上，指针类型分别是 8&#x2F;4 字节的，如果我们简单地直接用 int 来承接指针类型，在64位机器上就会直接溢出，因此 PPT 这里的 quiz 其实答案就是应该使用 <code>intptr</code> 这个数据类型。这也解释了其实 <code>intptr</code> 这个数据类型本质上其实在 C 语言中就是数据+我们对指针类型的解读。</li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221228221800127.png" alt="PPT上的Quiz"></p><p>但是这个代码的可维护性还是不太好，比如说我们新增了一个寄存器，这个时候就需要改动 <code>NREG</code> 这段数据，因此我们这里可以简单重构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这里通过枚举的形式列出所有的寄存器</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> RA, R1, ..., PC &#125;;<br><span class="hljs-comment">//数组初始化的时候对于每一个位置我们都清楚其内容意义</span><br>u8 R[] = &#123;<br>  [RA] = <span class="hljs-number">0</span>,<br>  [R1] = <span class="hljs-number">0</span>,<br>  ...<br>  [PC]  = init_pc,<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pc (R[PC]) <span class="hljs-comment">// 把 PC 也作为寄存器的一部分</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NREG (sizeof(R) / sizeof(u8)) <span class="hljs-comment">//这里其实也很巧妙的处理了寄存器个数，让我们的整个寄存器数组大小除以每一个寄存器都是 8bit 的大小来间接计算出寄存器的个数</span></span><br></code></pre></td></tr></table></figure><p>这里就引出了我们软件在设计的过程中代码应该如何写便于维护</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230102205826707.png"></p><h3 id="模拟指令执行"><a href="#模拟指令执行" class="headerlink" title="模拟指令执行"></a>模拟指令执行</h3><p>我们之前已经强调很多次了，其实计算机本质就是在时钟信号的驱动下，根据(Memory,Register)来更新系统的状态。</p><ul><li>取指令 (fetch): 读出 <code>M[R[PC]]</code> 的一条指令</li><li>译码 (decode): 根据指令集规范解析指令的语义 (顺便取出操作数)</li><li>执行 (execute): 执行指令、运算后写回寄存器或内存</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (!is_halt(M[pc])) &#123;<br>    idex(); <span class="hljs-comment">//核心所在</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>这里的 idex() 其实就是上面的三个步骤，我们以课件中最简单的计算机为例来学习。</p><p>我们很容易可以写出如下的 <code>if-else</code> 判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">idex</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> ((M[pc] &gt;&gt; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//高四位为0000</span><br>    R[(M[pc] &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>] = R[M[pc] &amp; <span class="hljs-number">3</span>];<span class="hljs-comment">//mov操作  rt(低四位的高两位) = rs(低四位的低两位)</span><br>    pc++;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((M[pc] &gt;&gt; <span class="hljs-number">4</span>) == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//高四位为0001</span><br>    R[(M[pc] &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>] += R[M[pc] &amp; <span class="hljs-number">3</span>];<span class="hljs-comment">//add操作 rt(低四位的高两位) += rs(低四位的低两位)</span><br>    pc++;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((M[pc] &gt;&gt; <span class="hljs-number">4</span>) == <span class="hljs-number">14</span>) &#123;<span class="hljs-comment">//高四位为1110</span><br>    R[<span class="hljs-number">0</span>] = M[M[pc] &amp; <span class="hljs-number">0xf</span>]; <span class="hljs-comment">//read操作</span><br>    pc++;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((M[pc] &gt;&gt; <span class="hljs-number">4</span>) == <span class="hljs-number">15</span>) &#123;<span class="hljs-comment">//高四位为1111</span><br>    M[M[pc] &amp; <span class="hljs-number">0xf</span>] = R[<span class="hljs-number">0</span>];<span class="hljs-comment">//store操作</span><br>    pc++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个代码看着实在是太折磨了，完全没有可维护性而言。</p><p>我们可以抽取出公共部分，通过变量命名追加自然语言来提升代码的可读性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">idex</span><span class="hljs-params">()</span> &#123;<br>  u8 inst = M[pc++];<span class="hljs-comment">//获取指令数据</span><br>  u8 op = inst &gt;&gt; <span class="hljs-number">4</span>;<span class="hljs-comment">//获取指令中的操作符数据</span><br>  <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0x0</span> || op == <span class="hljs-number">0x1</span>) &#123;<span class="hljs-comment">//如果为mov/add</span><br>    <span class="hljs-type">int</span> rt = (inst &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>, rs = (inst &amp; <span class="hljs-number">3</span>);<span class="hljs-comment">//抽取出rt和rs内容</span><br>    <span class="hljs-keyword">if</span>      (op == <span class="hljs-number">0x0</span>) R[rt]  = R[rs];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0x1</span>) R[rt] += R[rs];<br>  &#125;<br>  <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0xe</span> || op == <span class="hljs-number">0xf</span>) &#123;<br>    <span class="hljs-type">int</span> addr = inst &amp; <span class="hljs-number">0xf</span>;<br>    <span class="hljs-keyword">if</span>      (op == <span class="hljs-number">0xe</span>) R[<span class="hljs-number">0</span>]    = M[addr];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0xf</span>) M[addr] = R[<span class="hljs-number">0</span>];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者我们可以巧妙利用 c 的 <strong>union</strong> ,<strong>bitfield</strong> 以及 <strong>struct</strong> 来模拟两种不同的instruction解释行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">inst</span> &#123;</span><br>  <span class="hljs-comment">//从低到高依次通过bitfield来获取数据</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> u8 rs  : <span class="hljs-number">2</span>, rt: <span class="hljs-number">2</span>, op: <span class="hljs-number">4</span>; &#125; rtype;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> u8 addr: <span class="hljs-number">4</span>,        op: <span class="hljs-number">4</span>; &#125; mtype;<br>&#125; <span class="hljs-type">inst_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RTYPE(i) u8 rt = (i)-&gt;rtype.rt, rs = (i)-&gt;rtype.rs;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MTYPE(i) u8 addr = (i)-&gt;mtype.addr;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">idex</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">inst_t</span> *cur = (<span class="hljs-type">inst_t</span> *)&amp;M[pc];<br>  <span class="hljs-keyword">switch</span> (cur-&gt;rtype.op) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0b0000</span>: &#123; RTYPE(cur); R[rt]   = R[rs];   pc++; <span class="hljs-keyword">break</span>; &#125;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0b0001</span>: &#123; RTYPE(cur); R[rt]  += R[rs];   pc++; <span class="hljs-keyword">break</span>; &#125;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0b1110</span>: &#123; MTYPE(cur); R[RA]   = M[addr]; pc++; <span class="hljs-keyword">break</span>; &#125;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0b1111</span>: &#123; MTYPE(cur); M[addr] = R[RA];   pc++; <span class="hljs-keyword">break</span>; &#125;<br>  <span class="hljs-keyword">default</span>: panic(<span class="hljs-string">&quot;invalid instruction at PC = %x&quot;</span>, pc);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wii U|破解指南#01</title>
    <link href="/2022/12/10/WiiU-%E7%A0%B4%E8%A7%A3%E6%8C%87%E5%8D%97-01/"/>
    <url>/2022/12/10/WiiU-%E7%A0%B4%E8%A7%A3%E6%8C%87%E5%8D%97-01/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本教程主要基于 <code>wiiu.hacks.guide</code> 进行中文翻译和编写，仅供学习参考交流。</p><p>通过最新版本的 <code>提拉米苏</code> 破解的方式安装自制程序和自制固件。</p><h2 id="mod之后可以做什么"><a href="#mod之后可以做什么" class="headerlink" title="mod之后可以做什么"></a>mod之后可以做什么</h2><ul><li>对你的游戏使用金手指。</li><li>为许多<strong>游戏备份、修改和还原存档</strong>。（虽然是基本操作，但是存档党狂喜）</li><li>使用模拟器来玩旧主机游戏：RetroArch 或者其他独立的模拟器。（不得不说 WiiU 的GamePad 的设计非常适合用来以 Handled 模式运行 Retro 的游戏）</li><li>玩跨区游戏。(region free 正版玩家狂喜)</li><li>将你的 Wii U 游戏光盘里的游戏转换为可以在 Wii U 内部或外部存储器安装的格式。(游戏 ROM dump 正版玩家狂喜)</li></ul><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><ul><li>一台最新系统版本固件的 任何区域的 可以联网的 WiiU 主机<ul><li>美版 5.5.6</li><li>其他区域 5.5.5</li></ul></li><li>一张SD卡<ul><li>不同于 Wii 仅支持 SDHC , WiiU 支持 SDHC 和 SDXC 因此理论上 SD 卡可以保留很大的内容，文档推荐是说 32 就够用了，这里我用 64GB TF 卡 + SD 卡套转换器。</li></ul></li><li>把文章全部看完的耐心</li></ul><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>遵循本教程最终可以将自制固件安装到 WiiU 上并且开机自动引导提拉米苏固化（可选）。</p><h1 id="SD卡准备"><a href="#SD卡准备" class="headerlink" title="SD卡准备"></a>SD卡准备</h1><h2 id="需要下载哪些文件"><a href="#需要下载哪些文件" class="headerlink" title="需要下载哪些文件"></a>需要下载哪些文件</h2><ul><li>提拉米苏 mod 的最新文件<ul><li><a href="https://tiramisu.foryour.cafe/">提拉米苏网址</a></li><li>点击下载</li></ul></li><li>准备用于 EnvironmentLoader 的必要文件<ul><li><a href="https://github.com/marco-calautti/SigpatchesModuleWiiU/releases/tag/1.2">release 地址</a></li><li>下载 <code>01_sigpatches.rpx</code> 即可</li></ul></li></ul><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>1)格式化SD卡为 <strong>FAT32</strong> 格式，请先备份关键数据。</p><p>2)把提拉米苏 mod 的最新文件包解压缩至 <strong>SD 卡根目录下</strong>。</p><p>3)将 <code>01_sigpatches.rpx</code> 文件拷贝到 <code>SD卡根目录/wiiu/environments/tiramisu/modules/setup</code>.</p><blockquote><p><strong>注意</strong></p><p>如果出现了要求覆盖当前文件，一路点击确定就行。</p></blockquote><h1 id="浏览器漏洞"><a href="#浏览器漏洞" class="headerlink" title="浏览器漏洞"></a>浏览器漏洞</h1><h2 id="利用WiiU浏览器漏洞"><a href="#利用WiiU浏览器漏洞" class="headerlink" title="利用WiiU浏览器漏洞"></a>利用WiiU浏览器漏洞</h2><p>1)把上一步制作好的 SD 卡插入 WiiU 主机。</p><p>2)启动 WiiU 的浏览器，访问 <code>wiiuexploit.xyz</code> 这个网站。</p><p>3)在浏览器打开的界面中点击 <code>Run Exploit!</code> 并且长按 <code>B</code> 按键直到出现一个菜单，如果你的 Wii U 卡住不动或白屏了，请等一会。 如果什么都没有发生，那就重启主机后<a href="https://en-americas-support.nintendo.com/app/answers/detail/a_id/1507/~/how-to-delete-the-internet-browser-history">重置浏览器保存的数据</a>，然后再来一次。</p><h1 id="制作-NAND-备份"><a href="#制作-NAND-备份" class="headerlink" title="制作 NAND 备份"></a>制作 NAND 备份</h1><h2 id="目的和必要知识"><a href="#目的和必要知识" class="headerlink" title="目的和必要知识"></a>目的和必要知识</h2><p>备份 NAND 是为了以防万一，所以不要跳过这些步骤。</p><p>主要是用于 WiiU 软砖之后的备份恢复。</p><p>从某一台设备导出的 NAND 备份是<strong>那一台设备所独有的</strong>。恢复其他主机的 NAND 备份 <strong>不能救砖</strong>。</p><p>恢复 NAND 备份需要额外的设备和一点微焊技能。</p><p>Wii U NAND 备份的大小取决于你的设备型号 8GB&#x2F;32GB 我这里是日版 Basic Set 的 8GB 主机。为了备份 NAND，你需要准备一张大于你设备 NAND 对应设备型号存储 的 SD 卡。</p><p>如果你的 SD 卡没有如此大的空间，你在备份的时候可以选择跳过 <code>MLC</code> 部分，其中保存的文件是你的游戏和游戏存档，救砖不需要恢复这些东西。</p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>1)在上一步跳出的菜单中点击 <code>nanddumper</code> 之后点击 <code>A</code> 确认键启动。</p><p>2)通过十字键来配置以下内容：</p><ul><li>Dump SLC: <strong>yes</strong></li><li>Dump SLCCMPT: <strong>yes</strong></li><li>Dump MLC: **可选 **(保存的文件是你的游戏和游戏存档)</li><li>Dump OTP: <strong>yes</strong></li><li>Dump SEEPROM: <strong>yes</strong></li></ul><p>3)上述设置全部都配置完毕之后按下 <code>A</code> 确认导出。</p><p>4)完成后，将 Wii U 关机，然后把 SD 卡从 WiiU 上拔出并插入电脑。</p><p>5)此时你应该确认你的 SD 卡中出现了如下的文件，其名称对应配置中出现的选项，顾名思义。</p><ul><li><code>slc.bin</code></li><li><code>slccmpt.bin</code></li><li><code>seeprom.bin</code></li><li><code>otp.bin</code></li><li><code> mlc.bin.part</code>(如果你选择了 Dump MLC 也还应该多个这样的文件)</li></ul><p>6)这些都是重要资料，建议备份到 <strong>硬盘 网盘</strong> 等多份留档以备不时之需。</p><p>7)备份完毕可以删除原先的文件来腾出 SD 卡的空间。</p><h1 id="安装-PayloadLoader"><a href="#安装-PayloadLoader" class="headerlink" title="安装 PayloadLoader"></a>安装 PayloadLoader</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>现在你已经有了 NAND 的备份，所以可以乱搞了（划掉），现在我们向系统安装 <code>PayloadLoader </code>。</p><p>你可以简单理解为，安装 <code>PayloadLoader</code> 可以让我们通过访问 WiiU 自带的 <code>Health and Safety Information 健康和安全信息</code> 程序来进入到 <strong>提拉米苏</strong> 破解程序。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221210143522148.png" alt="WiiU 自带的 Health and Safety Information 程序"></p><h2 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>1)将内存卡从电脑上拔出并插回 WiiU 主机中。</p><p>2)访问上次提到的那个魔法网站，但是与之前不同的是，这一次点击之后长按 <code>X</code> 按键进入 <code>Environment Loader </code> 菜单。</p><p>3)将光标移动至 <code>installer</code> , 按下 <code>A</code> 启动。</p><p>4)再次按下 <code>A</code> 以确认是否可以安装 <code>PayloadLoader</code>.</p><ul><li>它现在应该告诉您可以将 PayloadLoader 安装到 <code>健康和安全信息</code> 应用程序上。</li></ul><p>5)按下 <code>A</code> 选择 <code>Install / Update</code>.</p><p>6)系统会询问您是否确定要安装 PayloadLoader。使用方向键选择 <code>install</code> 并按 <code>A</code> 确认。</p><p>7)安装完毕之后再次按下 <code>A</code> 关闭机器。</p><h1 id="开机自启固化"><a href="#开机自启固化" class="headerlink" title="开机自启固化"></a>开机自启固化</h1><h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><p>相信有一定理解能力的朋友会发现，这样子是不是每次进入提拉米苏破解都需要启动一次自带的 &#96;&#96;Health and Safety Information 健康和安全信息&#96; 软件呢，因此下面我们进行配置，最终实现每次开机启动时自动启动 <strong>提拉米苏</strong> 进行固化。</p><blockquote><p><strong>注意</strong></p><p>开机自启是一个可选操作，如果你确实享受每次开机都点一下 <code>Health and Safety Information 健康和安全信息</code> 的乐趣，那么可以直接跳到本文的下一章。</p></blockquote><h2 id="具体步骤-2"><a href="#具体步骤-2" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>1)开机进入 WiiU 主菜单，启动 <code>Health and Safety Information 健康和安全信息</code> 应用程序并按住 X 打开 <code> Environment Loader</code> 菜单。</p><p>2)将光标移至 <code>installer</code> 并按下 A 启动。</p><p>3)点击 A 选择 <code>Check</code>。</p><p>4）选择 <code>Boot options</code> 选项。</p><p>5)系统将询问是否要切换引导时启动的 title ，这里当然需要，我们按 A 选择切换到 PayloadLoader.</p><p>6)上述过程完毕之后按下 A 关闭主机。</p><p>至此，PayloadLoader 现在将在每次启动 WiiU 主机时自动启动。</p><blockquote><p>后续修改启动 WiiU 时自动引导所启动的 title 的方法：</p><p>在启动主机的同时按住游戏手柄上的 start(+)。</p><p>之后将光标悬停在想要自动启动的 title 上，然后按 Y 按钮将其设置为自动启动 title.</p><p>最后按下 A 启动对应的 title.</p></blockquote><h1 id="最终配置-自制程序"><a href="#最终配置-自制程序" class="headerlink" title="最终配置+自制程序"></a>最终配置+自制程序</h1><h2 id="最终配置"><a href="#最终配置" class="headerlink" title="最终配置"></a>最终配置</h2><p>现在我们已经安装了 PayloadLoader、Environment Loader 和 提拉米苏，我们将完成最终的设置。</p><p>1)启动你的 WiiU ,由于我们之前已经设置了开机自启固化(如果你之前没有设置开机自启<code>Health and Safety Information 健康和安全信息</code> 则需要每次手动都启动这个应用程序 )，因此这里会自动进入到 <code>Environment Loader</code>.</p><p>2)定位到 <code>tiramisu</code> 之后，按 Y 将其设置为默认环境，然后按 A 启动 Tiramisu.</p><ul><li>这里可能会看到一个红色警告，意思是没阻止自动更新，这里按 A 继续。我们将在下面的 <strong>关闭更新</strong> 部分中阻止自动更新。</li><li>以后要打开 Environment Loader，在启动 Wii U 时按住 X。</li></ul><p>3)在 <code>Tiramisu Boot Selector</code> 上，<code>WiiU Menu</code> 应该已经被选中，按 Y 将其设置为默认的自动启动选项，然后按 A 启动 WiiU 菜单。</p><ul><li>以后要打开 <code>Tiramisu Boot Selector</code>，在启动 WiiU 时按住 start(也就是+号)。</li></ul><h2 id="自制程序"><a href="#自制程序" class="headerlink" title="自制程序"></a>自制程序</h2><p>当我们进入到提拉米苏破解的环境之后，此时的 <code>Mii Maker</code> 已经被替换为了 <code>Homebrew Launcher</code> ，我们可以通过原先系统自带的 <code>Mii Maker</code> 来进入到 Homebrew Launcher 中运行和安装自制程序。</p><p>当然如果想要运行真正的 <code>Mii Maker</code> 我们只需要在进入 <code>Homebrew Launcher</code> 之后按下 <code>Home</code> 按键即可。</p><h3 id="一些推荐的自制程序"><a href="#一些推荐的自制程序" class="headerlink" title="一些推荐的自制程序"></a>一些推荐的自制程序</h3><p>手册这里推荐了三个很有用的自制程序(Homebrew Apps)</p><ul><li><strong>SaveMii Mod WUT Port</strong> WiiU 本体和 vWii(虚拟 Wii 设备)的存档备份管理软件。</li><li><strong>Bloopair</strong> 将当下主流的其他平台手柄模拟为 WiiU Pro 手柄 (牛头人狂喜)。</li><li><strong>Homebrew Appstore</strong> 自制程序应用市场。</li></ul><h3 id="具体下载地址"><a href="#具体下载地址" class="headerlink" title="具体下载地址"></a>具体下载地址</h3><ul><li><a href="https://wiiubru.com/appstore/zips/SaveMiiModWUTPort.zip">最新版本的SaveMii Mod WUT Port</a>.</li><li><a href="https://github.com/GaryOderNichts/Bloopair/releases">Release页面获取最新的 Bloopair</a>.</li><li><a href="https://github.com/fortheusers/hb-appstore/releases/">HB Appstore (只需要下 wiiu-extracttosd.zip 这个文件即可)</a>.</li></ul><h3 id="安装自制程序"><a href="#安装自制程序" class="headerlink" title="安装自制程序"></a>安装自制程序</h3><p>和 Wii 的自制系统一样，WiiU 安装自制应用程序也是统一安装(或者说是指定位置放置)在 SD 卡中即可。</p><ul><li><code>SaveMii</code>: 将下载下的压缩包解压至 SD 卡根目录。</li><li><code>Bloopair</code>: 将压缩包内的 <code>30_bloopair.rpx</code> 复制到 SD 卡根目录下的 <code>wiiu/environments/tiramisu/modules/setup/</code> 文件夹，将 <code>wiiu</code> 文件夹复制 (覆盖) 到 SD 卡的根目录。</li><li><code>HB Appstroe</code>: 将下载下的压缩包解压至 SD 卡根目录。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，WiiU 的初步配置到此结束，做一个简单总结。</p><p>本篇文章通过浏览器漏洞安装提拉米苏 , PayloadLoader 破解程序并加入开机自启固化，同时备份机器的 NAND 防止软砖，最后安装了几个很有用的自制程序完成了初步的破解。</p><p>下一篇预计整理：</p><ul><li>ROM 安装</li><li>禁用系统更新</li></ul>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WiiU</tag>
      
      <tag>Hack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NJU-ICS|PA1.0</title>
    <link href="/2022/11/25/NJU-ICS-PA1-0/"/>
    <url>/2022/11/25/NJU-ICS-PA1-0/</url>
    
    <content type="html"><![CDATA[<h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><h2 id="NEMU是什么"><a href="#NEMU是什么" class="headerlink" title="NEMU是什么"></a>NEMU是什么</h2><p>首先我们需要知道我们这个实验真正需要做什么————实现一个 FC 模拟器(双 厨 狂 喜)，他是一款经过简化的全系统模拟器。</p><p>NEMU 是基于开源的 FC 模拟器项目 FCEUX 移植而来，在之前 Lab0 的体验中其实我们已经装好了 FCEUX 这个项目的（同时官方也很贴心地为我们将其加入到了 <code>.gitignore</code> 文件中，可以进去体验一下，这里我们就以移植过后的 <code>fceux-am</code> 这个项目为例先进行一个 RTFM 初步跑起来一个 FC 游戏，至于游戏这块，我选择小时候最喜欢玩的 <strong>加纳战机</strong> 作为 ROM（仅为学习交流使用，不要问我哪里找的XD）。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221125005619509.png" alt="运行体验"></p><p>初步的体验可以说是一切正常，而且不知道为啥总感觉 Linux 上玩画质更好（</p><h2 id="运行的额外工作"><a href="#运行的额外工作" class="headerlink" title="运行的额外工作"></a>运行的额外工作</h2><h3 id="检查按键"><a href="#检查按键" class="headerlink" title="检查按键"></a>检查按键</h3><p>为了检查按键我们这里用一个讲义中同宫的新的子项目 <code>am-kernels</code> 来检查测试按键。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ics2022<br>bash init.sh am-kernels<br><span class="hljs-built_in">cd</span> am-kernels/tests/am-tests<br>make ARCH=native mainargs=k run<br></code></pre></td></tr></table></figure><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221125011127752.png"></p><p>这个其实就是一个键盘 IO 的测试工具，按下什么就显示什么，感觉可以抽时间单独研究一下代码。</p><h3 id="多线程编译"><a href="#多线程编译" class="headerlink" title="多线程编译"></a>多线程编译</h3><p>由于 makefile 默认是采用单线程进行编译的，因此编译构建的速度可能会比较慢，但是由于我们现在基本都是多核 CPU 的时代了，因此想要提升速度可以通过在 make 的时候追加 <code>-j核心数</code> 的这个参数来采用多个线程进行编译加快速度。</p><p>比如我这里是 2 core 的处理器，因此这里可以调动双线程进行编译加快速度。</p><p>同时为了查看到底加快了多少，我们可以在 make 命令的前面追加一个 time 命令，这个 time 会对我们 make 的时间进行统计</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">time make -j2 ARCH=native run mainarg=GANA<br></code></pre></td></tr></table></figure><h3 id="使用缓存进行编译加快速度"><a href="#使用缓存进行编译加快速度" class="headerlink" title="使用缓存进行编译加快速度"></a>使用缓存进行编译加快速度</h3><p>此外我们发现因为程序的源码本身没有改变，那么编译出来的结果大多数情况下也是不会发生改变的，那么我们是不是可以这样：如果发现编译的结果和之前一样，我们就直接取出来，不再进行长时间工程项目的编译。</p><p>这其实就是 <strong>缓存cache</strong> 的思想，在后续我们学习 CS 中会被广泛的运用上。</p><p>讲义中提到了 ccache 这个缓存库，我们可以安装进行体验一下。</p><h2 id="所以NEMU到底是什么"><a href="#所以NEMU到底是什么" class="headerlink" title="所以NEMU到底是什么"></a>所以NEMU到底是什么</h2><p>讲义中给出了这三个例子进行比较，他们分别是</p><ul><li>在GNU&#x2F;Linux中运行Hello World程序</li><li>在GNU&#x2F;Linux中通过红白机模拟器玩马里奥</li><li>在GNU&#x2F;Linux中通过NEMU运行Hello World程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">                         +---------------------+  +---------------------+<br>                         |     Super Mario     |  |    <span class="hljs-string">&quot;Hello World&quot;</span>    |<br>                         +---------------------+  +---------------------+<br>                         |    Simulated NES    |  |      Simulated      |<br>                         |       hardware      |  |       hardware      |<br>+---------------------+  +---------------------+  +---------------------+<br>|    <span class="hljs-string">&quot;Hello World&quot;</span>    |  |     NES Emulator    |  |        NEMU         |<br>+---------------------+  +---------------------+  +---------------------+<br>|      GNU/Linux      |  |      GNU/Linux      |  |      GNU/Linux      |<br>+---------------------+  +---------------------+  +---------------------+<br>|    Real hardware    |  |    Real hardware    |  |    Real hardware    |<br>+---------------------+  +---------------------+  +---------------------+<br>          (a)                      (b)                     (c)<br></code></pre></td></tr></table></figure><p>针对 a 情况，GNU&#x2F;Linux操作系统直接运行在真实的计算机硬件上, <strong>对计算机底层硬件进行了抽象</strong>, 同时向上层的用户程序提供接口和服务. <strong>因此 Hello World 程序输出信息的时候, 需要用到操作系统提供的接口</strong>。</p><p>而针对 b 情况，会有些复杂，实际上在 a 情况的基础上我们把 Hello World 更换为了 NES 模拟器，这个无可厚非，但是这个 NES 模拟器本身作为软件的同时还可以模拟出硬件。实际上对于马里奥来说, <strong>它并不能区分自己是运行在真实的红白机硬件之上, 还是运行在模拟出来的红白机硬件之上</strong>, 这正是”模拟”的障眼法。</p><p>那么再来看 c 情况，其实这个时候就很一目了然了，NEMU 本身其实也是和 NES 模拟器一样的存在，<strong>通过软件模拟出了一套硬件</strong>，并且在此基础上可以运行其它的软件系统。</p><h2 id="选择ISA"><a href="#选择ISA" class="headerlink" title="选择ISA"></a>选择ISA</h2><p>PA 为我们提供提供了三种不同的 ISA 架构，分别是：</p><ul><li>x86</li><li>mips32</li><li>riscv32&#x2F;64</li></ul><p>具体选择的难易度如下表：(5星 - 容易, 1星 - 困难)</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221125153035685.png" alt="image-20221125153035685"></p><p>这里我们就直接选择 <code>riscv</code> 架构了，而且无论是哪一种架构，在学习的时候都是需要 RTFM 的。</p><h2 id="什么是ISA"><a href="#什么是ISA" class="headerlink" title="什么是ISA"></a>什么是ISA</h2><p>简单来说，我们可以把计算机硬件比作不同尺寸的<strong>螺丝钉</strong>，把不同架构的程序软件比作是不同尺寸的<strong>螺母</strong>，如果一个软件程序要在特定架构的计算机上个运行，那么<strong>这个程序必须要满足同一套规范</strong>。</p><p>因此这里的一个规范其实就是 ISA，ISA的存在形式既不是硬件电路, 也不是软件代码, 而是一本规范手册。</p><p>和螺钉螺母的生产过程类似, <strong>计算机硬件是按照ISA规范手册构造出来的</strong>, 而<strong>程序也是按照ISA规范手册编写(或生成)出来的</strong>, 至于 ISA 规范里面都有哪些内容, 我们应该如何构造一个符合规范的计算机, 程序应该如何遵守这些规范来在计算机上运行, <strong>回答这些问题正是做 PA 的一个目标。</strong></p><h1 id="开天辟地的篇章"><a href="#开天辟地的篇章" class="headerlink" title="开天辟地的篇章"></a>开天辟地的篇章</h1><h2 id="最简单的计算机组件"><a href="#最简单的计算机组件" class="headerlink" title="最简单的计算机组件"></a>最简单的计算机组件</h2><p>我们在程序设计这门课上其实都已经发现了，<strong>程序 &#x3D; 代码 + 数据</strong>. 数据是程序处理的对象，而代码则是代表程序如何处理这些数据。</p><p>讲义中引出了一个最简单的计算机执行最简单的程序的这么一个 demo 案例介绍了最简单的计算机所需要的一些硬件组件。</p><p>首先为了放程序，我们需要一个<strong>存储器</strong>，这个就是内存。程序加载进入了内存之后被 CPU 执行。</p><p><strong>CPU</strong> 是计算机的大脑，负责处理数据的核心单元。</p><p>但是除此之外还是有点不太够，我们的 CPU 还需要<strong>运算器</strong>，对数据进行各种算术处理。</p><p>虽然说<strong>内存容量大，但是相比较于 CPU 的处理速度，还是比较慢</strong>，如果我们的程序需要对一个数据同时进行连续处理（比如一段程序求累加和的时候需要一个 sum 变量），我们就会需要<strong>寄存器</strong>，寄存器本身属于 CPU，<strong>它的定位和内存完全相反，可以装载的数据容量小，但是速度极快</strong>，让 CPU 把正在处理中的数据暂时存放在其中。</p><p>同时为了可以控制 CPU 做程序想要做的任何事情，我们还需要 <code>指令</code> 来<strong>指示</strong> CPU 对数据进行怎样的处理。</p><h2 id="自动化起来"><a href="#自动化起来" class="headerlink" title="自动化起来"></a>自动化起来</h2><p>有了指令之后，我们想着能不能让程序自动化地一行一行执行？显然这是可以的，因为我们的程序事实上就是自动地一行行执行的，我们来看下到底是底层通过什么来实现自动化执行的：</p><p>自动化执行其实就是<strong>执行完一条指令后继续执行下一条指令</strong>，那么计算机怎么知道现在执行到了哪一条了？因此我们需要一个特殊的计数器:<code>PC (Program Counter) 程序计数器</code>。</p><p>因此我们以后只需要把程序序列加载进入内存，然后让 PC 指向程序的第一行即可，整段程序执行的<strong>伪代码</strong>大致如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>     从当前PC所指向的内存位置中取出指令;<br>     执行指令;<br>     更新PC;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的指令序列可以计算 <code>1+2+...+100</code>, 其中 <code>r1</code> 和 <code>r2</code> 是两个寄存器, 还有一个隐含的程序计数器 <code>PC</code> , 它的初值是<code>0</code></p><p>为了便于理解，右边那块是 c 代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">// PC: instruction    | // label: statement<br>0: mov  r1, 0         |  pc0: r1 = 0;<br>1: mov  r2, 0         |  pc1: r2 = 0;<br>2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;<br>3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;<br>4: blt  r2, 100, 2    |  pc4: if (r2 &lt; 100) goto pc2;   // branch if less than<br>5: jmp 5              |  pc5: goto pc5;<br></code></pre></td></tr></table></figure><p>我们可以发现上面的程序在计算完 100 之后就会一直停留在 pc5 这一指令中进入死循环，虽然是死循环，但是结果已经存放在了 r1 寄存器中，计算已经结束。</p><blockquote><p><strong>实验必做内容</strong></p><p>在看到上述例子之前, 你可能会觉得指令是一个既神秘又难以理解的概念. 不过当你看到对应的C代码时, 你就会发现指令做的事情竟然这么简单! 而且看上去还有点蠢, 你随手写一个for循环都要比这段C代码看上去更高级.</p><p>不过你也不妨站在计算机的角度来理解一下, 计算机究竟是怎么通过这种既简单又笨拙的方式来计算<code>1+2+...+100</code>的. 这种理解会使你建立”程序如何在计算机上运行”的最初原的认识.</p></blockquote><p>其实就是自己模拟一下上述的过程，我们可以发现本质上其实就是对应上述的工作方式：</p><ul><li>读取PC对应的指令</li><li>执行指令</li><li>更新PC</li></ul><p>最终将会进入图灵机的 <strong>halt</strong> 状态。</p><p>今天的计算机**本质上还是”存储程序”**这种天然愚钝的工作方式。</p><blockquote><p>计算机是数组逻辑电路，如果从硬件视角来看，计算机本质上其实是由 时序逻辑电路(存储器，计数器，寄存器) + 组合逻辑电路（加法器）构成的，<strong>在每一个时钟周期到来的时候，计算机都会根据当前的时序逻辑状态，在组合逻辑电路组件的作用下，计算出下一时钟周期的新状态。</strong></p></blockquote><h2 id="程序本质是个状态机"><a href="#程序本质是个状态机" class="headerlink" title="程序本质是个状态机"></a>程序本质是个状态机</h2><p>在讲义中假设了一个计算机有 4 个 8 位的寄存器, 一个 4 位 PC , 以及一段 16 字节的内存(也就是存储器), 那么这个计算机可以表示比特总数为 <code>B = 4 * 8  + 4 + 16 * 8 = 164</code>，因此总共的状态数 N 为 2 的164 次方。我们这里就简单地以 N &#x3D; 50 来进行计算的话，也就是有五十种状态，一种可能的状态转移如下：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/state-machine.png" alt="state-machine"></p><p>之所以会进行状态转移，本质上其实还就是因为每一段程序的执行本质上就会进行一次状态的转移。因此我们说执行程序的计算机本质上其实就是一个状态机。</p><p>完整的定义为：给定一个程序, 把它放到计算机的内存中, <strong>就相当于在状态数量为 <code>N</code> 的状态转移图中</strong>指定了一个初始状态, 程序运行的过程就是从这个初始状态开始, <strong>每执行完一条指令, 就会进行一次确定的状态转移</strong>. 也就是说, 程序也可以看成一个状态机! 这个状态机是上文提到的大状态机(状态数量为 <code>N</code> )的子集.</p><p><strong>下面举个例子</strong></p><p>假设某程序在上图所示的计算机中运行, 其初始状态为上图左上角的 8 号状态, 那么这个程序对应的状态机为</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-number">8</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">32</span>-&gt;<span class="hljs-number">31</span>-&gt;<span class="hljs-number">32</span>-&gt;<span class="hljs-number">31</span>-&gt;...<br></code></pre></td></tr></table></figure><p>我们推测这个程序可能是:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">// PC: instruction    | // label: statement<br><span class="hljs-number">0</span>: addi <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r2</span>, <span class="hljs-number">2</span>     |  pc0: <span class="hljs-built_in">r1</span> = <span class="hljs-built_in">r2</span> + <span class="hljs-number">2</span><span class="hljs-comment">;</span><br><span class="hljs-number">1</span>: <span class="hljs-keyword">subi</span> <span class="hljs-built_in">r2</span>, <span class="hljs-built_in">r1</span>, <span class="hljs-number">1</span>     |  pc1: <span class="hljs-built_in">r2</span> = <span class="hljs-built_in">r1</span> - <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-number">2</span>: <span class="hljs-keyword">nop</span>                |  pc2: <span class="hljs-comment">;  // no operation</span><br><span class="hljs-number">3</span>: <span class="hljs-keyword">jmp</span> <span class="hljs-number">2</span>              |  pc3: goto pc2<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>实验必做内容：</strong></p><p>以上一小节中<code>1+2+...+100</code>的指令序列为例, 尝试画出这个程序的状态机.</p><p>这个程序比较简单, 需要更新的状态只包括<code>PC</code>和<code>r1</code>, <code>r2</code>这两个寄存器, 因此我们用一个三元组<code>(PC, r1, r2)</code>就可以表示程序的所有状态, 而无需画出内存的具体状态. 初始状态是<code>(0, x, x)</code>, 此处的<code>x</code>表示未初始化. 程序<code>PC=0</code>处的指令是<code>mov r1, 0</code>, 执行完之后<code>PC</code>会指向下一条指令, 因此下一个状态是<code>(1, 0, x)</code>. 如此类推, 我们可以画出执行前3条指令的状态转移过程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;(<span class="hljs-number">0</span>, x, x) -&gt; (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, x) -&gt; (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) -&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>请你尝试继续画出这个状态机, 其中程序中的循环只需要画出前两次循环和最后两次循环即可.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-number">0</span>, x, x) -&gt; (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, x) -&gt; (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) -&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) -&gt; (<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) -&gt; (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) -&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) -&gt;  (<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>) -&gt;  (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>) -&gt;  (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>) -&gt;  (<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>) -&gt; ... -&gt; (<span class="hljs-number">2</span>, <span class="hljs-number">4851</span>, <span class="hljs-number">98</span>) -&gt;  (<span class="hljs-number">3</span>, <span class="hljs-number">4851</span>, <span class="hljs-number">99</span>) -&gt;  (<span class="hljs-number">4</span>, <span class="hljs-number">4950</span>, <span class="hljs-number">99</span>) -&gt; (<span class="hljs-number">2</span>, <span class="hljs-number">4950</span>, <span class="hljs-number">99</span>) -&gt;  (<span class="hljs-number">3</span>, <span class="hljs-number">4950</span>, <span class="hljs-number">100</span>) -&gt;  (<span class="hljs-number">4</span>, <span class="hljs-number">5050</span>, <span class="hljs-number">100</span>) -&gt; (<span class="hljs-number">5</span>, <span class="hljs-number">5050</span>, <span class="hljs-number">100</span>)-&gt; (<span class="hljs-number">5</span>, <span class="hljs-number">5050</span>, <span class="hljs-number">100</span>)...<br></code></pre></td></tr></table></figure><h1 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python">nemu<br>├── configs                    <span class="hljs-comment"># 预先提供的一些配置文件</span><br>├── include                    <span class="hljs-comment"># 存放全局使用的头文件</span><br>│   ├── common.h               <span class="hljs-comment"># 公用的头文件</span><br>│   ├── config                 <span class="hljs-comment"># 配置系统生成的头文件, 用于维护配置选项更新的时间戳</span><br>│   ├── cpu<br>│   │   ├── cpu.h<br>│   │   ├── decode.h           <span class="hljs-comment"># 译码相关</span><br>│   │   ├── difftest.h<br>│   │   └── ifetch.h           <span class="hljs-comment"># 取指相关</span><br>│   ├── debug.h                <span class="hljs-comment"># 一些方便调试用的宏</span><br>│   ├── device                 <span class="hljs-comment"># 设备相关</span><br>│   ├── difftest-<span class="hljs-keyword">def</span>.h<br>│   ├── generated<br>│   │   └── autoconf.h         <span class="hljs-comment"># 配置系统生成的头文件, 用于根据配置信息定义相关的宏</span><br>│   ├── isa.h                  <span class="hljs-comment"># ISA相关</span><br>│   ├── macro.h                <span class="hljs-comment"># 一些方便的宏定义</span><br>│   ├── memory                 <span class="hljs-comment"># 访问内存相关</span><br>│   └── utils.h<br>├── Kconfig                    <span class="hljs-comment"># 配置信息管理的规则</span><br>├── Makefile                   <span class="hljs-comment"># Makefile构建脚本</span><br>├── README.md<br>├── resource                   <span class="hljs-comment"># 一些辅助资源</span><br>├── scripts                    <span class="hljs-comment"># Makefile构建脚本</span><br>│   ├── build.mk<br>│   ├── config.mk<br>│   ├── git.mk                 <span class="hljs-comment"># git版本控制相关</span><br>│   └── native.mk<br>├── src                        <span class="hljs-comment"># 源文件</span><br>│   ├── cpu<br>│   │   └── cpu-<span class="hljs-built_in">exec</span>.c         <span class="hljs-comment"># 指令执行的主循环</span><br>│   ├── device                 <span class="hljs-comment"># 设备相关</span><br>│   ├── engine<br>│   │   └── interpreter        <span class="hljs-comment"># 解释器的实现</span><br>│   ├── filelist.mk<br>│   ├── isa                    <span class="hljs-comment"># ISA相关的实现</span><br>│   │   ├── mips32<br>│   │   ├── riscv32<br>│   │   ├── riscv64<br>│   │   └── x86<br>│   ├── memory                 <span class="hljs-comment"># 内存访问的实现</span><br>│   ├── monitor<br>│   │   ├── monitor.c<br>│   │   └── sdb                <span class="hljs-comment"># 简易调试器</span><br>│   │       ├── expr.c         <span class="hljs-comment"># 表达式求值的实现</span><br>│   │       ├── sdb.c          <span class="hljs-comment"># 简易调试器的命令处理</span><br>│   │       └── watchpoint.c   <span class="hljs-comment"># 监视点的实现</span><br>│   ├── nemu-main.c            <span class="hljs-comment"># 你知道的...</span><br>│   └── utils                  <span class="hljs-comment"># 一些公共的功能</span><br>│       ├── log.c              <span class="hljs-comment"># 日志文件相关</span><br>│       ├── rand.c<br>│       ├── state.c<br>│       └── timer.c<br>└── tools                      <span class="hljs-comment"># 一些工具</span><br>    ├── fixdep                 <span class="hljs-comment"># 依赖修复, 配合配置系统进行使用</span><br>    ├── gen-expr<br>    ├── kconfig                <span class="hljs-comment"># 配置系统</span><br>    ├── kvm-diff<br>    ├── qemu-diff<br>    └── spike-diff<br></code></pre></td></tr></table></figure><p>这里官方把代码分为两大模块</p><ul><li>与 ISA 无关的基本框架</li><li>不同 ISA 的具体实现</li></ul><p>通过抽象不同 ISA 的接口以及在 <code>nemu/include/isa.h</code> 中进行装配不同的 ISA ，来实现适配不同的 ISA 支持。</p><h2 id="配置系统与项目构建"><a href="#配置系统与项目构建" class="headerlink" title="配置系统与项目构建"></a>配置系统与项目构建</h2><h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><h4 id="为什么需要配置系统"><a href="#为什么需要配置系统" class="headerlink" title="为什么需要配置系统"></a>为什么需要配置系统</h4><p>因为在一个完整的系统中，配置项可能会很多而且存在关联，我们<strong>需要一个系统来帮助我们自动化管理不同的配置以及修改配置后的关联修改</strong>，这个系统就是配置系统。</p><h4 id="NEMU-的配置系统"><a href="#NEMU-的配置系统" class="headerlink" title="NEMU 的配置系统"></a>NEMU 的配置系统</h4><p>NEMU 使用的是来自 GNU&#x2F;Liunx 系的配置系统 <code>kconfig</code>，并进行了少量的简化操作，通过 kconfig 指定的描述语言，开发者可以在<strong>配置描述文件</strong>中进行描述以下的几种配置：</p><ul><li>配置选项的属性（比如某配置的类型以及默认值）</li><li>不同配置选项的关联依赖</li><li>配置选项的层级关系</li></ul><p>个人感觉这一套配置描述下来，其实大概就是我们软件中用到的 <code>setting</code> 这么一个基本需求了。</p><p>NEMU 的配置描述文件为 <code>nemu/Kconfig</code>，当我们输入 <code>make menuconfig</code> 的时候，其实是通过 Makefile 自动化地帮助我们进行了配置描述文件的<strong>初始化</strong>以及<strong>用户在此之后进行的配置设置</strong>的<strong>整合</strong>。</p><h4 id="配置系统过程中需要注意的"><a href="#配置系统过程中需要注意的" class="headerlink" title="配置系统过程中需要注意的"></a>配置系统过程中需要注意的</h4><ul><li>上述的过程中会执行 <code>mconf nemu/Kconfig</code> 来通过解析 Kconfig 这个配置描述文件中的描述来生成展示各种用于用户设置的配置选项</li><li>在用户设置完毕之后会自动生成一个 <code>.config</code> 文件来持久化用户刚刚的配置选择。</li><li>配置系统在初始化以及用户配置持久化都完成之后，会执行 <code>conf --syncconfig nemu/Kconfig</code> 将配置描述文件 Kconfig 中的描述以及用户设置的结果 <code>nemu/.config</code> 进行结合，生成如下文件<ul><li>可以被包含到C代码中的宏定义 <code>#define</code> (<code>nemu/include/generated/autoconf.h</code>), 这些宏的名称都是形如<code>CONFIG_xxx</code>的形式</li><li>可以被包含到Makefile中的变量定义(<code>nemu/include/config/auto.conf</code>)</li></ul></li></ul><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221203102242796.png" alt="image-20221203102242796"></p><h3 id="项目构建Makefile"><a href="#项目构建Makefile" class="headerlink" title="项目构建Makefile"></a>项目构建Makefile</h3><p>NEMU 的 Makefile 很复杂，讲义中解析了他如下的几个功能</p><h3 id="关联配置系统"><a href="#关联配置系统" class="headerlink" title="关联配置系统"></a>关联配置系统</h3><p>我们上面提到了配置系统会结合初始化配置 Kconfig 的描述以及用户配置自动生成可以被包含到Makefile中的变量定义(<code>nemu/include/config/auto.conf</code>)，因此如果用户通过 <code>menuconfig</code> 来进行配置的更新，Makefile 的变量也会发生改变，实现与配置系统的关联绑定。</p><h3 id="文件列表filelist"><a href="#文件列表filelist" class="headerlink" title="文件列表filelist"></a>文件列表filelist</h3><p>在<code>nemu/src</code>及其子目录下存在很多名为<code>filelist.mk</code>的文件，这边以 <code>nemu/src/filelist.mk</code> 为例，我们先来理解一下这些文件的含义。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SRCS-y += src/nemu-main.c<br>DIRS-y += src/cpu src/monitor src/utils<br>DIRS-<span class="hljs-variable">$(CONFIG_MODE_SYSTEM)</span> += src/memory<br>DIRS-BLACKLIST-<span class="hljs-variable">$(CONFIG_TARGET_AM)</span> += src/monitor/sdb<br><br>SHARE = <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(CONFIG_TARGET_SHARE)</span>,1,0)</span><br>LIBS += <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(CONFIG_TARGET_NATIVE_ELF)</span>,-lreadline -ldl -pie,)</span><br><br><span class="hljs-keyword">ifdef</span> mainargs<br>ASFLAGS += -DBIN_PATH=\<span class="hljs-string">&quot;<span class="hljs-variable">$(mainargs)\&quot;</span></span><br><span class="hljs-string">endif</span><br><span class="hljs-string">SRCS-<span class="hljs-variable">$(CONFIG_TARGET_AM)</span> += src/am-bin.S</span><br><span class="hljs-string">.PHONY: src/am-bin.S</span><br></code></pre></td></tr></table></figure><ul><li><code>SRCS-y</code> - 参与编译的源文件的候选集合</li><li><code>SRCS-BLACKLIST-y</code> - 不参与编译的源文件的黑名单集合</li><li><code>DIRS-y</code> - 参与编译的目录集合, 该目录下的所有文件都会被加入到<code>SRCS-y</code>中</li><li><code>DIRS-BLACKLIST-y</code> - 不参与编译的目录集合, 该目录下的所有文件都会被加入到<code>SRCS-BLACKLIST-y</code>中</li></ul><p>同时我们也看到了 <code>DIRS-BLACKLIST-$(CONFIG_TARGET_AM) += src/monitor/sdb</code> 这种类似带有 <code>$</code> 取值的操作，具体取的值是与 <code>menuconfig</code> 的<strong>配置结果中的布尔选项</strong>进行关联。具体的工作模式是：</p><ul><li>当我们配置系统自动生成了 <code>nemu/include/config/auto.conf</code> 之后，Makefile 中会关联该文件中定义的变量。</li><li>如果用户在 menuconfig 中选择了 <code>TARGET_AM</code> 相关的布尔选项时, kconfig 最终会在 <code>nemu/include/config/auto.conf</code> 中生成形如 <code>CONFIG_TARGET_AM=y</code> 的代码, 我们把变量进行带入展开后将会得到 <code>DIRS-BLACKLIST-y += src/monitor/sdb</code> ，对应其实就是将此文件夹加入黑名单备选。从而实现了<strong>在 menuconfig 中选中 TARGET_AM 时, nemu&#x2F;src&#x2F;monitor&#x2F;sdb 目录下的所有文件都不会参与编译</strong>.</li><li>如果用户在 menuconfig 中<strong>未选择</strong> <code>TARGET_AM</code> 相关的布尔选项时, kconfig 将会生成形如 <code>CONFIG_TARGET_AM=n</code> 的代码, 或者未对 <code>CONFIG_TARGET_AM </code>进行定义, 此时将会得到 <code>DIRS-BLACKLIST-n += src/monitor/sdb</code> , 或者 <code>DIRS-BLACKLIST- += src/monitor/sdb</code> , 这两种情况都不会影响 <code>DIRS-BLACKLIST-y</code> 的值, <strong>因此 nemu&#x2F;src&#x2F;monitor&#x2F;sdb 目录下的所有文件都会参与编译</strong>.</li></ul><h3 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h3><p>讲义中指出对于类似的大型工程项目，Makefile的编译规则在 <code>nemu/scripts/build.mk</code> 中定义，我们可以看一下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.DEFAULT_GOAL = app<br><br><span class="hljs-comment"># Add necessary options if the target is a shared library</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(SHARE)</span>,1)<br>SO = -so<br>CFLAGS  += -fPIC<br>LDFLAGS += -rdynamic -shared -fPIC<br><span class="hljs-keyword">endif</span><br><br>WORK_DIR  = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br>BUILD_DIR = <span class="hljs-variable">$(WORK_DIR)</span>/build<br><br>INC_PATH := <span class="hljs-variable">$(WORK_DIR)</span>/<span class="hljs-keyword">include</span> <span class="hljs-variable">$(INC_PATH)</span><br>OBJ_DIR  = <span class="hljs-variable">$(BUILD_DIR)</span>/obj-<span class="hljs-variable">$(NAME)</span><span class="hljs-variable">$(SO)</span><br>BINARY   = <span class="hljs-variable">$(BUILD_DIR)</span>/<span class="hljs-variable">$(NAME)</span><span class="hljs-variable">$(SO)</span><br><br><span class="hljs-comment"># Compilation flags</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CC)</span>,clang)<br>CXX := clang++<br><span class="hljs-keyword">else</span><br>CXX := g++<br><span class="hljs-keyword">endif</span><br>LD := <span class="hljs-variable">$(CXX)</span><br>INCLUDES = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> -I, <span class="hljs-variable">$(INC_PATH)</span>)</span><br>CFLAGS  := -O2 -MMD -Wall -Werror <span class="hljs-variable">$(INCLUDES)</span> <span class="hljs-variable">$(CFLAGS)</span><br>LDFLAGS := -O2 <span class="hljs-variable">$(LDFLAGS)</span><br><br>OBJS = $(SRCS:%.c=<span class="hljs-variable">$(OBJ_DIR)</span>/%.o) $(CXXSRC:%.cc=<span class="hljs-variable">$(OBJ_DIR)</span>/%.o)<br><br><span class="hljs-comment"># Compilation patterns</span><br><span class="hljs-variable">$(OBJ_DIR)</span>/%.o: %.c<br>@echo + CC <span class="hljs-variable">$&lt;</span><br>@mkdir -p <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$@</span>)</span><br>@<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> call_fixdep, $(@:.o=.d)</span>, <span class="hljs-variable">$@</span>)<br><br><span class="hljs-variable">$(OBJ_DIR)</span>/%.o: %.cc<br>@echo + CXX <span class="hljs-variable">$&lt;</span><br>@mkdir -p <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$@</span>)</span><br>@<span class="hljs-variable">$(CXX)</span> <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(CXXFLAGS)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> call_fixdep, $(@:.o=.d)</span>, <span class="hljs-variable">$@</span>)<br><br><span class="hljs-comment"># Depencies</span><br><span class="hljs-keyword">-include</span> $(OBJS:.o=.d)<br><br><span class="hljs-comment"># Some convenient rules</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: app clean</span><br><br><span class="hljs-section">app: <span class="hljs-variable">$(BINARY)</span></span><br><br><span class="hljs-variable">$(BINARY)</span>: <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(ARCHIVES)</span><br>@echo + LD <span class="hljs-variable">$@</span><br>@<span class="hljs-variable">$(LD)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span> <span class="hljs-variable">$(ARCHIVES)</span> <span class="hljs-variable">$(LIBS)</span><br><br><span class="hljs-section">clean:</span><br>-rm -rf <span class="hljs-variable">$(BUILD_DIR)</span><br></code></pre></td></tr></table></figure><p>我们这里只关注具体的编译阶段</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Compilation patterns</span><br><span class="hljs-variable">$(OBJ_DIR)</span>/%.o: %.c<br>@echo + CC <span class="hljs-variable">$&lt;</span><br>@mkdir -p <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$@</span>)</span><br>@<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span>        <span class="hljs-comment">#主要是这一行</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> call_fixdep, $(@:.o=.d)</span>, <span class="hljs-variable">$@</span>)<br></code></pre></td></tr></table></figure><p>确实是什么都看不懂，但是我们可以通过 <code>make -nB</code> 查看 <code>make</code> 过程中都执行了哪些操作：</p><p>可以看到很多形如如下的编译操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -O2 -MMD -Wall -Werror -I/home/link/pa/ics2022/nemu/include -I/home/link/pa/ics2022/nemu/src/engine/interpreter -I/home/link/pa/ics2022/nemu/src/isa/riscv32/include -O2    -DITRACE_COND=<span class="hljs-literal">true</span> -D__GUEST_ISA__=riscv32 -c -o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/utils/timer.o src/utils/timer.c<br></code></pre></td></tr></table></figure><p>我们可以知道</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(CC)</span> -&gt; gcc<br><span class="hljs-variable">$@</span> -&gt; /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/utils/timer.o<br><span class="hljs-variable">$&lt;</span> -&gt; src/utils/timer.c<br><span class="hljs-variable">$(CFLAGS)</span> -&gt; 剩下的内容<br></code></pre></td></tr></table></figure><p>因此我们可以根据上述输出结果和Makefile反推 <code>$(CFLAGS)</code> 的值是如何形成的。</p><p>之后的链接过程，我们通过 <code>make -nB</code> 也可以看出</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(BINARY)</span>: <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(ARCHIVES)</span><br>@echo + LD <span class="hljs-variable">$@</span><br>@<span class="hljs-variable">$(LD)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span> <span class="hljs-variable">$(ARCHIVES)</span> <span class="hljs-variable">$(LIBS)</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ -o /home/link/pa/ics2022/nemu/build/riscv32-nemu-interpreter /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/nemu-main.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/device/io/map.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/device/io/mmio.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/device/io/port-io.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/cpu/cpu-exec.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/cpu/difftest/dut.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/cpu/difftest/ref.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/monitor/sdb/expr.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/monitor/sdb/sdb.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/monitor/sdb/watchpoint.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/monitor/monitor.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/utils/rand.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/utils/log.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/utils/state.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/utils/timer.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/memory/vaddr.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/memory/paddr.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/engine/interpreter/init.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/engine/interpreter/hostcall.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/isa/riscv32/logo.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/isa/riscv32/init.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/isa/riscv32/difftest/dut.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/isa/riscv32/reg.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/isa/riscv32/system/intr.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/isa/riscv32/system/mmu.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/isa/riscv32/inst.o /home/link/pa/ics2022/nemu/build/obj-riscv32-nemu-interpreter/src/utils/disasm.o -O2 -O2     -lLLVM-14 -lreadline -ldl -pie<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写给因为害怕失眠而失眠的我和你</title>
    <link href="/2022/11/23/%E5%86%99%E7%BB%99%E5%9B%A0%E4%B8%BA%E5%AE%B3%E6%80%95%E5%A4%B1%E7%9C%A0%E8%80%8C%E5%A4%B1%E7%9C%A0%E7%9A%84%E6%88%91%E5%92%8C%E4%BD%A0/"/>
    <url>/2022/11/23/%E5%86%99%E7%BB%99%E5%9B%A0%E4%B8%BA%E5%AE%B3%E6%80%95%E5%A4%B1%E7%9C%A0%E8%80%8C%E5%A4%B1%E7%9C%A0%E7%9A%84%E6%88%91%E5%92%8C%E4%BD%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>起因就是不知道为什么，突然有一天早上睡的久了，然后晚上就睡不好了。</p><p>本来这种情况其实也还好，之前发生的时候也根本就没有在意这种事情，当天晚上失眠了，第二天没啥精神，睡的自然就早了，可是没想到的是最近这段时间突然发生了同样的事情，<strong>但是这样的问题莫名其妙被我自己放大，给予了之前从来没有的注意力和关注</strong>。（也许是我自身性格的原因吧，从小性格就是喜欢纠结，优柔寡断的那种XD）</p><p>在失眠了的第二天晚上，我不断和自己说，今天一定要早睡，一定要在 11:30 分之前就睡着。</p><p>我心里这么想着，果不其然，我又失眠了。</p><p>这样的情况连续持续了好几天，不知不觉，<strong>我开始害怕晚上睡觉了</strong>，因为在我的潜意识中，上床睡觉 &#x3D; 床上清醒数小时 &#x3D; 失眠 &#x3D; 第二天神志不清，被撅晕过去力（悲）。</p><p>越紧张就越睡不着，后来慢慢发展成晚上紧张睡不着，白天郁闷担心失眠，整天脑袋里就反复地想着睡觉两个字。。。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="认清问题本质"><a href="#认清问题本质" class="headerlink" title="认清问题本质"></a>认清问题本质</h2><p>问题的本质不在于别人，在于<strong>你自己和自己过不去</strong>。</p><p>这是心理作用，不管什么外界药物或者是其他手段都不能 <strong>从根本上</strong> 解决这个问题。</p><p>因此，所谓的让你想什么，让你做什么，让你以为自己在想什么的操作，都是屁用没有，<strong>只会徒增你自己的压力</strong>，很有可能因为想了这个本来不会失眠的导致今晚失眠了。</p><h2 id="接受自己的不足，原谅自己"><a href="#接受自己的不足，原谅自己" class="headerlink" title="接受自己的不足，原谅自己"></a>接受自己的不足，原谅自己</h2><p>我们常说人要学会爱自己，<strong>真正爱自己其实就是完全包容自己，宽容自己</strong>，哪怕这个自己是不完美的，有缺陷的，而不是所谓去给自己买身漂亮衣服，今天奖励自己吃上一顿好吃的这种物质上的水平。</p><p>以我为例，我知道自己性格是会纠结的那种，<strong>那我就接受自己喜欢纠结喜欢多想事情的这一个事实。</strong>晚上睡不着了，我也告诉自己：想就想吧，我是那种会纠结的人，心态放平。</p><p>脑子里想事情，你允许自己去想。<strong>同时，也允许自己把它忘掉。“拿的起，放的下”</strong>。</p><p>这一个要求最终的目的不是一下就什么都不担心了。而是<strong>相信自己可以面对任何情况，就算现在不能完全做到，但也相信自己会做到，只是时间问题，允许自己担心害怕存在，允许自己睡不着，就是接受任何情况下的自己，爱自己任何状态</strong>。</p><h2 id="改变自己的认识"><a href="#改变自己的认识" class="headerlink" title="改变自己的认识"></a>改变自己的认识</h2><p>不睡觉死不了人，常年失眠的人并没有明显的疾病。（当然我不是说熬夜有好处，<strong>但是现在失眠这一个问题被那些营销公众号给吹上天了，搞得大家一谈到失眠就觉得要死了一样，没多大事，人家不这么吓你，不让你焦虑，怎么好卖自己的产品呢？</strong>）</p><p>睡眠并不会影响效率，即使是失眠了，只要你想，第二天学习一样学，记住一点，<strong>不是抓紧每时每刻学习，而是认真投入学习的每时每刻</strong>。</p><p>放下偏执和强迫症，12点睡觉可以，3点睡觉也可以，不必要非得在某个时间点之前入睡。</p><p>这训练会帮助你不逃避，直面所有问题，学会放下，这个练习需要自己不断挖掘内心，每天做三次，日积月累，效果就慢慢的出现了</p><p>对人对事没那么纠结了，心静如水静静地体验当下美好的生活。</p><h2 id="一些小的方案"><a href="#一些小的方案" class="headerlink" title="一些小的方案"></a>一些小的方案</h2><p>上面说了，所谓的具体操作比如让你想什么，让你睡前做什么，让你以为自己在想什么的操作，都是屁用没有，这是因为你自己把这些事情和睡觉进行了无意识的关联。</p><p>睡前强迫自己数羊，你一定失眠，因为你一直在乎自己睡不着强迫自己数羊，只会让自己的意识越来越清醒。</p><p>但是如果我们不把数羊和睡觉这个事情挂上钩，那么在睡前还是有一些手段可以辅助睡觉的，但是切记，还是那句话，不要把失眠放在心上。</p><ul><li>睡前半小时尽量不要摄入食物和水，不要看刺激大脑的东西。</li><li>晚上饭后可以适量运动（燃脂跑这种），让你产生困意，但是<strong>不要强迫自己因为跑步了所以今晚一定要睡着，你这么想了，等下又睡不着了</strong>。</li><li>如果实在睡不着，那就下床做些别的事情，冥想&#x2F;coding&#x2F;打电动，不管是做什么，<strong>不刻意逼自己入睡就好了，不要给自己心理压力，告诉自己大不了通宵一晚得了</strong>。等到自己感觉困了的时候再上床。</li></ul><h1 id="一些知乎参考"><a href="#一些知乎参考" class="headerlink" title="一些知乎参考"></a>一些知乎参考</h1><p><a href="https://www.zhihu.com/question/265456938/answer/296355603">失眠，睡不着怎么办？</a></p><p><a href="https://zhuanlan.zhihu.com/p/145945811">送给“害怕失眠”而失眠的人</a></p><p><a href="https://zhuanlan.zhihu.com/p/104277374">失眠后越睡不着我就越担心，越担心就越睡不着，形成了恐惧心理</a></p>]]></content>
    
    
    <categories>
      
      <category>杂谈&amp;人生哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>夜读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NJU-ICS|PA0</title>
    <link href="/2022/11/22/NJU-ICS-PA0/"/>
    <url>/2022/11/22/NJU-ICS-PA0/</url>
    
    <content type="html"><![CDATA[<h1 id="Installing-Linux"><a href="#Installing-Linux" class="headerlink" title="Installing Linux"></a>Installing Linux</h1><p>最恶心的装虚拟机来咯，首先需要下载 Ubuntu 22.03 的镜像，官网下载即可。</p><p>之后通过 VMWare 来进行虚拟机的安装，这里直接通过<strong>典型</strong>的安装步骤即可，网上很多，这里不再记录归档。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>针对 VMWare 不能全屏幕显示的这个问题，主要是需要安装 VMWare Tools，但是在按照官方的文档配置安装的过程中爆出了 <code>segementation fault</code> 的错误选项，这里查询到了几种解决方案。</p><p><a href="https://www.jianshu.com/p/3e5a0d7e8f41">VMWare tools 安装以及一些常见错误</a></p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>值得注意的是官方的讲义中明确指出了第一次进去的时候弹出更新软件包的窗口，要求<strong>不要让我们更新软件包</strong>，否则之后将以的操作会产生冲突，我们这里严格按照要求来就好了。</p><p>至于如何永久关闭软件包的更新，这里按照这个配置来即可</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221122235553191.png"></p><h1 id="First-Exploration"><a href="#First-Exploration" class="headerlink" title="First  Exploration"></a>First  Exploration</h1><p>这部分就是简单的一个初体验快速上手我们的 Linux，如果你之前有过Linux操作的经验应该不是问题。</p><p>同时还强调了 CLI 相较于 GUI 的优势， <code>vim</code> 为何是编辑器之神 XD。</p><h1 id="Installing-Tools"><a href="#Installing-Tools" class="headerlink" title="Installing Tools"></a>Installing Tools</h1><p>按照文档来即可 <a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2022/0.3.html">Installing Tools</a></p><p><a href="https://blog.csdn.net/xpy870663266/article/details/94742491">解决 Unable to Correct Problems ‘You have Held Broken Packages</a></p><p><a href="https://www.cnblogs.com/asmer-stone/p/5227188.html">在英文的 Linux 系统中安装中文输入法</a></p><p>当我们通过 fcitx 下载了最新的 sunpinyin 语言包之后，就可以进入到左上角小键盘右键的 <code>configure</code> 选项卡中进行追加中文输入法了，但是保持系统语言还是英文。</p><p>之后重启&#x2F;注销即可生效。</p><h1 id="Configuring-vim"><a href="#Configuring-vim" class="headerlink" title="Configuring vim"></a>Configuring vim</h1><h2 id="Learning-vim"><a href="#Learning-vim" class="headerlink" title="Learning vim"></a>Learning vim</h2><p>为什么 vim 是神？因为他确实太好用了。</p><p>讲义中给出了很多推荐的 tutorial 这边我采用的是这个 <a href="https://www.openvim.com/tutorial.html">Open Vim Tutorial</a>。</p><p>这边简单进行记录和总结，具体还是需要多实战练习。</p><ul><li><p>基本移动</p><ul><li>h 左，j 下，k 上，l 右。</li><li>w 表示光标移动到下一个 word 的开头，e 表示光标移动到这个单词的结尾(end)，b 表示移动到这个单词的开头(begin)。</li><li>移动操作不仅包括一次移动一格，同时也包括了一次移动倍数格，可以通过组合键的形式进行移动，例如 3w 就是移动三个 word。</li><li>同时倍数的操作也可以用于插入，我们都知道插入操作是 i 这个按键，也可以进行组合，比如 <code>3igo + esc</code> 表示我们在普通模式下进入插入模式写三个 go 之后再退回普通模式。</li><li>0 返回这一行的开头，$ 移动到这一行的末尾。</li><li>gg 移动到文件的开头，G 移动到文件的末尾，如果要定位第几行，用 nG。</li></ul></li><li><p>查询</p><ul><li>通过 f 来进行查询某个字母第一次出现的位置并定位。</li><li>也可以配合数字倍数进行查询第 n 次出现的位置。</li><li>通过 <code>%</code> 可以匹配对应的各种括号。</li><li><code>#</code> 可以查询并移动到当前下标所指单词的下一个位置，<code>*</code> 起到反作用。</li></ul></li></ul><h2 id="Enabling-syntax-highlight"><a href="#Enabling-syntax-highlight" class="headerlink" title="Enabling syntax highlight"></a>Enabling syntax highlight</h2><p>这一部分主要是让我们修改一下 vim 的配置文件来开启文本高亮的显示，修改不是问题，主要在这个过程中学到了 <code>GNU 合并格式的 diff</code> 的这么一个阅读方式，收益很大。</p><p>关于 diff 的语法格式这里可以参考 阮一峰 的博客：<a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">读懂diff - 阮一峰的网络日志</a></p><p>（说白了其实就是把 syntax on 给他注释了的开起来）</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">--- before modification</span><br><span class="hljs-comment">+++ after modification</span><br><span class="hljs-meta">@@ -17,3 +17,3 @@</span><br> &quot; Vim5 and later versions support syntax highlighting. Uncommenting the next<br> &quot; line enables syntax highlighting by default.<br><span class="hljs-deletion">-&quot;syntax on</span><br><span class="hljs-addition">+syntax on</span><br></code></pre></td></tr></table></figure><p>具体解释一下就是，diff 中的 <code>-</code> 表示的是修改前的文档， <code>+</code> 表示的是修改后的文档，第三行的意思是两次修改分别都是在 第一个&#x2F;第二个文件的第 17 行处进行的修改，同时都只展示三行的内容合并显示。</p><h1 id="More-Exploration"><a href="#More-Exploration" class="headerlink" title="More Exploration"></a>More Exploration</h1><h2 id="man-命令"><a href="#man-命令" class="headerlink" title="man 命令"></a>man 命令</h2><p>man 命令可以说是 GNU&#x2F;Linux 系统中最重要的一个命令了，因为他是其他所有命令的说明书一般的存在，这里有<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2022/man.html">man 命令的快速上手教程</a>，可以稍微了解一下，学会最基本的 RTFM 即可。</p><h2 id="Linux-快速上手"><a href="#Linux-快速上手" class="headerlink" title="Linux 快速上手"></a>Linux 快速上手</h2><p>这边有 jyy 老师的<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2022/linux.html">Linux快速上手指南</a>。</p><h2 id="综合体验"><a href="#综合体验" class="headerlink" title="综合体验"></a>综合体验</h2><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><blockquote><p>Write a “Hello World” program, compile it, then run it under GNU&#x2F;Linux. If you do not know what to do, refer to the GNU&#x2F;Linux tutorial above.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221123213545917.png" alt="test"></p><h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><blockquote><p>Write a Makefile to compile the “Hello World” program above. If you do not know what to do, refer to the GNU&#x2F;Linux tutorial above.</p></blockquote><p>这块的话其实还是第一次写 makefile ，这边稍微看了一下文档进行记录。</p><h4 id="最简单的demo"><a href="#最简单的demo" class="headerlink" title="最简单的demo"></a>最简单的demo</h4><p>基于我们上面写的 hello.c 我们可以针对他做出如下的 Makefile demo:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">hello:hello.c</span><br>    gcc hello.c -o hello    <span class="hljs-comment"># 注意开头的tab, 而不是空格</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><br><span class="hljs-section">clean:</span><br>    rm hello    <span class="hljs-comment"># 注意开头的tab, 而不是空格</span><br></code></pre></td></tr></table></figure><p>这个时候我们保存并键入 <code>make</code> 命令，可以看到 makefile 帮助我们进行了 gcc 的编译。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221123221038058.png" alt="image-20221123221038058"></p><h4 id="makefile-语法"><a href="#makefile-语法" class="headerlink" title="makefile 语法"></a>makefile 语法</h4><p>makefile文件的一般格式和语法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">目标文件名:该文件依赖的文件列表</span><br>用于生成这个目标文件的命令序列<br></code></pre></td></tr></table></figure><p>比如上面这段 makefile ：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">hello:hello.c</span><br>    gcc hello.c -o hello <br></code></pre></td></tr></table></figure><p>意思就是我们想要生成 <code>hello</code> 文件，他依赖于 <code>hello.c</code> 这个源文件，而具体生成则是需要 <code>gcc hello.c -o hello </code> 这段命令序列。</p><p>上面例子中的 <code>clean</code> 规则比较特殊, 它并不是用来生成一个名为 <code>clean</code> 的文件, 而是用于清除编译结果, 并且它不依赖于其它任何文件。</p><p>我们需要键入 <code>make clean </code> 命令来告诉 <code>make</code> 程序执行 <code>clean</code> 规则, 这是因为 <code>make</code> 默认执行在 <code>Makefile</code> 中文本序排在最前面的规则. 但如果很不幸地, 目录下已经存在了一个名为<code>clean</code>的文件, 执行<code>make clean</code>会得到”文件已经是最新版本”的提示.。</p><p>为了解决这一个问题，我们在 <code>Makefile</code> 中加入一行 <code>PHONY: clean</code> , 用于指示 “<code>clean</code>是一个伪目标” 。</p><p>这样以后, <code>make </code>程序就不会判断目标文件的新旧, <strong>伪目标相应的命令序列总是会被执行</strong>。</p><h4 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h4><p>对于一个规模稍大一点的工程, <code>Makefile</code> 文件还会使用变量, 函数, 调用Shell命令, 隐含规则等功能，希望能够 STFW.</p><h3 id="Learn-to-us-GDB"><a href="#Learn-to-us-GDB" class="headerlink" title="Learn to us GDB"></a>Learn to us GDB</h3><blockquote><p>Read the GDB tutorial and use GDB following the tutorial. </p><p>In PA1, you will be required to implement a simplified version of GDB. If you have not used GDB, you may have no idea to finish PA1.</p></blockquote><p>RTFM: <a href="https://www.cprogramming.com/gdb.html">GDB, The GNU Debugger, By Example</a></p><h4 id="必要准备"><a href="#必要准备" class="headerlink" title="必要准备"></a>必要准备</h4><p>首先需要编译你的源代码生成可执行文件，在编译的同时开启编译器警告，比如这里有一个 cpp 源程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>      <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>      <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br>      <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">long</span> val=<span class="hljs-built_in">factorial</span>(n);<br>    cout&lt;&lt;val;<br>    cin.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>      <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        result*=n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ main.cpp -g -Wall -o main<br></code></pre></td></tr></table></figure><p>之后直接通过 <code>gdb 可执行程序名</code> 即可进行调试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gdb main<br></code></pre></td></tr></table></figure><h4 id="设置断点，运行中debug"><a href="#设置断点，运行中debug" class="headerlink" title="设置断点，运行中debug"></a>设置断点，运行中debug</h4><p>通过 <code>break linenumber</code> 可以对源代码的指定行数进行断点设置。</p><p>由于是命令行，不像是 IDE 中当前位置一目了然，我们需要 <code>list</code> 命令来查看当前程序进行到哪一行了，这里会列出最近的十行程序。</p><p><code>next</code> 命令走到下一行，而 <code>step</code> 命令有可能会走到源码里。</p><p>我们可以通过 <code>print &lt;var&gt;</code> 来对当前程序中的变量值进行检查，同时也可以通过 <code>set &lt;var&gt; = &lt;value&gt;</code>修改某个变量的值，这样也是便于调试，如果修改成功了说明问题已经被我们 debug 出来了。</p><h4 id="记录程序变化"><a href="#记录程序变化" class="headerlink" title="记录程序变化"></a>记录程序变化</h4><p><code>watch &lt;var&gt;</code> 命令可以查看当前所有变量在运行时的修改情况，每当程序发生变化的时候程序都会提供详细的修改信息。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>事实上这个程序有 bug ，我们通过断点调试就可以看出来，这里手册上详细说出来了，这里就截图跑了一遍体验了一下。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221123230606542.png" alt="初始化变量"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221123230744364.png" alt="多次执行查看watch的情况"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221123230824399.png" alt="找出最终问题所在"></p><h2 id="Installing-tmux"><a href="#Installing-tmux" class="headerlink" title="Installing tmux"></a>Installing tmux</h2><p><code>tmux</code> 顾名思义就是 Terminal Multiplxer 的简称，一般是给 <strong>有高分屏的富哥们</strong> 拿来同时操作多件事情用的。</p><p>具体的使用还得是 STFW.</p><p>讲义中的思考题提出了原先的 terminal 其实是不支持滚动的，为什么最早的终端不支持滚动显示？</p><p>此外 tmux 的滚动实现是怎样的？</p><p>如果想让终端可以进行滚动显示，应该如何处理？</p><h1 id="Getting-Source-Code-for-PAs"><a href="#Getting-Source-Code-for-PAs" class="headerlink" title="Getting Source Code for PAs"></a>Getting Source Code for PAs</h1><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>这里由于是一台新的机器，因此 git 需要进行初始化，否则直接拉取讲义中的源码的时候会报错:<code>git@github.com: Permission denied (publickey)</code>.</p><p>具体解决的方案 <a href="https://blog.csdn.net/qq_43768946/article/details/90411154">STFW</a>.</p><p>之后我们就可以拉取代码了，代码其实是人家写好的 shell 脚本，我们直接运行即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch -m master<br>bash init.sh nemu<br>bash init.sh abstract-machine<br></code></pre></td></tr></table></figure><p>脚本运行主要是拉取一下实验需要的其他的 git 代码仓库，同时也设置了一些环境变量，我们这里可以进行验证：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$NEMU_HOME</span> <span class="hljs-comment"># 执行 shell 脚本的目录下的 nemu 目录</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$AM_HOME</span> <span class="hljs-comment">#执行 shell 脚本的目录下的 abstract-machine 目录</span><br></code></pre></td></tr></table></figure><h2 id="git-review"><a href="#git-review" class="headerlink" title="git review"></a>git review</h2><p>本实验基于 branch 分支对每一次实验进行管理。一个分支对应一个 PA 的实验课。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout -b pa0 <span class="hljs-comment">#创建 Lab0 的专属分支</span><br></code></pre></td></tr></table></figure><p>每一次差不多就是在 pa 的实验开始之前先建立一个分支，之后在这个分支上进行 Lab 的开发，开发完毕之后再合并到 master 主干分支中，这也是一般的开源项目中最常见的一种开发方式。</p><p>这里我们把原先的 git 仓库指向删除，改成自己的仓库，方便版本管理，<a href="https://blog.csdn.net/weixin_44578786/article/details/123102195">STFW 之后得到其实本质就是修改 git 文件的引用即可。</a></p><h2 id="Compiling-and-Running-NEMU"><a href="#Compiling-and-Running-NEMU" class="headerlink" title="Compiling and Running NEMU"></a>Compiling and Running NEMU</h2><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>讲义让我们直接进入 nemu 中进行编译构建，然后就报错了XD，具体原因我们直接 STFW.</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221124191924777.png"></p><p>可以看到似乎是有两个问题</p><ul><li>第一个是这个 bison 指令，好像是没有安装的样子</li><li>第二个好像是 makefile 在执行的时候 27 行 <code>parser.tab.h</code> 的时候报错了，这里先不管他，因为可能是 bison 缺少导致的问题</li></ul><p>我们这里先直接安装 bison 工具包:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install bison<br></code></pre></td></tr></table></figure><p>之后再次执行，发现还是爆了:</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221124192704275.png"></p><p>这次发现可能是 flex 的问题，这里我们去装 flex 试试:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install flex<br></code></pre></td></tr></table></figure><p>这次就可以了，原来是讲义没有引导我们安装 bison 和 flex 这两个构建项目必要的工具包。</p><p>此时我们进入到一个 GUI 中，这里按照讲义的要求先退出然后保存 configuration ，之后通过 make 编译。</p><p>如果想要清除构建重新编译的话，只需要 <code>make clean</code> 即可。</p><p>下面我们直接通过 <code>make run</code> 运行 NEMU：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221124193414160.png"></p><p>出现了 assertion fail ，这个问题我们会在 Lab1 中进行修复，现在只是快速体验一下把环境搭建好。</p><blockquote><p>思考题：为什么在 make 的时候会出现打印提示？</p></blockquote><p>这是因为 makefile 其实本质就是一个构建用的脚本，讲义的作者为我们提供的 makefile 中加入了 <code>if , echo xxx</code> 等的语句用于错误&#x2F;成功时的信息调试，便于我们快速定位问题所在。</p><h3 id="turn-off-development-tracing"><a href="#turn-off-development-tracing" class="headerlink" title="turn off development tracing"></a>turn off development tracing</h3><p>因为我不是 NJU 的学生，为了保证 git 提交的整洁，这里先把开发跟踪关闭了，具体在讲义中也有提到。</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><h2 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h2><ul><li>完成了所有内容，其中包括基本环境搭建，学习了 vim gdb makefile 等具体使用。</li><li>蓝框思考题已经在以上内容中。</li></ul><h2 id="针对-PA0-实验的心得"><a href="#针对-PA0-实验的心得" class="headerlink" title="针对 PA0 实验的心得"></a>针对 PA0 实验的心得</h2><p>深刻体会了 RTFM &#x2F; STFW  对于一个 CSer 的必要性。</p><p>中间的我忘了，后面的我也忘了。</p><p>废话不多说，PA1 启动。</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compiler|Overview &amp; Architecture &amp; Phase</title>
    <link href="/2022/11/22/Compiler-Overview-Architecture-Phase/"/>
    <url>/2022/11/22/Compiler-Overview-Architecture-Phase/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Purpose-for-compiler"><a href="#Purpose-for-compiler" class="headerlink" title="Purpose for compiler"></a>Purpose for compiler</h2><p>通过之前的部分学习其实我们已经可以知道了，编译器的目的本质上其实是将 <strong>高级编程语言</strong> 写下的代码在<strong>不改变原有意义的情况下</strong>转化为 <strong>目标代码</strong>。</p><p>同时编译器应当针对生成的目标代码进行<strong>最优化处理并使从时间和空间上运行更高效</strong>。</p><h2 id="Why-compiler"><a href="#Why-compiler" class="headerlink" title="Why compiler"></a>Why compiler</h2><ul><li>因为考试要考XD</li><li>计算机本质上是硬件+软件的平衡组合，而两者之间之所以需要结合，存在一定的问题。<ul><li>硬件只是一堆机械设备，他们以高低电平(不是0就是1)的方式来理解我们的指令。</li><li>如果让软件开发者直接通过0和1来写代码不仅繁琐而且可读性可维护性都很差，因此需要借助编译器。</li></ul></li></ul><h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>不需要别的，起码你会 c 或者是 java，能有汇编基础那就更好了。</p><h2 id="Audience"><a href="#Audience" class="headerlink" title="Audience"></a>Audience</h2><p>本教程基于 <a href="https://www.tutorialspoint.com/compiler_design/index.htm">Compiler Design Tutorial</a> 进行学习，针对后续深入的理解，可以考虑二刷的时候配合 龙书 + CS143 进行学习。</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="Language-Processing-System"><a href="#Language-Processing-System" class="headerlink" title="Language Processing System"></a>Language Processing System</h2><p>硬件理解的是 0 和 1，而我们通过人类可以理解的高级编程语言语法所写下的代码，将他们作为系列 OS 组件以及工具的输入，最后得到机器可以执行的二进制代码，这一步骤就称为 <strong>Language Processing System</strong>。</p><h2 id="Program-executed"><a href="#Program-executed" class="headerlink" title="Program executed"></a>Program executed</h2><p>编译器整个系统可以大致概括为如下的图</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/language_processing_system.jpg" alt="Language Processing System"></p><p>我们直接举一个例子：</p><p>当我们写的 c 语言的代码在编译执行的过程中，其实是如下的几个阶段</p><ul><li>我们通过遵循高级编程语言的语法来编写 c 语言的代码。</li><li>c 语言的编译一起将程序编译并转化为低级编程语言的汇编代码。</li><li>汇编器将汇编代码转化为可执行的目标代码(机器码)。</li><li>连接器将程序所需要的各个部分连接在一起合并生成可执行文件。</li><li>装载器将程序的指令和数据状态进内存之后执行程序。</li></ul><h2 id="tools-work-closely-with-compilers"><a href="#tools-work-closely-with-compilers" class="headerlink" title="tools work closely with compilers"></a>tools work closely with compilers</h2><h3 id="Preprocessor"><a href="#Preprocessor" class="headerlink" title="Preprocessor"></a>Preprocessor</h3><p>预处理器。</p><p>他是被认为是编译器的其中一个部分，通过文件包含，语言扩展等方式来处理将结果作为编译器的输出文件。</p><h3 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h3><p>和编译器类似，但是有区别，区别在于读取源码&#x2F;输入的方式。</p><ul><li>编译器一次读取整个代码，而解释器一次读取一条语句(statement)。</li><li>编译器遇到多个错误也会读取整个程序，而编译器遇到错误就直接停止。</li></ul><h3 id="Assembler"><a href="#Assembler" class="headerlink" title="Assembler"></a>Assembler</h3><p>汇编器的目的主要是将汇编代码转化为机器码。</p><h3 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h3><p>用于连接多个汇编器执行的目标代码结果。</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>操作系统提供的一个抽象，用于加载程序并计算程序指令和数据在内存中的具体位置。</p><h3 id="Cross-compiler"><a href="#Cross-compiler" class="headerlink" title="Cross-compiler"></a>Cross-compiler</h3><p>可以生成（另一个）跨平台可执行文件的汇编器我们就说他是一个 <code>cross-compiler</code>。</p><h3 id="Source-to-source-compiler"><a href="#Source-to-source-compiler" class="headerlink" title="Source-to-source compiler"></a>Source-to-source compiler</h3><p>一般的编译器都是直接生成可执行的机器码，但是如果对于一个编译器他生成的是另一种高级编程语言的代码则称他是 <code>source-to-source</code> 的编译器。</p><h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><p>根据编译的不同方式主要可以分为两个部分：分析阶段和合成阶段。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/compiler_analysis_synthesis.jpg" alt="Analysis and Synthesis phase of compiler"></p><h2 id="Analysis-Phase"><a href="#Analysis-Phase" class="headerlink" title="Analysis Phase"></a>Analysis Phase</h2><p>编译器的前端。</p><p>读取源码，检验语法准确性。</p><p>生成中间状态的源代码以及 <strong>symbol table</strong> 作为 Synthesis Phase 的输入。</p><h2 id="Synthesis-Phase"><a href="#Synthesis-Phase" class="headerlink" title="Synthesis Phase"></a>Synthesis Phase</h2><p>编译器的后端</p><p>读取源码的中间表示形式以及 symbol table 生成机器代码**(target code)**。</p><h1 id="Phases"><a href="#Phases" class="headerlink" title="Phases"></a>Phases</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>需要区分一下基本的 Pass 和 Phase 的区别。</p><p>Pass 指的是编译器针对源程序的一次完整遍历。</p><p>而编译器的 Phase 指的是一次可区分的阶段，<strong>一次阶段通过读取上一阶段的输出作为输入，同时将这一阶段的输出作为下一阶段的输入。</strong></p><h2 id="Phases-of-compiler"><a href="#Phases-of-compiler" class="headerlink" title="Phases of compiler"></a>Phases of compiler</h2><p>编译器有不同的几个阶段，如下图：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/compiler_phases.jpg" alt="Phases of compiler"></p><h3 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h3><p>扫描源码为字符流，同时词法分析器(lexical analyzer)<strong>会读取源程序生成 token。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;token-name,attribute-value&gt;<br></code></pre></td></tr></table></figure><h3 id="Syntax-Analysis"><a href="#Syntax-Analysis" class="headerlink" title="Syntax Analysis"></a>Syntax Analysis</h3><p>检查词法分析器生成的 token 是否在语法上正确。</p><p><strong>语法分析器最终会生成 parse tree。</strong></p><h3 id="Semantic-Analysis"><a href="#Semantic-Analysis" class="headerlink" title="Semantic Analysis"></a>Semantic Analysis</h3><p>语义分析主要检查 语法分析树 是否遵循语法的规则。</p><p>例如检查变量赋值是否遵循这个语言规定的类型（类型是否能兼容）。</p><p>同时也会记录程序中声明的标识符等出现的情况（比如是否要求先声明所有变量之后再使用）。</p><p><strong>最终语义分析阶段会在语法分析树的基础上生成带有注释的语法分析树</strong>。</p><h3 id="Intermediate-Code-Generation"><a href="#Intermediate-Code-Generation" class="headerlink" title="Intermediate Code Generation"></a>Intermediate Code Generation</h3><p>生成介于高级编程语言和机器语言两者之间的汇编代码，要求这个汇编代码能够易于转化为机器码。</p><p>对于 gcc，我们有如下的操作来生成 intermediate code</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -s hello.c<br></code></pre></td></tr></table></figure><p>这里的 s 就表示 stop，表示到了这一阶段就停止。</p><h3 id="Code-Optimization"><a href="#Code-Optimization" class="headerlink" title="Code Optimization"></a>Code Optimization</h3><p>编译器的优化阶段，这一阶段的目的是为了让二进制程序运行所占用的资源更小。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -o<br></code></pre></td></tr></table></figure><p>这里的 <code>-o</code> 就是 optimize 开启编译器的优化阶段。</p><h3 id="Code-Generation"><a href="#Code-Generation" class="headerlink" title="Code Generation"></a>Code Generation</h3><p>将上一个阶段生成的优化后的汇编代码对应映射到机器码中并生成。</p><h3 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h3><p>这是在编译器的所有阶段都维护的一个<strong>数据结构</strong>。</p><p>所有标识符的名称以及类型都存储在这个表格中。</p><p>其作用在于让编译器更快速定位标识符和标识符的作用域管理。</p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS143</tag>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手把手教你同步PS2实机记忆卡和模拟器的存档</title>
    <link href="/2022/11/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%90%8C%E6%AD%A5PS2%E5%AE%9E%E6%9C%BA%E8%AE%B0%E5%BF%86%E5%8D%A1%E5%92%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84%E5%AD%98%E6%A1%A3/"/>
    <url>/2022/11/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%90%8C%E6%AD%A5PS2%E5%AE%9E%E6%9C%BA%E8%AE%B0%E5%BF%86%E5%8D%A1%E5%92%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84%E5%AD%98%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="食用情景"><a href="#食用情景" class="headerlink" title="食用情景"></a>食用情景</h1><p>前阵子在玩影之心，由于经常外出，所以PS2没有随身携带，因此在模拟器上推了一会。</p><p>由于最近又收了一台国行 50009 ，所以打算外出带薄机，家里放厚机，走的时候带上手柄和记忆卡就行。</p><p>但是模拟器打了一些进度，不想重新推了，相信有不少的怀旧玩家都有这样的困扰，<strong>模拟器虽然方便，CRT扫描线还原的效果也可以媲美实体彩监的效果，但是总还是想要在实际上把玩一番，满足自己的仪式感。但是实机和模拟器之间的存档同步一直是一个绕不过去的坎</strong>，因此记录一下如何把 PCSX2 的模拟器记忆卡数据同步到实机记忆卡中。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>注意，<strong>存档同步是基于FMCB记忆卡引导+uLanucher进行的</strong>，一般来说tb上买到的FMCB引导卡都会装有uLauncher。</p><p>1.可以启动FMCB引导程序并运行uLauncher的任何手段，可以是记忆卡引导启动，也可以是光盘引导，总之需要能让你的PS2运行FMCB引导并且装好了uLauncher，我这里是用tb上买的记忆卡引导。</p><p>2.<strong>任意型号的PS2一台</strong>（可以是厚机也可以是薄机，和机器有无直读完全没关系，但是最好直读别和FMCB引导冲突，比如我的那台薄机，直读会和FMCB冲突，而且也不知道直读怎么关掉，每次进不去引导界面只能盲选OPL和uLauncher），我这里是70011。</p><p>3.电脑一台。</p><p>4.USB设备一个，能被PS2识别的就行，最好不要和FMCB冲突（所谓和FMCB冲突就是如果USB设备插着PS2，同时FMCB引导卡也插着PS2，那么如果开机一直卡在FMCB的界面就表示USB设备兼容性不行，<strong>解决方案是先把USB拔了，等FMCB引导启动进入自制系统后再插入USB</strong>）。</p><h1 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h1><h2 id="定位模拟器记忆卡"><a href="#定位模拟器记忆卡" class="headerlink" title="定位模拟器记忆卡"></a>定位模拟器记忆卡</h2><p>我们首先需要定位到PCSX2的模拟器存档位置，可以直接通过主界面的导航栏直接查看。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20220927100536242.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20220927100618649.png"></p><p>之后我们就可以看到模拟器创建的记忆卡了，<strong>记住这个路径，下面要用</strong>。</p><p><strong>注意：下面的一定要仔细看！</strong></p><p>由于PCSX2在1.6Release之后推出了文件夹格式的记忆卡形式，使用文件夹格式的记忆卡更加方便进行实机和模拟器的存档转移，因此下面会依据不同的存档形式来分为两条分支进行讲解。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221103144821255.png" alt="1.6Release之后推出的文件夹格式的记忆卡形式"></p><ul><li>分支一：【默认情况】没有使用文件夹形式的 PCSX2 存档。</li><li>分支二：使用了文件夹形式的 PCSX2 存档。</li></ul><h2 id="分支一：没有使用文件夹形式的-PCSX2-存档"><a href="#分支一：没有使用文件夹形式的-PCSX2-存档" class="headerlink" title="分支一：没有使用文件夹形式的 PCSX2 存档"></a>分支一：没有使用文件夹形式的 PCSX2 存档</h2><h3 id="运行-mymc"><a href="#运行-mymc" class="headerlink" title="运行 mymc"></a>运行 mymc</h3><p><a href="http://www.csclub.uwaterloo.ca:11068/mymc/">http://www.csclub.uwaterloo.ca:11068/mymc/</a></p><p>mymc是一个可以提取模拟器记忆卡内容的工具，通过上述链接可以直接进入下载 release 版本，直接运行 gui</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20220927100840646.png"></p><p>每次进入都会要你直接选择ps2模拟器记忆卡位置，还记得上面我们提到的路径吗，直接找到打开你需要复制存档的那个记忆卡</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20220927100939167.png"></p><p>之后点击<code>export</code>，会生成一个psu文件，这个文件就是<strong>用于在实机的记忆卡中解包存档数据的文件</strong></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20220927101027892.png"></p><p>记住把 psu 文件保存到 usb 设备中，此时电脑的步骤就完成了</p><h3 id="运行uLauncher"><a href="#运行uLauncher" class="headerlink" title="运行uLauncher"></a>运行uLauncher</h3><p>插上引导卡&#x2F;引导盘，为了防止USB设备不兼容，<strong>建议进入到引导界面之后再插入USB设备</strong>。</p><p>进入 FMCB 中的 uLauncher。</p><p>再根目录下找到自己USB设备的位置，都是<code>/mass</code>目录。</p><p>之后找到刚刚导出的<code>psu</code>文件，按下<code>R1</code>,跳出选项卡，之后选择<code>copy</code></p><p>由于uLauncher本质是一个文件管理器，可以读取ps2所有外接设备包括记忆卡，因此我们可以返回根目录，找到自己要复制到的记忆卡的具体哪一个插槽（第一个卡槽是mc0，第二个卡槽是mc1）点击进入。</p><p>再次按下<code>R1</code>,选择<code>paste psu</code>，这个时候就会自动解包生成对应游戏的存档目录（注意，如果你和我之前一样有过这个游戏的存档，那么会问你是否覆盖，点击yes就行）</p><p>之后重启进入游戏，可以看到存档确实是和模拟器中的同步了</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/Snipaste_2022-09-27_10-00-32.png"></p><h2 id="分支二：使用了文件夹形式的-PCSX2-存档"><a href="#分支二：使用了文件夹形式的-PCSX2-存档" class="headerlink" title="分支二：使用了文件夹形式的 PCSX2 存档"></a>分支二：使用了文件夹形式的 PCSX2 存档</h2><p>如果你在之前初始化记忆卡的时候选择了文件夹形式的记忆卡，或者是看完这篇文章之后你新建了一个文件夹形式的记忆卡并且用这个记忆卡玩了一会想同步到实机上，那么恭喜你，过程会十分的方便。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221103145450140.png"></p><p>我们直接进入到这个文件夹形式的PCSX2记忆卡中，可以看到以游戏编号命名的文件夹。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221103145517080.png"></p><p>这些文件夹其实就是一个个存档了，PS2记忆卡支持直接识别，不需要任何其他工具，我们直接复制到USB设备中，此时电脑的步骤就完成了。</p><h3 id="运行uLauncher-1"><a href="#运行uLauncher-1" class="headerlink" title="运行uLauncher"></a>运行uLauncher</h3><p>插上引导卡&#x2F;引导盘，为了防止USB设备不兼容，<strong>建议进入到引导界面之后再插入USB设备</strong>。</p><p>进入 FMCB 中的 uLauncher。</p><p>再根目录下找到自己USB设备的位置，都是<code>/mass</code>目录。</p><p>之后找到刚刚导出的<code>psu</code>文件，按下<code>R1</code>,跳出选项卡，之后选择<code>copy</code></p><p>由于uLauncher本质是一个文件管理器，可以读取ps2所有外接设备包括记忆卡，因此我们可以返回根目录，找到自己要复制到的记忆卡的具体哪一个插槽（第一个卡槽是mc0，第二个卡槽是mc1）点击进入。</p><p>再次按下<code>R1</code>,选择<code>paste psu</code>，这个时候就会自动解包生成对应游戏的存档目录（注意，如果你和我之前一样有过这个游戏的存档，那么会问你是否覆盖，点击yes就行）</p><p>之后重启进入游戏，可以看到存档确实是和模拟器中的同步了</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/Snipaste_2022-09-27_10-00-32.png"></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PS2</tag>
      
      <tag>FMCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-18.06|Assignment1&amp;2</title>
    <link href="/2022/10/30/MIT-18-06-Assignment1-2/"/>
    <url>/2022/10/30/MIT-18-06-Assignment1-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Assignment1"><a href="#Assignment1" class="headerlink" title="Assignment1"></a>Assignment1</h1><p>主要考察的是关于 Lecture1 中出现的一些 Linear Combination 的最基本概念，以及判断在 <strong>Column Picture</strong> 中多个列向量是否可以进行 Linear Combination 来<strong>间接判断方程组是否有解</strong>。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>主要问题在第一题，第二题是计算。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221030094308541.png"></p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>主要是这里没有注意看题目的问法，人家都说了要你找出一组 combination 了，我还在想着说初看 <code>w1+w2</code> 并不能得到 <code>w3</code>，因此就直接说他们是 <strong>independent</strong> 的了，确实是有点粗心。</p><p>实际上我们可以很容易的得到：<code>w1 + w3 = 2 * w2</code>。</p><p>换言之 w1 w2 w3 三个里面的两个确实是可以通过 Linear Combination 来得到剩下的一个，满足这个条件，说明他们其实不能算是空间中的一组<strong>基底</strong>，因此也就是非独立的(dependent)。这三个向量实际上是在一个平面而不是在一个 space 中。</p><h1 id="Assignment2"><a href="#Assignment2" class="headerlink" title="Assignment2"></a>Assignment2</h1><p>主要考察的是矩阵的消元，同时第二题也着重复习了如何通过 Linear Combination 的思想来通过 <strong>矩阵乘法</strong> 快速进行矩阵的消元。</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>主要问题在第二题，第一题是简单消元计算题。</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221030095130643.png"></p><h2 id="详解-1"><a href="#详解-1" class="headerlink" title="详解"></a>详解</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>可以说已知条件就给了一个E右乘一个矩阵进行第一列的消元。那么我们其实可以直接通过教授在 Lecture2 上的重点思想来快速得出：</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221030100945738.png"></p><p>具体为什么可以参考 Lecture 2 的笔记，本质其实就是通过 行的左乘进行 Linear Combination 来实现快速消元。</p><p>然后题目问的是现在通过多次进行类似 E 的操作，可以将原始的矩阵最终化简为单位矩阵 I ，求多次类型E的操作，其实也就是多次左乘 E 最终的化简为一个矩阵一步到位的 M 是多少。</p><h3 id="第二列化简"><a href="#第二列化简" class="headerlink" title="第二列化简"></a>第二列化简</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221030101005249.png"></p><h3 id="第三列化简"><a href="#第三列化简" class="headerlink" title="第三列化简"></a>第三列化简</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221030101024429.png"></p><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221030101038217.png"></p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT</tag>
      
      <tag>Linear Algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TED|How NOT taking things PERSONALLY</title>
    <link href="/2022/10/19/TED-How-NOT-taking-things-PERSONALLY/"/>
    <url>/2022/10/19/TED-How-NOT-taking-things-PERSONALLY/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://www.bilibili.com/video/BV13G4y1x7S1">TED|如何学会别把事都往心里去？</a></p><p>本次演讲的主讲人是一名足球裁判，他向我们讲述了<strong>如何在生活中做到不把任何事都往心里去</strong>。</p><p>这个主讲的老哥很有场景感，发音也十分标准，虽然部分和场下观众的互动在我个人看来显得有点尴尬XD，但是整体而言这篇演讲内容很值得回味，在结合自身足球裁判的经历讲述我们常常会在生活中把一些事情都往心里去之后，给出了两个针对策略，两个如何做到不想太多，停止焦虑内耗。</p><p>同时这篇演讲发音标准语速适中，适合进行英语听力精听练习~</p><h1 id="我们为什么会把任何事都往心里去"><a href="#我们为什么会把任何事都往心里去" class="headerlink" title="我们为什么会把任何事都往心里去"></a>我们为什么会把任何事都往心里去</h1><h2 id="中国人看来的面子问题"><a href="#中国人看来的面子问题" class="headerlink" title="中国人看来的面子问题"></a>中国人看来的面子问题</h2><p>中国人一直有一句话个人认为很好地概括了有些人（比如我自己XD)常常都把事情挂在心上,究其原因在于：还是考虑到个人的<strong>面子问题。</strong></p><p>这里的面子其实指的就是我们的自尊心。</p><p>比如，在你准备停车的时候寻找合适的位置，突然被后面的司机喇叭催了几下，这个时候你就会觉得，好像我做错了什么。</p><p>当你在台上演讲的时候，发现底下的人在玩手机，这个时候你把这件事往心里去了。</p><p>又或者当你在和别人分享今天一些很头疼的遭遇的时候，对方表示出一副不感兴趣的样子，并没有理会你，这时候你又把这件事往心里去了。</p><p>这有一部分其实是归咎于我们的自尊心(ego)，还有另一部分就在于我们想的太多。</p><h2 id="想得太多的危害"><a href="#想得太多的危害" class="headerlink" title="想得太多的危害"></a>想得太多的危害</h2><p>虽然说三思而后行，适当思考是好事，但是想得太多往往就会带来更多的压力。</p><ul><li>想得太多会让我们感到无从下手，进而形成<strong>焦虑</strong>，甚至是无限的精神内耗。</li><li>事事都往心里去，任何一个自己犯的错，<strong>受到批评了都觉得天要塌下来了</strong>。</li><li>每次和别人说话，事后都觉得自己做的不对，把刚刚的谈话挂在心上，这样会<strong>活得很累</strong></li></ul><h1 id="别把任何事都往心里去的两种方法"><a href="#别把任何事都往心里去的两种方法" class="headerlink" title="别把任何事都往心里去的两种方法"></a>别把任何事都往心里去的两种方法</h1><h2 id="It’s-not-about-me"><a href="#It’s-not-about-me" class="headerlink" title="It’s not about me"></a>It’s not about me</h2><p>简而言之就是，这<strong>一切都不关我的事</strong>。</p><p>我们想的太多，把任何事情都往心里去，主要在于我们一直都是<strong>站在我自己的角度</strong>来思考问题。</p><p>为什么我在演讲的时候别人会在看手机，不妨试试站在对方的角度看问题，把 <code>Me</code> 转换成 <code>We</code> 的角度。</p><ul><li>有可能是我的演讲对于他而言不感兴趣。</li><li>又或者恰恰相反是他觉得很感兴趣，准备记笔记或是和别人打字分享。</li></ul><p>如果这么想，是不是就不会觉得事事都往心里去了呢？</p><hr><p>因此第一种做到不把事情往心里去的措施就是</p><blockquote><p>It’s not about me , look at the other person’s intension.</p></blockquote><p>这种方法要求我们需要不断地练习，正如主讲人所说。在每次比赛前他都会告诉自己，不要把观众对他的恶意辱骂挂在心上，因为<strong>他们只是希望自己是正确的，他们只是希望自己支持的球队赢得比赛</strong>。</p><p>人的大脑一天会产生5w多条的想法，但是好的想法只有30％，因此当我们发现别人谈话的时候正好看着我们，我们可能会本能地认为，他们是不是在背后说我的坏话。这个时候，我们就又往心里去了。正确的回应应该是，<strong>他们说的和我一点关系都没有，不关我的事</strong>。</p><h2 id="It’s-about-me"><a href="#It’s-about-me" class="headerlink" title="It’s about me"></a>It’s about me</h2><p>但是上述的方式不一定万用，<strong>有的时候事情真的与我们有关，确实是我们做错了</strong>。</p><p>当你犯错的时候，受到别人的批评，那可能确实是我们存在一些问题</p><p>这个时候另一种的思考方式就是：</p><blockquote><p>It is about me.Give yourself empathy.Speak up.</p></blockquote><p>同情自己，将自己心中的问题说出来，让别人能刚好的理解你，这个时候才不会一直挂在心上，解决了问题也会解决精神内耗。</p><h1 id="你的价值不会因他人的言语而改变"><a href="#你的价值不会因他人的言语而改变" class="headerlink" title="你的价值不会因他人的言语而改变"></a>你的价值不会因他人的言语而改变</h1><p>最后演讲者以一个金钱的实际案例为例，提出了一个观点：</p><p>无论别人对你说了什么，都不能改变你自身的价值，<strong>所以不断认清自己，提升自己的价值才是王道</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>TED</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语口语</tag>
      
      <tag>职场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Design Pattern|代理模式-01</title>
    <link href="/2022/10/18/Design-Pattern-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-01/"/>
    <url>/2022/10/18/Design-Pattern-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-01/</url>
    
    <content type="html"><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>代理模式需要解决的问题其实很简单，有些代码是第三方库，我们修改不能，因此需要一个代理模式在此基础上进行横向增强。</p><p>或者类比生活中的例子，买房子要找中介，上课没来找个好兄弟帮你代点名，等等。</p><p>此部分仅仅从很简单浅显的角度来进行理解静态代理的设计模式，作为一个 quick start ，后续会深入理解动态代理等部分。</p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>主要是有三个成员，这里我们以<strong>上课的时候某同学没来，找好兄弟代点名</strong>为例作为背景</p><h2 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h2><p>可以简单理解为表示的是一个能力，比如我们代理同学上课点名，这个能力就是喊<code>到</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CheckAttandance</span>()&#123;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayAttand</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><p>这个实现类在这个背景中就是指：这个应该来的同学，它实现了喊<code>到</code>的这个接口，可以喊<code>到</code>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStudent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CheckAttandance</span>&#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayAttand</span><span class="hljs-params">()</span>&#123;<br>          System.out.println(<span class="hljs-string">&quot;老师我到了&quot;</span>);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h2><p>这个情景中指的是我们代点名的同学，在代理模式中他叫做代理对象</p><p>代理对象一般需要显式声明被代理的对象，作为一个内部成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CheckAttandance</span>&#123;<br>     <span class="hljs-comment">//持有我们的代理类</span><br>     <span class="hljs-keyword">static</span> ConcreteStudent student;<br>     <br>     <span class="hljs-comment">//横向增强</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">minusVoice</span><span class="hljs-params">()</span>&#123;<br>          System.out.println(<span class="hljs-string">&quot;使用消音器&quot;</span>);<br>     &#125;<br>     <br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayAttand</span><span class="hljs-params">()</span>&#123;<br>          minusVoice();<br>          <span class="hljs-comment">//延迟初始化</span><br>          <span class="hljs-keyword">if</span>(student==<span class="hljs-literal">null</span>)&#123;<br>               student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStudent</span>();<br>          &#125;<br>          student.sayAttand();<br>     &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyDemo</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Proxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>();<br>      proxy.sayAttand();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">使用消音器<br>老师我到了<br></code></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>上述的思路分析中其实已经可以看出一些代理模式的影子了</p><p>下面给出代理模式另一个常用的场景————<strong>代理某个对象实现延迟初始化</strong>，代码抽象出一些比较通用可被替换的操作，希望能活学活用</p><h2 id="某个接口-x2F-抽象类"><a href="#某个接口-x2F-抽象类" class="headerlink" title="某个接口&#x2F;抽象类"></a>某个接口&#x2F;抽象类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeWork</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="某一个具体实现类"><a href="#某一个具体实现类" class="headerlink" title="某一个具体实现类"></a>某一个具体实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span><br>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeWork</span><span class="hljs-params">()</span> <br>&#123;<br>System.out.println(<span class="hljs-string">&quot;doSomeWork() inside ConcreteSubject is invoked.&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代理类-1"><a href="#代理类-1" class="headerlink" title="代理类"></a>代理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Subject</span><br>&#123;<br>     <span class="hljs-comment">//持有被代理的对象</span><br><span class="hljs-keyword">static</span> Subject cs;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomeWork</span><span class="hljs-params">()</span> <br>&#123;<br>System.out.println(<span class="hljs-string">&quot;Proxy call happening now...&quot;</span>);<br><span class="hljs-comment">// 代理的横向增强，进行延迟初始化</span><br><span class="hljs-keyword">if</span> (cs == <span class="hljs-literal">null</span>)<br>&#123;<br>cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>&#125;<br>          <span class="hljs-comment">//调用被代理对象真正进行方法调用</span><br>cs.doSomeWork();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试调用"><a href="#测试调用" class="headerlink" title="测试调用"></a>测试调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyPatternExample</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Proxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>();<br>proxy.doSomeWork();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Framework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TED|如何应对焦虑</title>
    <link href="/2022/10/13/TED-%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E7%84%A6%E8%99%91/"/>
    <url>/2022/10/13/TED-%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E7%84%A6%E8%99%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇地址：<a href="https://www.bilibili.com/video/BV15b411L7M4">TED演讲：如何解决焦虑？</a></p><p>此篇文章为个人观点+学习感悟随笔</p><p>这一期的主题是如何应对生活中的焦虑，演讲者是一个很有气质的大姐姐（确实好看），从如何正确认识焦虑，提出应对焦虑的三种措施，最后进行了总结</p><p>整篇下来语速很慢，发音标准，可以作为英语听力&#x2F;原文阅读理解来练习:)</p><hr><p>我们每个人在生活中多少都会收到他人的影响，因为我们在生活中就是不断地与他人进行打交道，在这个过程中一定会收到很多影响和干扰。</p><p>比如，XXX又获得了XX奖项，和你一起学习的同学又拿到了XXX的实习offer，上头又交给你了XX工作任务，要求很严格，不知道能否按时完成，等等…</p><p>在上述的情景中，我们多少会收到这样那样的影响，然后产生一定程度上的自我否定，从最开始的正常焦虑心理（比如未来工作规划的如何），慢慢地演变，当焦虑一直放大达到极致的时候，就会出现<strong>焦虑症。</strong></p><h1 id="焦虑症的影响"><a href="#焦虑症的影响" class="headerlink" title="焦虑症的影响"></a>焦虑症的影响</h1><p>这一部分主要是简单说一下焦虑、焦虑症的影响和危害。</p><h2 id="正常的焦虑心理"><a href="#正常的焦虑心理" class="headerlink" title="正常的焦虑心理"></a>正常的焦虑心理</h2><p>正常的焦虑其实没有特别大的坏处，只要我们正确应对，<strong>正常的焦虑心理是有积极作用的。</strong></p><ul><li>例如我们在危险情况下，比如面对一只熊，处于本能和自我保护意识，我们会选择逃跑，这就是正常焦虑心理的一个体现，处于焦虑，为自己的生命安全而焦虑，选择了逃跑，虽然在熊面前逃跑并不能算是一个很明智的选择（</li><li>正常的焦虑心理还可以促进我们的学习，工作进度，比如发现 deadline 要来了，我们此时处于焦虑心理，会比往常更加集中注意力，更加专注于工作上。</li></ul><h2 id="焦虑症"><a href="#焦虑症" class="headerlink" title="焦虑症"></a>焦虑症</h2><p>而当焦虑心理发挥到极致的时候，正常的焦虑心态就会演变为焦虑症。</p><p>患有焦虑症的人<strong>对于生活中的所有事情都过分的关注。</strong></p><p>他们往往<strong>更难集中注意力于日常学习和工作中</strong>，而把自己大部分的时间都放在思考上，思考多了就变成了焦虑，最终导致工作绩效差，往往很难保住自己的工作。</p><h1 id="焦虑症的应对措施"><a href="#焦虑症的应对措施" class="headerlink" title="焦虑症的应对措施"></a>焦虑症的应对措施</h1><p>焦虑症的应对措施(coping skills)其实是可以<strong>锻炼</strong>出来的(主讲人当时用 develop 一词来形容)</p><p>我们感受到的焦虑程度一定程度上和我们是否具有应对焦虑(cope with anxiety)的技能相关。</p><p>主讲人主要从三个方面讲述如何应对焦虑。</p><h2 id="Do-it-badly"><a href="#Do-it-badly" class="headerlink" title="Do it badly"></a>Do it badly</h2><p>你是否常常面对手上的任务时，苦于思考如何实现（比如这个需求如何做），但是在思考的过程中发现还有很多的知识没有学，于是开始感到焦虑，思考了很多的学习方法，然后….然后就没有然后了。</p><p>我们一直在想着如何去实现，这似乎在我们看来一定要是完美的完成这一个需求&#x2F;任务。</p><p>但是我们却<strong>一直停留在思考，最后发现啥也没做成。</strong></p><p><strong>想太多会让我们本能地拖延推迟，最终导致没有取得一定的进度</strong>。</p><p>这里主持人大姐姐通过引用一句名言论证了这一观点：</p><blockquote><p>Anything worth doing is worth doing badly the first time.</p><p>任何一件值得做的事情在第一次去做的时候值得做的不是那么的完美。</p></blockquote><p>这也是本站点现在的 slogan，我个人其实是十分收到启发的。</p><p>我们总想着在一个完美的状态，掌握完美的技能知识后，完美地完成需求，但是在不断的思考中也会让我们推迟行动。</p><p>如果我们一开始就直接动手行动，虽然可能做的很<code>烂</code>，但是当我们自以为很<code>烂</code>地完成了这一部分需求后，再回头看，其实也没有那么的<code>烂</code>。</p><h2 id="Forgive-yourself"><a href="#Forgive-yourself" class="headerlink" title="Forgive yourself"></a>Forgive yourself</h2><p>主持人大姐姐提出的另一个措施是：学会原谅自己。</p><p>但是在这里我更觉得应该是学会<strong>悦纳自己</strong>。</p><p>我们常常会觉得，自己因为某些原因，可能事情发生之后，觉得表现的不好，做的很差，因此陷入了纠结焦虑之中。或者在和他人进行比较之后，觉得自己很差，甚至是一无是处。</p><p>主持人提出我们应该<code>start being kinder with ourselves</code>，学会接收自己的不足，认识自己的不足，改进自己的不足。</p><p>为什么别人xxx又拿了xxx的offer，而我没有？</p><p><strong>学会接受自己，学会原谅自己的不足，接受自己的不完美，同时也不要盲目和他人比较，甚至是否定自己</strong>。</p><h2 id="Having-purpose-and-meaning-in-life"><a href="#Having-purpose-and-meaning-in-life" class="headerlink" title="Having purpose and meaning in life"></a>Having purpose and meaning in life</h2><p>最后主持人大姐姐提出了要对生活有目标，有意义，有希望。</p><p>即使我们现在做的可能是一些看起来没有意义的事情，但是只要我们和他人分享，或者对于自己而言是有意义的，那么在这个过程中我们就不会因为外界的七七八八而感到焦虑。</p>]]></content>
    
    
    <categories>
      
      <category>TED</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语口语</tag>
      
      <tag>职场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-18.06|02-Elimination</title>
    <link href="/2022/10/12/MIT18-06-02-Elimination/"/>
    <url>/2022/10/12/MIT18-06-02-Elimination/</url>
    
    <content type="html"><![CDATA[<h1 id="消元Elimination"><a href="#消元Elimination" class="headerlink" title="消元Elimination"></a>消元Elimination</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本次 Lecture 主要讲解如何<strong>运用消元法系统化地求解</strong></p><p>什么时候消元法有效，什么时候失效？</p><p>整门课程其实用到最多的是<strong>矩阵变换</strong></p><h2 id="矩阵消元具体操作"><a href="#矩阵消元具体操作" class="headerlink" title="矩阵消元具体操作"></a>矩阵消元具体操作</h2><h3 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h3><p>首先这部分教授提出了一些专有名词定义</p><ul><li>主元 <code>pivot</code></li><li>行列式 <code>determinant</code></li></ul><p>其中：</p><ul><li>主元是我们自己定义的，如果出现系数矩阵中<strong>某一行主元为0</strong>的情况，那么我们可以在通过<strong>向下置换</strong>来实现</li><li>行列式&#x3D;主元的乘积，这里教授只是简单引出，后续还会深入讲解</li></ul><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004101754850.png" alt="image-20221004101754850" style="zoom:50%;" /><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004102005619.png" alt="image-20221004102005619"></p><p>同时我们最终可以得到原来系数矩阵A通过消元得到的上三角矩阵U(Upper Triangular)</p><p>其中方框中标出的就是我们的主元，主元是我们自己定义的，如果出现系数矩阵中<strong>某一行主元为0</strong>的情况，那么我们可以在通过<strong>向下置换</strong>来实现</p><h3 id="消元失效的情况"><a href="#消元失效的情况" class="headerlink" title="消元失效的情况"></a>消元失效的情况</h3><p>正如上面所说，当想要消元得出主元的时候发现主元也消掉，出现主元为0的情况，我们就可以通过向下交换</p><p>当然<strong>如果下面没有了，出现最后一行主元为0的情况，此时消元就失效了，方程无解</strong></p><p>换句话说，n*n的矩阵中如果主元个数最终通过置换还是不为n，那么此时消元就失效了</p><h3 id="增广矩阵回代"><a href="#增广矩阵回代" class="headerlink" title="增广矩阵回代"></a>增广矩阵回代</h3><p>教授这里将右边的b在初次消元时不带入，最终以<code>Argument Matrix</code>的形式接入，但是实际上还是需要遵循因消元而产生<strong>的倍增倍缩</strong>情况进行计算，最终得到一个<code>c</code>，<strong>c对应b正如U对应A一样</strong></p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004103900881.png" alt="image-20221004103900881" style="zoom:50%;" /><p>求到了这里之后就可以进行最后的回代了，原来的<code>Ax=b</code>现在已经转化为了<code>Ux=c</code></p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004104051046.png" alt="image-20221004104051046" style="zoom:50%;" /><h2 id="从矩阵乘法的角度来看消元"><a href="#从矩阵乘法的角度来看消元" class="headerlink" title="从矩阵乘法的角度来看消元"></a>从矩阵乘法的角度来看消元</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>首先教授进行了一个<strong>从线性代数本质来看矩阵操作的前置科普</strong></p><p>主要是行和列和线性组合</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004151141485.png" alt="image-20221004151141485"></p><p>这里其实就涉及到了线性代数中核心概念：<strong>分别使用行（左乘）和列（右乘）进行矩阵操作。</strong></p><h3 id="矩阵乘法进行消元"><a href="#矩阵乘法进行消元" class="headerlink" title="矩阵乘法进行消元"></a>矩阵乘法进行消元</h3><p>在上述的基础上，教授提出了如何进行消元，可以这么理解</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004151455843.png" alt="image-20221004151455843"></p><p>对于原始的系数矩阵A进行左乘操作，采用行的线性组合</p><p>[1,0,0]表示的是新结果（也就是右边）的第一行，<strong>行的线性组合应该是1倍的原来矩阵第一行+0倍的原来矩阵第二行+0倍的原来矩阵第三行</strong></p><p>同理第三行[0,0,1]表示的是新矩阵的第三行</p><blockquote><p>这也是为什么说[[1,0,0],[0,1,0],[0,0,1]]是单位矩阵，也可以从这个角度进行理解</p></blockquote><p>最重要的由于我们这里需要消元的是A<del>21</del>，因此最终要的是第二行的操作，想要消元A<del>21</del>，我们就<strong>需要让-3*第一行+第二行，而不需要第三行参与，因此这里就是[-3,1,0]</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><a href="https://rqtn.github.io/2019/08/11/LA-Lec02/">这里参考大佬的总结👇</a></p><p><strong>一个指定位置的消元不过是一次行的线性组合</strong></p><h2 id="从行的线性组合理解置换矩阵和逆矩阵"><a href="#从行的线性组合理解置换矩阵和逆矩阵" class="headerlink" title="从行的线性组合理解置换矩阵和逆矩阵"></a>从行的线性组合理解置换矩阵和逆矩阵</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>有了上述的前置条件，其实我们就很清楚如何实现矩阵的置换以及矩阵的逆操作了</p><p>教授在最后进行整篇 Lecture 的补充</p><h3 id="置换矩阵"><a href="#置换矩阵" class="headerlink" title="置换矩阵"></a>置换矩阵</h3><p>不需要死记硬背，这个其实很好理解</p><p>相当于说我们让新的第一行&#x2F;列是原来的第二行&#x2F;列，新的第二行&#x2F;列是原来的第一行&#x2F;列，</p><h4 id="行置换"><a href="#行置换" class="headerlink" title="行置换"></a>行置换</h4><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004152329517.png" alt="image-20221004152329517"></p><p>注意是<strong>左乘操作进行 行的线性组合</strong></p><h4 id="列置换"><a href="#列置换" class="headerlink" title="列置换"></a>列置换</h4><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004152638894.png" alt="image-20221004152638894"></p><p>注意是<strong>右乘操作进行 列的线性组合</strong></p><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>逆矩阵需要注意和转置矩阵进行区分</p><p>逆矩阵的本质其实就是为了<strong>撤销之前的行变换合并操作</strong></p><h4 id="如何计算"><a href="#如何计算" class="headerlink" title="如何计算"></a>如何计算</h4><p>对于一个 3×3 的 矩阵 A，当我们左乘一个 E 矩阵就表示对 A 进行一次行的线性组合，是一次<strong>行变换</strong>，具体变换操作是将 −3 倍的第一行和第二行相加得到新的第二行，而第一行和第三行保持不变</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004152940158.png" alt="image-20221004152940158"></p><p>如果想要撤销其实只需要把之前加回去的给他减掉其实就行了</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221004153054618.png" alt="image-20221004153054618"></p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT</tag>
      
      <tag>Linear Algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-18.06|01-Linear Combination</title>
    <link href="/2022/10/12/MIT-18-06-01-Linear-Combination/"/>
    <url>/2022/10/12/MIT-18-06-01-Linear-Combination/</url>
    
    <content type="html"><![CDATA[<h1 id="方程组的几何解释"><a href="#方程组的几何解释" class="headerlink" title="方程组的几何解释"></a>方程组的几何解释</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>从最经典的n个未知数n个方程开始讲起(一定有解！)</p><p>可以从三个维度进行描述</p><ul><li>row pic </li><li>column pic</li><li>matrix form</li></ul><h2 id="最简单的二元一次方程"><a href="#最简单的二元一次方程" class="headerlink" title="最简单的二元一次方程"></a>最简单的二元一次方程</h2><h3 id="这里情不自禁直接把-Matrix-Form-给写出来了"><a href="#这里情不自禁直接把-Matrix-Form-给写出来了" class="headerlink" title="这里情不自禁直接把 Matrix Form 给写出来了"></a>这里情不自禁直接把 Matrix Form 给写出来了</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20220716231556969.png" alt="image-20220716231556969"></p><h3 id="row-pic"><a href="#row-pic" class="headerlink" title="row pic"></a>row pic</h3><p>核心在于针对我们的方程组，<strong>一次只取一行</strong>，作图于xy平面</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20220717162929274.png" alt="image-20220717162929274" style="zoom:50%;" /><p>通过作图我们就可以得到，两条直线的交点就是方程组的解(1,2)(对应未知数矩阵)</p><h3 id="column-pic"><a href="#column-pic" class="headerlink" title="column pic"></a>column pic</h3><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20220717163118372.png" alt="image-20220717163118372" style="zoom:50%;" /><p>方法是一列一列获取元素，本质是通过<strong>把系数矩阵 A 进行拆分</strong>，但是右边的 b 不变</p><p>现在的问题就转换为<strong>找到一组合适的组合&#x2F;解x和y，可以使得等式成立</strong></p><p>也即 <strong>AxAx 就是对 AA 的列向量进行 xx 对应的组合（这种组合显然是线性的）</strong></p><p>这个思想方法是后来很重要的一个<code>线性组合</code>(linear combination)</p><p>这里有两个列式向量[2,-1]和[-1,2]，我通过x和y<strong>以某种线性的方式来进行组合相加</strong>，这就是 <code>linear combination</code></p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221003144602224.png" alt="image-20221003144602224" style="zoom:50%;" /><p>通过作图，我们可以很容易的得出结果，蓝色实线与红色实线作为不平行的二维空间基底，可以通过构造2x红色+1x蓝色来得到最终的 b 向量</p><h2 id="延伸到三元一次方程"><a href="#延伸到三元一次方程" class="headerlink" title="延伸到三元一次方程"></a>延伸到三元一次方程</h2><p>教授给出了一副三元一次方程</p><p>三个未知数，三个方程，一定有解！</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221003150456022.png" alt="image-20221003150456022" style="zoom:50%;" /><h3 id="Row-pic"><a href="#Row-pic" class="headerlink" title="Row pic"></a>Row pic</h3><p>这种方式直接进行画图其实就比较难了，由于现在是三维空间，每一行取出来都是表示一个三维空间的平面(plane)，因此画图很困难，<strong>无法直接通过每一行进行作图来画出解</strong></p><p>不过值得明确的是，由于这三个平面一定不会平行，因此三个平面相交，一定是可以确定一个三维空间的点的，一定是有解！</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221003150537428.png" alt="image-20221003150537428" style="zoom:33%;" /><h3 id="Column-pic"><a href="#Column-pic" class="headerlink" title="Column pic"></a>Column pic</h3><p>通过将系数矩阵A的列进行提取，我们可以得到下面的column pic</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221003150555101.png" alt="image-20221003150555101" style="zoom: 50%;" /><p>由于老师这里专门设计了一下，我们一眼就能看出原方程组的解为(0,0,1)，这也从侧面体现出了，采用<code>column pic</code>作为解决方式的快捷与直观</p><p>教授也引出了一个探讨的话题：</p><blockquote><p>对于<code>Ax=b</code>，是不是对于任何的b都有解？</p><p>如果用线性组合(<code>linear combination</code>)的角度来看待这个问题，问题也可以转化为：系数矩阵中每一列的线性组合是否可以覆盖全部的空间(在这里三元是对应三维空间)</p></blockquote><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221003151113109.png" alt="image-20221003151113109" style="zoom:50%;" /><p>这其实是取决于我们的A的，因为在 <code>Column pic</code> 中，如果是三元方程组，理论上有解的 column pic 中一定是<strong>存在三个互不共面的向量来作为三个基底的</strong>，如果发现题目给的数据中存在三个向量abc，其中c可以通过ab的线性组合得来，说明他们就不共面了，<strong>因此实际上相当于你只有两个有效的方程组，三个未知数，是没有唯一解的</strong></p><h2 id="延申问题到九维空间"><a href="#延申问题到九维空间" class="headerlink" title="延申问题到九维空间"></a>延申问题到九维空间</h2><p>还是那个问题，对于<code>Ax=b</code>，是不是对于任何的b都有解？</p><p>通过迁移，其实我们也可以举一反三了，只要系数矩阵中的9个列元素都可以作为九维空间的基底（不存在说其中的某一个可以被剩下八个向量表示的情况）那么我们就一定可以通过<code>linear combination</code>来对这九个向量组合，得到空间的任意一个向量b</p><h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h2><p>由于之前提到过矩阵的<code>Matrix Form</code>，因此教授还对矩阵的乘法，形如<code>Ax=b</code>的乘法来进行一个讲解</p><p>例题如下：</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20221003151348896.png" alt="image-20221003151348896" style="zoom: 33%;" /><p>从<code>row pic</code>以及<code>column pic</code>的角度出发，其实还是有两种角度来看待</p><h3 id="row-pic的角度"><a href="#row-pic的角度" class="headerlink" title="row pic的角度"></a>row pic的角度</h3><p>row pic 的核心思想在于一次取一行，因此我们取第一行[2,5]，点乘[1,2]^T^，得到的就是2*1+5*2&#x3D;12</p><p>同理下面的就是1*1+3*2&#x3D;7</p><h3 id="column-pic的角度"><a href="#column-pic的角度" class="headerlink" title="column pic的角度"></a>column pic的角度</h3><p>column pic的思想在于每次取的是系数矩阵的每一列，而最核心的辅助于他的实际上是<code>linear combination</code>这个核心概念</p><p>我们在乘法的时候也可以运用上这个核心的思想</p><p>上述的题目就相当于是：最终的结果&#x3D;1倍的[2,1]与2倍的[5,3]进行<code>linear combination</code>组合得来的，直接秒杀得到[12,7]</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>教授通过上述的问题在第一节课就提出了线性代数中很重要的一个概念：<code>linear combination</code></p><p>同时也引出一个很重要的问题，是不是对于<code>Ax=b</code>，是不是对于任何的b都有解？</p><p>为后续<code>奇异</code>，<code>可逆</code>的矩阵性质埋下伏笔</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h3><p>部分图片来自大佬的博客：<a href="https://rqtn.github.io/2019/08/11/LA-Lec01/">Lec01 - 方程组的几何解释</a></p>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT</tag>
      
      <tag>Linear Algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统数据复制模型(上)</title>
    <link href="/2022/10/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B-%E4%B8%8A/"/>
    <url>/2022/10/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所有内容来自美团技术团队</p><p><a href="https://tech.meituan.com/2022/08/25/replication-in-meituan-01.html">Replication（上）：常见复制模型&amp;分布式系统挑战 - 美团技术团队 (meituan.com)</a></p><h2 id="为什么需要进行复制"><a href="#为什么需要进行复制" class="headerlink" title="为什么需要进行复制"></a>为什么需要进行复制</h2><ul><li><p>系统的扩展性</p><ul><li>数据量读写负载增加，需要<strong>横向扩展</strong></li></ul></li><li><p>系统的可用性以及容错性（高可用）</p><ul><li>单机故障在分布式系统中是常态，希望复制做到冗余备份，能够<strong>及时接管故障机器</strong></li></ul></li><li><p>统一的用户体验</p><ul><li>多地部署服务，这个时候也是需要复制</li></ul></li></ul><h2 id="复制的方式和目的"><a href="#复制的方式和目的" class="headerlink" title="复制的方式和目的"></a>复制的方式和目的</h2><h3 id="复制的方式"><a href="#复制的方式" class="headerlink" title="复制的方式"></a>复制的方式</h3><p>数据的多机分布的方式主要有两种：</p><p>一种是将数据分片保存，每个机器保存数据的部分分片（Kafka中称为Partition，其他部分系统称为Shard）</p><p>另一种则是完全的冗余，其中每一份数据叫做一个副本（Kafka中称为Replica），通过数据复制技术实现。</p><p>在分布式系统中，两种方式通常会<strong>共同使用</strong>，最后的数据分布往往是下图的样子，一台机器上会保存不同数据分片的若干个副本。这里主要探讨如何进行数据的复制</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/1a0f88b2d8ff9019da609b765bc7eaca34503.png" alt="图1 常见数据分布"></p><h3 id="复制的目的"><a href="#复制的目的" class="headerlink" title="复制的目的"></a>复制的目的</h3><p>复制的目标需要保证<strong>若干个副本上的数据是一致的</strong>，这里的“一致”是一个<strong>十分不确定的词</strong></p><p>从最终复制的结果来看，主要是有两种形式：</p><ul><li><strong>强一致性</strong>角度<ul><li><strong>任何时候</strong>不同客端都能访问到<strong>相同的新的数据</strong></li></ul></li><li><strong>最终一致性</strong>，可用性角度<ul><li>不同客户端某一时刻访问的数据不相同，但<strong>在一段时间后可以访问到相同的数据</strong>（强调的是最终能实现一致，但是具体什么时候，我不知道）</li></ul></li></ul><hr><p>此时，大家可能会有疑问，直接让所有副本在任意时刻都保持一致不就行了，为啥还要有各种不同的一致性呢？</p><p>我们认为有两个考量点，第一是性能，第二则是复杂性。</p><p><strong>性能</strong>比较好理解，因为冗余的目的<strong>不完全是为了高可用，还有延迟和负载均衡这类提升性能的目的</strong>，如果只<strong>一味地为了地强调数据一致，可能得不偿失</strong>。</p><p><strong>复杂性</strong>是因为分布式系统中，有着比单机系统更加复杂的不确定性，<strong>节点之间由于采用不大可靠的网络进行传输</strong>，并且不能共享统一的一套系统时间和内存地址（后文会详细进行说明），这使得原本在一些单机系统上很简单的事情，在转到分布式系统上以后就变得异常复杂。这种复杂性和不确定性甚至会让我们怀疑，这些副本上的数据真的能达成一致吗？</p><h2 id="数据复制模式"><a href="#数据复制模式" class="headerlink" title="数据复制模式"></a>数据复制模式</h2><p>常见的数据复制模式主要有三种</p><ul><li>主从模式</li><li>多Leader模式</li><li>无Leader模式</li></ul><h3 id="主从模式——最简单的复制模式"><a href="#主从模式——最简单的复制模式" class="headerlink" title="主从模式——最简单的复制模式"></a>主从模式——最简单的复制模式</h3><p>这是最简单的方式</p><p>核心思想在于赋予多个副本不同的<strong>角色</strong></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>我们常说主从架构中的主，是指主副本。主副本将数据存储在本地后，<strong>将数据更改作为日志，或者以更改流的方式发到各个从副本</strong>（后文也会称节点）中。</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>读取数据一致性问题无法保证</p><p>网络传输的时间开销不可忽略</p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/c6a4c47606226ed3664c162796d0006482842.png" alt="图2 同步复制与异步复制" style="zoom: 80%;" /><p>上述出现了<strong>异步复制</strong>和<strong>同步复制</strong>两种完全不同的复制方式（概念）</p><p>可能读到旧值，这个其实有专门的名称————<strong>复制滞后</strong></p><p>这是因为在异步复制中，由于写请求写到主副本就返回成功，在数据复制到其他副本的过程中，如果客户端进行读取，在不同副本读取到的数据可能会不一致，《DDIA》将这个种现象称为复制滞后（Replication Lag），存在这种问题的复制行为<strong>所形成的数据一致性统称为最终一致性</strong>。</p><h4 id="一致性的解决方式"><a href="#一致性的解决方式" class="headerlink" title="一致性的解决方式"></a>一致性的解决方式</h4><p>两种做法可以参考</p><ul><li>Kafka当前的做法：所有客户端只能读主节点数据</li><li>采用<strong>同步复制</strong>的方式，任何一个副本同步的时候出现故障都会阻塞，同时要求<strong>每一次写请求都需要等待所有节点进行确认</strong></li></ul><p>还是有问题</p><ul><li>所有读请求全部打入主节点，主节点故障切换时还是会有不一致问题</li><li>第二种方案：副本过多时系统吞吐量极低，消耗性能</li></ul><p>很多系统都会采用<strong>半同步复制或异步复制来在可用性和一致性之间做权衡</strong></p><h4 id="需要的一些能力"><a href="#需要的一些能力" class="headerlink" title="需要的一些能力"></a>需要的一些能力</h4><h5 id="追加新的从节点"><a href="#追加新的从节点" class="headerlink" title="追加新的从节点"></a>追加新的从节点</h5><ul><li>在Kafka中，我们所采取的的方式是通过新建副本分配的方式，以追赶的方式从主副本中同步数据。</li><li>而经常使用的数据库，所采用的方式则是通过<code>快照(snapshot)+增量更新同步</code>的方式来实现从节点数据的同步追赶，具体的操作实现步骤如下👇<ul><li>在某一个时间点产生一个一致性的快照</li><li>将快照拷贝到新创建的从节点</li><li>由于上述过程存在一定的网络传输时间，在这个过程中还存在一些增量更新，<strong>因此从节点会连接到主节点请求所有快照点后发生的改变日志</strong></li><li>获取到日志后，应用日志到自己的副本中，称之为追赶</li></ul></li><li>相比Kafka，数据库是将一段时间间隔内的数据抽取成了一个<code>snapshot</code>的形式，之后多余的零散数据再进行<strong>追赶同步</strong></li></ul><h5 id="处理从节点失效"><a href="#处理从节点失效" class="headerlink" title="处理从节点失效"></a>处理从节点失效</h5><p>这里一般采取的就是<strong>追赶式恢复</strong></p><p>下面还是从两个具体应用角度来看</p><ul><li>对于数据库而言，从节点可以知道在崩溃前所执行的最后一个事务，然后连接主节点，从该节点将拉取所有的事件变更，将这些变更应用到本地记录即可完成追赶。</li><li>对于Kafka而言，恢复也是类似的，Kafka在运行过程中，会定期向磁盘文件中写入<code>checkpoint</code>，共包含两个文件，一个是recovery-point-offset-checkpoint，记录已经写到磁盘的offset，另一个则是replication-offset-checkpoint，用来记录高水位（下文简称HW），由ReplicaManager写入，下一次恢复时，Broker将读取两个文件的内容，可能有些被记录到本地磁盘上的日志没有提交，这时就会先截断（Truncate）到HW对应的offset上，然后从这个offset开始从Leader副本拉取数据，直到认追上Leader，被加入到ISR集合中</li></ul><h5 id="处理主节点失效"><a href="#处理主节点失效" class="headerlink" title="处理主节点失效"></a>处理主节点失效</h5><ol><li>确认主节点失效，由于失效的原因有多种多样，大多数系统会采用超时来判定节点失效。一般都是采用节点间互发心跳的方式，如果发现某个节点在较长时间内无响应，则会认定为节点失效。具体到Kafka中，它是通过和Zookeeper（下文简称ZK）间的会话来保持心跳的，在启动时Kafka会在ZK上注册临时节点，此后会和ZK间维持会话，假设Kafka节点出现故障（这里指被动的掉线，不包含主动执行停服的操作），当会话心跳超时时，ZK上的临时节点会掉线，这时会有专门的组件（Controller）监听到这一信息，并认定节点失效。</li><li>选举新的主节点。这里可以通过通过选举的方式（民主协商投票，通常使用共识算法），或由某个特定的组件指定某个节点作为新的节点（Kafka的Controller）。在选举或指定时，需要尽可能地让新主与原主的差距最小，这样会最小化数据丢失的风险（让所有节点都认可新的主节点是典型的共识问题）——这里所谓共识，就是让一个小组的节点就某一个议题达成一致，下一篇文章会重点进行介绍。</li><li>重新配置系统是新的主节点生效，这一阶段基本可以理解为对集群的元数据进行修改，让所有外界知道新主节点的存在（Kafka中Controller通过元数据广播实现），后续及时旧的节点启动，也需要确保它不能再认为自己是主节点，从而承担写请求。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CS_Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>基础架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PS2 OPL+SMB指南</title>
    <link href="/2022/10/12/PS2-OPL-SMB%E6%8C%87%E5%8D%97/"/>
    <url>/2022/10/12/PS2-OPL-SMB%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PS2 作为我最喜欢的主机，其软件阵容堪称豪华，几乎所有类型的游戏都可以在这个平台找到，和现在 PS5 世代的比起来完全不是一个级别的。</p><p>我自己收藏了三台 PS2，一台 50006，一台国行 50009 还有一台墨西哥特供版 70011，但是由于 PS2 因为年代久远，光驱基本上有点危险了，前几天读自己刻的影之心，玩了一晚上，第二天再读取，死活就是读取不出来，于是想着把自己的那几台直接改成硬盘启动玩游戏，反正自己收藏的光盘也不会拿出来读，光驱基本上可以退休了。</p><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><p>PS2主机一台</p><ul><li>如果是厚机，则需要自备网卡。</li><li>如果是薄机，不需要额外网卡，内置网卡。</li><li>如果你不知道什么是厚机什么是薄机，网上很多文章列举所有 PS2 Model，建议有个常识。</li></ul><p>引导卡一个</p><ul><li>具体制作会在下面展开讲述。</li></ul><p>电脑一台</p><ul><li>没有网线口的（比如说我）需要买一个拓展坞。</li><li>有网线口的继续往下看。</li></ul><h2 id="玩游戏的方式"><a href="#玩游戏的方式" class="headerlink" title="玩游戏的方式"></a>玩游戏的方式</h2><p>通过免光驱玩游戏我们需要用到 OPL，具体什么是 OPL 下面会介绍。</p><p>OPL 支持多种方式进行游戏：</p><ul><li>USB 设备</li><li>PS2 HDD（厚机专属，因为只有厚机在不改机的情况下可以接入 IDE 并口网卡）</li><li>SMB 网络共享</li></ul><p>这里我最推荐的方式就是 SMB 共享的方式，理由如下：</p><ul><li>第一种 USB 设备的方式几乎不太可能，因为 PS2 的 USB port 是 <strong>USB1.1</strong> 的口，传输速度极慢，在读取大型游戏数据（比如 CG 动画，特别是 SE 家的，数据大小都不小）的时候会因为速度不够而导致卡死，从而无法正常进行游戏。</li><li>第二种方式，首先你需要是一台厚机，其次你需要买一个原装网卡，再次你需要一个 IDE 硬盘。如果你觉得 IDE 已经被淘汰了（当然确实也是），去买组装的 SETA 接口的网卡并不能保证可以用很久，而且这一套下来的成本挺大。当然也有他的优点，那就是极少数的汉化游戏（比如 FF12 的汉化版本）在汉化破解的时候对 OPL 的 SMB 兼容做的不是很好，导致有 BUG，目前已知 FF12 汉化版不能用 SMB 玩，只能用硬盘玩，因此 HDD 的方式兼容性是最好的，但是成本高，富哥们推荐。</li></ul><p>SMB 方式非常推荐，因为他本身只需要一个原装网卡，<strong>如果你是薄机，那么甚至都不需要任何额外的材料</strong>，只需要一台笔记本+网线即可。</p><h2 id="自制系统运行OPL"><a href="#自制系统运行OPL" class="headerlink" title="自制系统运行OPL"></a>自制系统运行OPL</h2><p>[OPL是一个开源项目] (<a href="https://github.com/ps2homebrew/Open-PS2-Loader">https://github.com/ps2homebrew/Open-PS2-Loader</a>)</p><p>如果想要自己折腾安装 OPL 的话请参考官方文档，这里直接采取最简单最快的方案。</p><p>先简单介绍一下OPL，其实就是翻译一下官方文档（</p><blockquote><p>OPL本质上其实是一个自制程序加载器，它支持三大存储设备</p><ul><li><p>USB硬盘设备</p></li><li><p>SMB网络共享</p></li><li><p>PS2专属硬盘</p><p>USB 设备和 SMB 共享支持 USBExtreme 和 *.ISO 格式</p><p>而 PS2 硬盘支持 HDLoader 格式</p><p>所有设备也支持 ZSO 格式（压缩 ISO）。</p></li></ul></blockquote><p>最终只有通过核心的 OPL 我们才能运行游戏来进行免光盘游玩。</p><p>主要有三种方式运行OPL。</p><h3 id="从工具盘中运行OPL"><a href="#从工具盘中运行OPL" class="headerlink" title="从工具盘中运行OPL"></a>从工具盘中运行OPL</h3><p>这个方案<strong>要求机器需要带有直读</strong>，能正常读取自己刻录的光盘，如果光头坏了就参考下面其他的方案罢。（悲）</p><p>主要需要就是自己刻录一份然后丢到机器中运行，由于我本身并不采用这一种，因此也没有进行尝试，推荐FMCB。</p><h3 id="手动制作-FMCB-（需要有一个FMCB的卡作为基础）"><a href="#手动制作-FMCB-（需要有一个FMCB的卡作为基础）" class="headerlink" title="手动制作 FMCB （需要有一个FMCB的卡作为基础）"></a>手动制作 FMCB （需要有一个FMCB的卡作为基础）</h3><p>如果您的记忆卡空间足够，可以准备一份Free MCBoot（FMCB）的安装包。</p><p>放到 FAT32 格式的U盘上，利用<strong>工具盘</strong>中的 LaunchELF 等文件管理工具将 FMCB 安装到记忆卡上，安装完毕后，当PS2插入这张记忆卡启动时，就会启动到 FMCB 界面，FMCB 可以简单类比为 PS2 的 Homebrew Channel，FMCB一般自带 OPL，在系统菜单选择启动即可。</p><p>但是这种方式需要你有一个已经制作好了的可以运行 FMCB 安装包的手段（比如工具盘，或者是制作好了的引导卡），是通过 OPL引导卡来制作 OPL 引导卡XD</p><p>所以这种方式大家知道一下就好，这里我们直接用第三种也是最常见的方式。</p><h3 id="钞能力，直接买做好的FMCB"><a href="#钞能力，直接买做好的FMCB" class="headerlink" title="钞能力，直接买做好的FMCB"></a>钞能力，直接买做好的FMCB</h3><p>由于我本身的两个记忆卡都是原装的，舍弃掉一个来做引导卡，有点肉疼。</p><p>因此这里直接上 TB 买一个做好了的FMCB。</p><h2 id="SMB-配置"><a href="#SMB-配置" class="headerlink" title="SMB 配置"></a>SMB 配置</h2><p>我们需要一个机器作为 SMB 服务端，这里可以是电脑也可以是<strong>带有 SMB 共享的路由器</strong>。</p><p>因为本身玩游戏的时候我就习惯录制，电脑必须开着，因此这里我就直接用电脑当作 SMB 服务端了，这也是最简单的方案。</p><h3 id="打开-windows-的-SMB-共享功能"><a href="#打开-windows-的-SMB-共享功能" class="headerlink" title="打开 windows 的 SMB 共享功能"></a>打开 windows 的 SMB 共享功能</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230106164108382.png"></p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230106164132719.png"></p><h3 id="指定-ROM-进行分享"><a href="#指定-ROM-进行分享" class="headerlink" title="指定 ROM 进行分享"></a>指定 ROM 进行分享</h3><p>找到你放置 ROM 的文件夹，右键–属性–共享</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230106164320689.png"></p><p>添加 Everyone，权限为读取&#x2F;写入</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230106164344563.png"></p><p>高级共享设置</p><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20230106164557595.png"></p><h3 id="分配网卡-IP"><a href="#分配网卡-IP" class="headerlink" title="分配网卡 IP"></a>分配网卡 IP</h3><p>我这里是通过 USB 网卡+网线直连 PS2 实现的连接。</p><p>因此这里在电脑上为这个网卡配置好 IPV4 的地址和子网掩码，随便分配，只要不要和你当前网络环境下的机器 IP 冲突就行。</p><p>电脑端配置完毕，进入 OPL 的配置。</p><h2 id="OPL配置"><a href="#OPL配置" class="headerlink" title="OPL配置"></a>OPL配置</h2><p>通过 FMCB 进入到 OPL 之后，需要完成 SMB 的配置。</p><p>到 OPL 中配置 SMB 的 Server 为刚刚电脑网卡配置的地址，然后配置 PS2 的机器IP地址，<strong>要求和电脑USB网卡处在同一个网段</strong>。比如电脑网卡分配的是<code>192.168.1.2</code>，那么PS2可以分配<code>192.168.1.6</code>。</p><p>之后指定上面 SMB 分享的目录名称（比如我上面就是 PS2）即可看到游戏数据列表。</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PS2</tag>
      
      <tag>OPL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
